

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/ap0l1o.png">
  <link rel="icon" href="/img/ap0l1o.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Makefile基础知识整理。">
  <meta name="author" content="ap0l1o">
  <meta name="keywords" content="">
  
  <title>Makefile的基本编写 - ap0l1o</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Ap0l1o</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                大概
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E6%8A%80%E6%9C%AF/">
                    
                    技术
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E7%94%9F%E6%B4%BB/">
                    
                    生活
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/">
                    
                    书影音
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E8%AE%BA%E6%96%87/">
                    
                    论文
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/running/">
                
                跑步
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/hello.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Makefile的基本编写">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-11 11:28" pubdate>
        2023年2月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      80
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Makefile的基本编写</h1>
            
            <div class="markdown-body">
              <h2 id="Makefile-的组成"><a href="#Makefile-的组成" class="headerlink" title="Makefile 的组成"></a>Makefile 的组成</h2><ul>
<li>显示规则：显示规则说明了如何生成目标文件</li>
<li>隐晦规则：make 有自动推导的功能，利用隐晦规则可以简写makefile</li>
<li>变量的定义：在 makefile 中可以定义一系列变量，变量一般为字符串，makefile 中的变量类似 C/C++中的宏，当 makefile 执行时，变量都会被其定义的字符串所替换</li>
<li>文件指示：包括三部分，一个是在一个 makefile 中引用另一个 makefile，类似 C/C++中的 <code>#include</code>；另一个是根据某些情况指定 makefile 中的有效部分，类似 C/C++中的预编译 <code>#if</code>；最后一个是定义一个多行的命令</li>
<li>注释：makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，注释也是使用 <code>#</code> 字符</li>
</ul>
<h2 id="Makefile-的文件名"><a href="#Makefile-的文件名" class="headerlink" title="Makefile 的文件名"></a>Makefile 的文件名</h2><p>默认情况下，make 命令会在当前目录下按顺序查找文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到后解释执行。<br>三种命名方式中推荐使用“Makefile”来命名，此种命名方式更为醒目和通用。当然我们也可以使用其他的文件名来命名 Makefile 文件，使用其他命名方式时需要使用 make 命令的 <code>-f</code> 参数来指定要解释执行 Makefile 文件。</p>
<h2 id="Makefile-书写规则"><a href="#Makefile-书写规则" class="headerlink" title="Makefile 书写规则"></a>Makefile 书写规则</h2><p>规则包含两个部分：一个是依赖关系，另一个是生成目标的方法。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">targets  : prerequisites # 第一部分<br>	commands # 第二部分<br></code></pre></div></td></tr></table></figure>

<ul>
<li>targets : 可以是目标文件，也可以是执行文件，还可以是标签，目标可以是一个文件也可以是多个文件，多个文件的话用空格分开</li>
<li>prerequisites : 生成 target 所依赖的文件，同样可以是多个文件，多个文件的话用空格分开</li>
<li>command ：要执行的命令，必须以 <code>Tab</code> 键开头，如果命令过长则可以使用反斜杠 <code>\</code> 作为换行符<br>这是一个文件的依赖关系，目标文件 targets 依赖于 prerequisites 文件，其生成规则定义在 command 中，也即：当 prerequisites 中存在比 targets 中更新的文件时（或者当 targets 文件不存在时），就会执行 command 命令来生成新的 targets 文件。</li>
</ul>
<h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><p>在一些大的工程中，存在大量的源文件，通常的做法是把这许多的源文件进行分类并存放在不同的目录中。所以，当 make 指令需要去寻找文件的依赖关系时，我们需要在依赖关系中使用每个文件的完整路径，但最好的方法是将依赖关系中的文件可能存在的路径告诉 make，让 make 去自动查找。<br>告诉 make 文件查找路径的方法有两种。第一种是在 Makefile 文件中使用特殊变量 <code>VPATH</code>，如果没有设置这个变量，则 make 只会在当前的目录中去寻找依赖文件和目标文件。如果定义了这个变量，则当 make 在当前目录找不到依赖文件和目标文件时，就会去该变量指定的路径下查找。</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">VPATH</span> = src:../headers<br></code></pre></div></td></tr></table></figure>
<p>通过 <code>VPATH</code> 变量可以设置多个查找目录，多个查找目录之前使用冒号分割，并按设置的顺序查找。上述示例指定了两个查找目录，分别是“src”目录和“../headers”目录。<br>另一种设置文件搜索路径的方法是使用 make 指令的“vpath”关键字。它可以指定不同的文件在不同的搜索目录中，它的使用方法有三种：</p>
<ul>
<li><code>vpath &lt;pattern&gt; &lt;directories&gt;</code> ：为符合模式 <code>&lt;pattern&gt;</code> 的文件指定搜索目录为 <code>&lt;directories&gt;</code> (也即告诉 make 在指定的搜索目录中去搜索符合指定模式的文件)</li>
<li><code>vpath &lt;pattern&gt;</code> ：清除符合模式 <code>&lt;pattern&gt;</code> 的文件的搜索目录</li>
<li><code>vpath</code> ：清除所有已被设置的文件搜索目录<br><code>&lt;pattern&gt;</code> 指定了需要搜索的文件集，而 <code>&lt;directories&gt;</code> 则指定了要去哪里搜索需要的文件集。注意，<code>vpath</code> 使用方法中的 <code>&lt;pattern&gt;</code> 需要包含 <code>%</code> 字符，该字符的意思是「匹配零或多个字符」。例如，<code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">vpath %<span class="hljs-string">.h</span> <span class="hljs-string">../headers</span><br></code></pre></div></td></tr></table></figure>
<p>上述示例表示如果在当前目录下没有找到所需的 <code>.h</code> 文件，则去 “../headers”目录下去查找。</p>
<h3 id="伪目标文件"><a href="#伪目标文件" class="headerlink" title="伪目标文件"></a>伪目标文件</h3><p>在 makefile 文件中通常存在一个名为「clean」的目标，这是一个伪目标。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">clean:</span><br>	rm *.o main<br></code></pre></div></td></tr></table></figure>
<p>如上所示，我们通常需要提高一个清除所有目标文件以便完整重新编译的「clean」目标，并通过「make clean」来使用该目标。<br>因为我们并不生成“clean”这个文件，所以说“伪目标”并不是一个文件，而只是一个标签。而由于“伪目标”并不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效，这里也即使用 <code>make clean</code> 指令来使用「clean」目标。<br>当然，“伪目标”的取名不能和已有的文件名重名，不然就失去了“伪目标”的意义了。为了避免重名的情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显式地指明一个目标是“伪目标”，以向 make 说明，不管是否有这个文件，这个目标就是一个“伪目标”。只要有这个声明，只有使用 <code>make clean</code> 才能运行这个目标。示例如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">.PHONY</span> : clean<br><br>clean:<br>	rm *<span class="hljs-string">.o</span> main<br></code></pre></div></td></tr></table></figure>
<h3 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h3><p>在 Makefile 中，我们的依赖关系常常包含一系列的头文件。特别是在一个比较大型的工程中，我们需要搞清楚哪些 C/C++文件包含了哪些头文件，并且在加入或者删除头文件时也需要小心修改 Makefile，这增加了维护 Makefile 的难度。<br>为了避免这种繁重而又容易出错的事情，我们可以使用 C/C++编译的一个功能来帮助我们梳理这些包含关系。大多数的 C/C++编译器都支持一个 <code>-M</code> 选项，来自动找寻源文件中包含的头文件，并生成一个依赖关系（如果使用 GNU 的 C/C++编译器，需要使用 <code>-MM</code> 参数，不然 <code>-M</code> 参数会把一些标准库的头文件也包含进来）。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// main.cc文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;header/header.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print_hello</span>();<br>&#125;<br><br><span class="hljs-comment">// header.h文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HEADER_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEADER_H_</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_hello</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>执行 <code>g++ -MM main.cc</code> 的输出结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cc</span> header/<span class="hljs-selector-tag">header</span>.h<br></code></pre></div></td></tr></table></figure>
<p>GNU 组织建议把编译器为每一个源文件自动生成的依赖关系放到一个文件中，为每一个 <code>name.cc</code> 的文件都生成一个 <code>name.d</code> 的 Makefile 文件，<code>.d</code> 文件中就存放对应 <code>.cc</code> 文件的依赖关系。<br>于是，我们就可以写出 <code>.cc</code> 文件和 <code>.d</code> 文件的依赖关系，并让 make 自动更新或生成 <code>.d</code> 文件，并将其包含在我们的主 Makefile 中，这样我们就可以自动化地生成每个文件的依赖关系了。示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">SRCS = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cc)</span> <span class="hljs-comment"># 源文件</span><br>OBJS = $(SRCS:.cc=.o) <span class="hljs-comment"># 目标文件 </span><br>DEPS = $(SRCS:.cc=.d) <span class="hljs-comment"># 依赖关系文件</span><br><br>CC = g++<br>CPPFLAGS = -c -g -Wall -I./header<br><br>.PHONY : all clean cleand<br><br>all : main<br><br>main : <span class="hljs-variable">$(OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o  <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 引入依赖关系，该依赖关系是完整的，这能保证当依赖文件更新后能及时更新目标文件</span><br><span class="hljs-comment"># 隐晦规则会自动使用CPPFLAGS变量</span><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEPS)</span><br><br><span class="hljs-comment"># 依赖关系的.d文件尚未生成时会执行该命令生成.d文件</span><br>%.o : %.cc<br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$&lt;</span> -MMD -MP<br><br><span class="hljs-section">clean:</span><br>	rm *.o main<br><br><span class="hljs-section">cleand:</span><br>	rm *.d<br></code></pre></div></td></tr></table></figure>
<h2 id="Makefile-中的命令"><a href="#Makefile-中的命令" class="headerlink" title="Makefile 中的命令"></a>Makefile 中的命令</h2><p>在 Makefile 中，每条规则中的命令和操作系统 Shell 的命令行是一致的，make 会按顺序一条一条的执行命令，每条命令必须以 <code>Tab</code> 键开头（除非命令是紧跟在依赖规则后面的分号后的）。<br>我们在 UNIX 下可能会使用不同的 Shell，但是 Makefile 中的命令默认是被 <code>/bin/sh</code> （也即 UNIX 的标准 Shell）执行的。</p>
<h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>默认情况下，make 会把其要执行的命令行在命令执行钱打印到屏幕上。当我们在命令行前加上一个 <code>@</code> 字符时，这个命令将会取消打印到屏幕。</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>当依赖文件新于目标文件时，也就是依赖关系的目标文件需要被更新时，make 会一条一条的执行其后的命令。不过需要注意的是，如果我们希望让上一条命令的结果应用在下一条命令执行前时，则应该将这两条命令写在同一行中并使用「分号」来分割。</p>
<h3 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h3><p>每当一条命令执行完后，make 会检测每个命令的返回码，如果命令返回成功，那么 make 就会继续执行下一条命令。当一个规则中的所有命令都成功返回后，这个规则便成功完成了。如果一个规则中的某个命令出错了，那么 make 就会终止执行当前规则，默认情况下这会终止后续所有规则的执行。<br>但是，有些时候命令的出错并不表示就是错误的，我们需要忽略命令的出错。为了做到这一点我们可以在 Makefile 的命令行前加上一个减号 <code>-</code>，标记为不管命令执行是否出错都认为是成功的。例如：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">clean:</span><br>	-rm *.o main<br></code></pre></div></td></tr></table></figure>
<p>还有一种全局的方法，在执行 make 命令时加上 <code>-i</code> 或 <code>-ignore-errors</code> 参数，那么 Makefile 中的所有命令都会忽略错误。<br>make 命令的另一个参数 <code>-k</code> 或 <code>-keep-going</code> 会终止出错规则的执行，但会继续执行后续其他规则。</p>
<h3 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h3><p>如果在 Makefile 中会重复执行一些相同的命令序列，则可以将这些重复执行的命令序列定义为一个命令包。定义语法和使用方法如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义，name为定义的命令包变量的名字</span><br><span class="hljs-keyword">define</span> name <br>commands ...<br><span class="hljs-keyword">endef</span><br><br><span class="hljs-comment"># 使用，和普通变量的使用方法相同</span><br>main : main.c<br>	<span class="hljs-variable">$(name)</span><br><br></code></pre></div></td></tr></table></figure>
<p>make 在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="Makefile-中的变量"><a href="#Makefile-中的变量" class="headerlink" title="Makefile 中的变量"></a>Makefile 中的变量</h2><p>在 Makefile 中定义的变量类似 C/C++中的「宏」，它代表了一个文本字符串，Makefile 在执行的时候会自动在使用变量的地方替换为其所代表的字符串。<br>变量名可以包含字符、数字和下划线，但是不能含有 <code>:</code>、<code>#</code>、<code>=</code> 或空字符（空格、Tab 和回车等）。且变量名是大小写敏感的。<br>变量在声明的时候就需要给予初值，而在使用时需要在变量名前加上 <code>$</code> 字符，且最好使用小括号 <code>()</code> 或者大括号 <code>&#123;&#125;</code> 把变量名给包裹起来（在使用时给变量名加上括号只是为了更加安全地使用整个变量）。</p>
<h3 id="用变量定义变量"><a href="#用变量定义变量" class="headerlink" title="用变量定义变量"></a>用变量定义变量</h3><p>在定义变量的值时，可以使用其他变量来构造变量的值。Makefile 提供了两种方式来<strong>用变量定义变量的值</strong>。</p>
<h4 id="使用-定义"><a href="#使用-定义" class="headerlink" title="使用 = 定义"></a>使用 <code>=</code> 定义</h4><p>第一种方式就是简单的使用 <code>=</code> 来定义，等号的右侧是用来定义新变量值的变量。右侧的变量可以定义在文件的任何一处，也就是说在使用这个变量来定义另一个变量的值时，这个变量不一定是已经定义好的。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">varA = <span class="hljs-variable">$(varB)</span><br>varB = <span class="hljs-variable">$(varC)</span><br>varC = en?<br><br>.PHONY : all<br><br>all :<br>	echo <span class="hljs-variable">$(varA)</span><br></code></pre></div></td></tr></table></figure>
<p>这个功能的好处是可以把在定义变量时使用的变量推迟到后面进行定义，坏处是 kennel 会导致递归定义，进入死循环。例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">varA</span> = $(varB)<br><span class="hljs-attr">varB</span> = $(varA)<br></code></pre></div></td></tr></table></figure>

<h4 id="使用-定义-1"><a href="#使用-定义-1" class="headerlink" title="使用 := 定义"></a>使用 <code>:=</code> 定义</h4><p>为了避免第一种定义方式可能导致的递归定义问题，我们可以使用第二种定义方式，也即使用操作符 <code>:=</code>。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">varA := Hello<br>varB := <span class="hljs-variable">$(varA)</span> world!<br></code></pre></div></td></tr></table></figure>
<p>这种方式不会导致递归定义问题是因为这种方式不允许前面的变量使用后面的变量，也即一个变量只能使用在它之前已经定义好的变量。</p>
<h3 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h3><h4 id="操作符"><a href="#操作符" class="headerlink" title="?=  操作符"></a><code>?= </code> 操作符</h4><p>示例：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> ?= Hello world<br></code></pre></div></td></tr></table></figure>
<p>如上， <code>?=</code> 操作符的意思是，如果变量 <code>var</code> 没有被定义的话，那么 <code>var</code> 将被定义为 <code>Hello world</code>，如果 <code>var</code> 已被定义，则什么也不做。</p>
<h4 id="操作符-1"><a href="#操作符-1" class="headerlink" title="+= 操作符"></a><code>+=</code> 操作符</h4><p>我们可以使用 <code>+=</code> 操作符来为一个变量追加值，例如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">src <span class="hljs-operator">=</span> a.<span class="hljs-keyword">cc</span> b.<span class="hljs-keyword">cc</span> d.<span class="hljs-keyword">cc</span><br>src +<span class="hljs-operator">=</span> e.<span class="hljs-keyword">cc</span><br></code></pre></div></td></tr></table></figure>
<p>则变量 <code>src</code> 的值为 <code>a.cc b.cc d.cc e.cc</code>。=</p>
<h4 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h4><p>我们可以替换变量中共有的部分，方法是使用 <code>$(var:a=b)</code> 或者 <code>$&#123;var:a=b&#125;</code>，其意思是：把变量 <code>var</code> 中所有以字符 <code>a</code> 结尾的字符串替换为以 <code>b</code> 结尾的字符串。例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">src1 := <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.o</span><br>src2 := $(src1:o=c)<br></code></pre></div></td></tr></table></figure>
<p>在上面的例子中，第一行我们先定义了一个变量 <code>src1</code>，第二行我们将变量 <code>src1</code> 中所有以 <code>.o</code> 结尾的字符串替换成以 <code>.c</code> 结尾，并赋值给变量 <code>src2</code>，所以变量 <code>src2</code> 的值为 <code>a.c b.c</code>  。<br>还有一种变量替换的方式是以「静态模式」定义的，例如：</p>
<figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">src1 := a.o b.o<br>src2 := $(src1:%.o:%.c)<br></code></pre></div></td></tr></table></figure>
<p>这种方式依赖于被替换的字符串中具有相同的模式。</p>
<h4 id="把变量的值再作为变量"><a href="#把变量的值再作为变量" class="headerlink" title="把变量的值再作为变量"></a>把变量的值再作为变量</h4><p>我们可以将一个变量的值作为另一个变量的名字，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></div></td></tr></table></figure>
<p>在上面的例子中，<code>$(x)</code> 为 <code>y</code>，那么 <code>$($(x))</code> 就等于 <code>$(y)</code>，而变量 <code>y</code> 的值为 <code>z</code>，所以变量 a 的值为 <code>z</code>。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>系统环境变量可以在 make 运行时被载入到 Makefile 文件中。但是，如果 Makefile 中已经定义了同名的系统环境变量，或者这个变量由 make 命令行带入，那么系统环境变量的值将会被覆盖（如果 make 指定了 <code>-e</code> 参数，则系统环境变量将反过来覆盖 Makefile 中定义的同名变量）。<br>当 make 嵌套调用时，通过命令行设置的变量会以系统环境变量的方式传递到下层的 Makefile 中。而定义在文件中的变量，如果要向下层 Makefile 传递，则需要使用 <code>export</code> 关键字来声明。</p>
<h3 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h3><p>如果通过 make 的命令行参数设置了一个变量的值，则 Makefile 中对这个变量的赋值会被忽略。如果我们需要在 Makefile 中设置这类参数的值，那么我们可以使用 <code>override</code> 关键字。其语法是：</p>
<figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">override <span class="hljs-params">&lt;variable&gt;</span> = <span class="hljs-params">&lt;value&gt;</span><br><span class="hljs-meta"># 或</span><br>override <span class="hljs-params">&lt;variable&gt;</span> := <span class="hljs-params">&lt;value&gt;</span><br><span class="hljs-meta"># 同样可以追加</span><br>override <span class="hljs-params">&lt;variable&gt;</span> += <span class="hljs-params">&lt;value&gt;</span><br></code></pre></div></td></tr></table></figure>
<h3 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h3><p>我们前面所提到的变量都是指的全局变量，在整个 Makefile 文件中我们都可以访问这些变量。<br>我们也可以为某个目标设置局部变量，这种变量被称为「Target-specific Variable」，它可以和「全局变量」同名，因为它的作用范围只在指定目标所在的规则及其连带规则中，而不会影响到规则链以外的全局变量的值。例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"># 语法<br>&lt;target ... &gt; : &lt;variable-assignment&gt;<br><br># 示例<br><span class="hljs-keyword">prog</span> : CFLAGS = -<span class="hljs-keyword">g</span><br><span class="hljs-keyword">prog</span> : <span class="hljs-keyword">prog</span>.o<br>	$(<span class="hljs-keyword">CC</span>) $(CFLAGS) <span class="hljs-keyword">prog</span>.o<br><br><span class="hljs-keyword">prog</span>.o : <span class="hljs-keyword">prog</span>.c<br>	$(<span class="hljs-keyword">CC</span>) $(CFLAGS) <span class="hljs-keyword">prog</span>.c<br><br></code></pre></div></td></tr></table></figure>

<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><p>GNU 的 make 还支持「模式变量」（Pattern-specific Variable）。前面我们提到，我们可以将变量定义在某个目标上，而通过模式变量，我们可以将变量定义在符合这种模式的所有目标上。<br>例如，我们可以按照如下方式给所有以 <code>.o</code> 的目标定义目标变量（也即模式变量）：</p>
<figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-class">.o</span></span> : CFLAGS = -O<br></code></pre></div></td></tr></table></figure>

<h2 id="Makefile-条件判断"><a href="#Makefile-条件判断" class="headerlink" title="Makefile 条件判断"></a>Makefile 条件判断</h2><p>使用条件判断，我们可以让 make 根据运行时的不同情况选择不同的执行分支。条件表达式可以是<strong>比较变量的值</strong>，也可以是<strong>比较变量和常量的值</strong>。条件表达式的语法为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">&lt;conditional-directive&gt;<br>	&lt;<span class="hljs-built_in">text</span>-<span class="hljs-keyword">if</span>-<span class="hljs-literal">true</span>&gt;<br>endif<br><br><span class="hljs-comment"># 或</span><br>&lt;conditional-directive&gt;<br>	&lt;<span class="hljs-built_in">text</span>-<span class="hljs-keyword">if</span>-<span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">else</span><br>	&lt;<span class="hljs-built_in">text</span>-<span class="hljs-keyword">if</span>-<span class="hljs-literal">true</span>&gt;<br>endif<br></code></pre></div></td></tr></table></figure>
<p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，在 make 中有四个条件关键字：<code>ifeq</code> ，<code>ifneq</code>，<code>ifdef</code> 和 <code>ifndef</code>。分别表示「是否相等」以及「是否定义」。用法及示例如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs perl"><span class="hljs-comment"># 用法</span><br>ife<span class="hljs-string">q(&lt;arg1&gt;, &lt;arg2&gt;)</span><br>ifne<span class="hljs-string">q(&lt;arg1&gt;, &lt;arg2&gt;)</span><br>ifdef &lt;variable&gt;<br>ifndef &lt;variable&gt;<br><br><span class="hljs-comment"># 示例1</span><br>var = abc<br>ife<span class="hljs-string">q($(var)</span> abc)<br>	echo <span class="hljs-string">&quot;var&#x27;s value is abc&quot;</span><br><br><span class="hljs-comment"># 示例2</span><br>ifdef var<br>	echo <span class="hljs-string">&quot;var has defined&quot;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="Makefile-中的函数"><a href="#Makefile-中的函数" class="headerlink" title="Makefile 中的函数"></a>Makefile 中的函数</h2><p>在 Makefile 中可以使用函数来处理变量，函数调用后的返回值也可以当作变量来使用。<br>在 Makefile 中，函数的调用类似变量的使用，也是用 <code>$</code> 来标识的，语法如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">$(<span class="hljs-params">&lt;function&gt;</span> <span class="hljs-params">&lt;arguments&gt;</span>)<br><br><span class="hljs-meta"># 或</span><br>$&#123;<span class="hljs-params">&lt;function&gt;</span> <span class="hljs-params">&lt;arguments&gt;</span>&#125;<br></code></pre></div></td></tr></table></figure>
<p>其中，<code>&lt;function&gt;</code> 代表函数名，<code>&lt;arguments&gt;</code> 代表函数调用需要的参数，多个参数之间使用逗号 <code>,</code> 分隔，而函数名和参数之间用「空格」分隔。函数中的参数也可以使用变量。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><h4 id="subset"><a href="#subset" class="headerlink" title="subset"></a>subset</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">subset</span> &lt;<span class="hljs-params">from</span>&gt;,&lt;<span class="hljs-params">to</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：字符串替换函数</li>
<li>功能：把字符串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换为 <code>&lt;to&gt;</code></li>
<li>返回：返回被替换后的字符串</li>
</ul>
<h4 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> &lt;<span class="hljs-params">pattern</span>&gt;,&lt;<span class="hljs-params">replacement</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：模式字符串替换函数</li>
<li>功能：把字符串 <code>&lt;text&gt;</code> 中符合模式 <code>&lt;pattern&gt;</code> 的字符串替换为 <code>&lt;replacement&gt;</code></li>
<li>返回：返回被替换后的字符串</li>
<li>示例：<code>$(patsubst %.c, %.o, main.c)</code></li>
</ul>
<h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">$(<span class="hljs-keyword">strip</span> &lt;<span class="hljs-keyword">string</span>&gt;)<br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：去空格函数</li>
<li>功能：去掉 <code>&lt;string&gt;</code> 字符串中开头和结尾的空字符</li>
<li>返回：返回被去掉空格后的字符串值</li>
</ul>
<h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">findstring</span> &lt;<span class="hljs-params">find</span>&gt;,&lt;<span class="hljs-params">in</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：查找字符串函数</li>
<li>功能：在字符串 <code>&lt;in&gt;</code> 中查找 <code>&lt;find&gt;</code> 字符串</li>
<li>返回：如果找到，则返回 <code>&lt;find&gt;</code> 否则返回空字符串</li>
</ul>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">filter</span> &lt;<span class="hljs-params">pattern</span>&gt;, &lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：过滤函数</li>
<li>功能：返回字符串 <code>&lt;text&gt;</code> 中符合模式 <code>&lt;pattern&gt;</code> 的字符串</li>
</ul>
<h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">filter</span>-<span class="hljs-params">out</span> &lt;<span class="hljs-params">pattern</span>&gt;, &lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：反过滤函数</li>
<li>功能：返回字符串 <code>&lt;text&gt;</code> 中不符合模式 <code>&lt;pattern&gt;</code> 的字符串</li>
</ul>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">sort</span> &lt;<span class="hljs-params">list</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：排序函数</li>
<li>功能：对字符串 <code>&lt;list&gt;</code> 中的单词进行排序（升序），并返回排序后的字符串（该函数会去掉 <code>&lt;list&gt;</code> 中重复的单词）</li>
</ul>
<h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">word</span> &lt;<span class="hljs-params">n</span>&gt;, &lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取单词函数</li>
<li>功能：从 1 开始取单词 <code>&lt;text&gt;</code> 中的第 <code>n</code> 个单词并返回，如果 <code>n</code> 超过单词数量则返回空字符串</li>
</ul>
<h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">wordlist</span> &lt;<span class="hljs-params">n1</span>&gt;,&lt;<span class="hljs-params">n2</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取字符串函数</li>
<li>功能：从字符串 <code>&lt;text&gt;</code> 中取从第 <code>n1</code> 到 <code>n2</code> 的字符串并返回（也是从 1 开始计数）</li>
</ul>
<h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">words</span> &lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：单词个数统计函数</li>
<li>功能：统计 <code>&lt;text&gt;</code> 中单词的个数并返回</li>
</ul>
<h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">firstword</span> &lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取首单词函数</li>
<li>功能：取字符串 <code>&lt;text&gt;</code> 中的首单词并返回</li>
</ul>
<h3 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h3><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">dir</span> &lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取目录函数</li>
<li>功能：从一系列文件的全路径中取出路径部分并返回（也即最后一个斜杠 <code>/</code> 前的部分）</li>
</ul>
<h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">nodir</span> &lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取文件名函数</li>
<li>功能：从一系列文件的全路径中取出文件名并返回（也即最后一个斜杠 <code>/</code> 后的部分）</li>
</ul>
<h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">suffix</span> &lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取后缀函数</li>
<li>功能：从文件名序列中取出文件名后缀并返回，如果文件名无后缀则返回空字符串</li>
</ul>
<h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">basename</span> &lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：取文件名前缀函数</li>
<li>功能：从一系列文件名中取出文件名的前缀并返回</li>
</ul>
<h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">addsuffix</span> &lt;<span class="hljs-params">suffix</span>&gt;,&lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：添加后缀函数</li>
<li>功能：为 <code>&lt;names&gt;</code> 中的每个文件名添加后缀 <code>&lt;suffix&gt;</code> 并返回</li>
</ul>
<h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">addprefix</span> &lt;<span class="hljs-params">prefix</span>&gt;,&lt;<span class="hljs-params">names</span> <span class="hljs-operator">...</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：添加前缀函数</li>
<li>功能：为 <code>&lt;names&gt;</code> 中的每个文件名添加前缀 <code>&lt;prefix&gt;</code> 并返回</li>
</ul>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">join</span> &lt;<span class="hljs-params">list1</span>&gt;,&lt;<span class="hljs-params">list2</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>名称：连接函数</li>
<li>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中</li>
<li>返回：返回连接过后的字符串</li>
</ul>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">foreach</span> &lt;<span class="hljs-params">var</span>&gt;,&lt;<span class="hljs-params">list</span>&gt;,&lt;<span class="hljs-params">text</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>功能：将参数 <code>&lt;list&gt;</code> 中的每个单词逐一去取出来放到参数 <code>&lt;var&gt;</code> 所指定的变量中，然后执行 <code>&lt;text&gt;</code> 所包含的表达式。</li>
<li>返回：每次 <code>&lt;text&gt;</code> 的执行都会返回一个字符串，全部执行完毕后字符串用空格拼接后返回</li>
</ul>
<h4 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">if</span> &lt;<span class="hljs-params">condition</span>&gt;,&lt;<span class="hljs-params">then</span>-<span class="hljs-params">part</span>&gt;)</span><br># 或<br><span class="hljs-constructor">$(<span class="hljs-params">if</span> &lt;<span class="hljs-params">condition</span>&gt;,&lt;<span class="hljs-params">then</span>-<span class="hljs-params">part</span>&gt;,&lt;<span class="hljs-params">else</span>-<span class="hljs-params">part</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>功能：<code>&lt;condition&gt;</code> 成立则返回 <code>&lt;then-part&gt;</code>，否则，存在 <code>&lt;else-part&gt;</code> 则返回 <code>&lt;else-part&gt;</code>，不存在则返回空字符串</li>
</ul>
<h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">shell</span> &lt;<span class="hljs-params">command</span>&gt;)</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>功能：执行操作系统命令 <code>&lt;command&gt;</code>，并将执行结果的输出返回</li>
</ul>
<h2 id="Makefile-隐含规则"><a href="#Makefile-隐含规则" class="headerlink" title="Makefile 隐含规则"></a>Makefile 隐含规则</h2><p>「隐含规则」也就是一种惯例，make 会按照这种惯例心照不宣地来运行，即使我们的 Makefile 中没有书写这样的规则。<br>隐含规则会使用一些我们的系统变量，我们可以设置这些系统变量的值来定制隐含规则在运行时使用的参数。例如，系统变量 <code>CFLAGS</code> 可以控制编译时使用的编译器参数。<br>如果要使用隐含规则生成我们需要的目标文件，我们需要做的就是不需要写出这个目标的完整规则链。此时，make 会试图去自动推导产生这个目标的规则和命令。例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> math<span class="hljs-selector-class">.o</span><br>	cc -o <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> math<span class="hljs-selector-class">.o</span> $(CFLAGS) $(LDFLAGS)<br></code></pre></div></td></tr></table></figure>
<p>在上面的例子中，我们并没有写如何生成 <code>main.o</code> 和 <code>math.o</code> 文件的规则，make 的「隐含规则」功能会试图为我们自动推导生成这两个文件的依赖文件和生成命令。make 会在自己的隐含规则库中寻找可以用的规则，如果找到就会使用，找不到则会报错。<br>一些常用的隐含规则如下：</p>
<ul>
<li>编译 C 程序的隐含规则：以 <code>.o</code> 结尾的目标文件的依赖文件会自动推导为对应的 <code>.c</code> 文件，并且其生成命令为：<code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li>
<li>编译 C++程序的隐含规则：以 <code>.o</code> 结尾的目标文件的依赖文件会自动推导为对应的 <code>.cc</code> 或 <code>.C</code> 文件，并且其生成命令为：<code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code></li>
</ul>
<h3 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h3><p>隐含规则的命令中大多使用了一些预置的变量，我们可以在 Makfile 中改变这些变量的值，或者在 make 的命令行中传入这些值，亦或是在我们的环境变量中设置这些值，无论采用哪种方法，只要设置了这些特定的变量，那么它们就会对隐含规则起作用。<br>我们可以把隐含规则中使用的变量分为两种：</p>
<ul>
<li>一种是命令相关的，例如 <code>CC</code> 变量</li>
<li>另一种是参数相关的，例如 <code>CFLAGS</code> 变量</li>
</ul>
<p>命令相关的常用变量如下：</p>
<ul>
<li><code>AR</code> ：函数库打包程序，默认命令为 <code>ar</code></li>
<li><code>AS</code> ：汇编语言编译程序，默认命令为 <code>as</code></li>
<li><code>CC</code> ：C 语言编译程序，默认命令为<code>cc</code></li>
<li><code>CXX</code> ：C++语言编译程序，默认命令为 <code>g++</code></li>
<li><code>CPP</code> ：C 程序的预处理器（输出为标准输出设备），默认命令为 <code>$(CC) -E</code></li>
<li><code>RM</code> ：文件删除命令，默认为 <code>rm -f</code></li>
</ul>
<p>命令参数相关的常用变量如下：</p>
<ul>
<li><p><code>ARFLAGS</code> ：函数库打包程序 <code>AR</code> 命令的参数</p>
</li>
<li><p><code>ASFLAGS</code> ：汇编语言编译器参数</p>
</li>
<li><p><code>CFLAGS</code> ：C 语言编译器参数</p>
</li>
<li><p><code>CXXFLAGS</code> ：C++语言编译器参数</p>
</li>
<li><p><code>CPPFLAGS</code> ：C 预处理器参数</p>
</li>
<li><p><code>LDFLAGS</code> ：连接器参数</p>
</li>
</ul>
<h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h3><p>我们可以使用模式规则来定义一个隐含规则。一个模式规则就像一个普通的规则，区别在于模式规则中目标文件的定义中需要使用 <code>%</code> 字符。目标文件名中使用的 <code>%</code> 字符表示对文件名的匹配，<code>%</code> 标识匹配任意长度的非空字符串。例如 <code>%.cc</code> 表示以 <code>.cc</code> 结尾的文件名。<br>如果 <code>%</code> 出现在目标文件中，则依赖文件中的 <code>%</code> 所匹配的值决定了目标文件中 <code>%</code> 所代表的值。例如有如下模式规则：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">%<span class="hljs-string">.o</span> : %<span class="hljs-string">.cc</span><br>	&lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></div></td></tr></table></figure>
<p>该模式规则定义了如何从所有的 <code>.cc</code> 文件生成对应名称的 <code>.o</code> 文件的规则，例如 <code>main.cc</code> 会生成 <code>main.o</code> 文件。</p>
<h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>所谓的自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完。<strong>这种自动化变量只应该出现在规则的命令中</strong>。<br>下面为常用的自动化变量及其说明：</p>
<ul>
<li><code>$@</code> ：表示规则中的目标文件。</li>
<li><code>$%</code> ：当目标是函数库文件时，表示库文件中的一个成员名。例如，当目标为 <code>foo.a(bar.o)</code> 时，<code>$%</code> 表示 <code>bar.o</code> 而 <code>$@</code> 表示 <code>foo.a</code>。</li>
<li><code>$&lt;</code> ：表示依赖文件中的第一个文件名字。</li>
<li><code>$?</code> ：所有比目标文件新的依赖文件的集合，以空格分隔。</li>
<li><code>$^</code> ：所有依赖文件的集合，以空格分隔，该变量会去除重复的文件。</li>
<li><code>$+</code> ：类似 <code>$^</code>，也是依赖文件的集合，不过该变量不会去重。</li>
<li><code>$*</code> ：表示目标模式中，<code>%</code> 及其之前的部分</li>
</ul>
<h3 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h3><p>我们可以重载内建的隐含规则或事定义一个全新的隐含规则。例如，我们可以重新构造和内建隐含规则不同的命令：</p>
<figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">%.o : %.c<br>	$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(<span class="hljs-keyword">date</span>)<br></code></pre></div></td></tr></table></figure>
<p>或者也可以取消内建的隐含规则，只要不再后面写命令就行：</p>
<figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-meta">%</span>.o : <span class="hljs-meta">%</span>.s<br></code></pre></div></td></tr></table></figure>
<h2 id="Makefile-更新函数库文件"><a href="#Makefile-更新函数库文件" class="headerlink" title="Makefile 更新函数库文件"></a>Makefile 更新函数库文件</h2><p>函数库文件也就是对 Object 文件（程序编译的中间文件）的打包文件。在 UNIX 下，一般是通过 <code>ar</code> 命令来完成打包工作。</p>
<h3 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h3><p>一个函数库文件通常由多个中间文件组成，我们可以使用如下个是来指定函数库文件及其组成：</p>
<figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">archive</span>(<span class="hljs-params">members ... </span>)</span><br></code></pre></div></td></tr></table></figure>
<p>这不是一个命令，而是一个目标和依赖的定义。一般来说，这种用法就是为了 <code>ar</code> 命令来服务的。例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">foolib</span><span class="hljs-params">(hack.o)</span></span> : hack<span class="hljs-selector-class">.o</span><br>	ar cr foolib hack.o<br></code></pre></div></td></tr></table></figure>
<p>如果要指定多个 member 则使用空格分隔。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在进行函数库打包文件时，需要小心使用 make 的并行机制（也即使用 <code>-j</code> 参数）。如果多个 <code>ar</code> 命令在同一时间运行在同一个函数库打包文件上，就很有可能损坏这个函数库文件。</p>
<h2 id="make-的工作方式"><a href="#make-的工作方式" class="headerlink" title="make 的工作方式"></a>make 的工作方式</h2><p>GNU 的 make 工作时的执行步骤如下：</p>
<ol>
<li>读入所有的 Makefile 文件</li>
<li>读入被 include 的其他 Makefile 文件</li>
<li>初始化文件中的变量</li>
<li>推导隐晦规则，并分析所有规则</li>
<li>为所有的目标文件创建依赖关系链</li>
<li>根据依赖关系，决定哪些目标需要重新生成</li>
<li>执行生成命令</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Makefile/">Makefile</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/18/%E5%85%B3%E4%BA%8E%E8%B7%91%E6%AD%A5/2022-11-13%E5%8F%97%E4%BC%A4%E8%AE%B0%E5%BD%95/">
                        <span class="hidden-mobile">2022年11月份训练受伤记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"6ea770bf22abf781c224","clientSecret":"af10c8b29047aede4963f4d93f77f6abc18ade91","repo":"blog_gitalk","owner":"ap0l1o","admin":["ap0l1o"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '20bc810dfe8af0386bda5a555ad7a23a'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
