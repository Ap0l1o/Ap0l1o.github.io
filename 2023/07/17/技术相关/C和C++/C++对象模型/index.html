<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="第2章 构造函数语意学 2.1 默认构造函数的构造操作 2.2 拷贝构造函数的构造操作 2.3 程序转换语意学 2.4 成员初始化列表   第3章 Data语意学 3.1 Data Member的绑定 3.2 Data Member的布局 3.3 Data Member的存取 3.4 继承与Data Member 3.5 指向Data Members的指针   第4章 Function语意学">
<meta property="og:type" content="article">
<meta property="og:title" content="ap0l1o">
<meta property="og:url" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="ap0l1o">
<meta property="og:description" content="第2章 构造函数语意学 2.1 默认构造函数的构造操作 2.2 拷贝构造函数的构造操作 2.3 程序转换语意学 2.4 成员初始化列表   第3章 Data语意学 3.1 Data Member的绑定 3.2 Data Member的布局 3.3 Data Member的存取 3.4 继承与Data Member 3.5 指向Data Members的指针   第4章 Function语意学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-2-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-2-2.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-2.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-3.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-4.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-5.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-6.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-11.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-12.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-7.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-8.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-9.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-3-10.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-4-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-4-2.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-4-3.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-5-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-5-2.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-6-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-0.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-2.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-1.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-3.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-4.png">
<meta property="og:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-f-5.png">
<meta property="article:published_time" content="2023-07-17T12:04:46.522Z">
<meta property="article:modified_time" content="2023-07-17T12:04:46.524Z">
<meta property="article:author" content="ap0l1o">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/cppmode-2-1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>ap0l1o</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="ap0l1o" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/EffectiveC++/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/07/07/%E5%85%B3%E4%BA%8E%E8%B7%91%E6%AD%A5/%E5%A4%8F%E8%AE%AD%E8%AF%BE%E8%A1%A8/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&text="><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&is_video=false&description="><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&name=&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&t="><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">第2章 构造函数语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 默认构造函数的构造操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 拷贝构造函数的构造操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 程序转换语意学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 成员初始化列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Data%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">2.</span> <span class="toc-text">第3章 Data语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Data-Member%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 Data Member的绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Data-Member%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 Data Member的布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Data-Member%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 Data Member的存取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BB%A7%E6%89%BF%E4%B8%8EData-Member"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 继承与Data Member</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">1）不使用继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8D%E5%90%AB%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">2）不含多态的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%90%AB%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">3）含多态的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.4.</span> <span class="toc-text">4）多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.5.</span> <span class="toc-text">5）虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%8C%87%E5%90%91Data-Members%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.</span> <span class="toc-text">3.5 指向Data Members的指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">3.</span> <span class="toc-text">第4章 Function语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Member%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 Member的各种调用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Nonstatic-Member-Functions-%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">1）Nonstatic Member Functions(非静态成员函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">名称的特殊处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">成员函数重载的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Static-Member-Functions-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">2）Static Member Functions(静态成员函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Virtual-Member-Functions-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">3）Virtual Member Functions(虚函数)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Virtual-Member-Functions%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 Virtual Member Functions虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">1）单继承中的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">2）多继承中的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">3）虚继承下的虚函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%8C%87%E5%90%91Member-Function%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 指向Member Function的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%94%AF%E6%8C%81%E6%8C%87%E5%90%91Virtual-Member-Functions%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">1）支持指向Virtual Member Functions的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%EF%BC%8C%E6%8C%87%E5%90%91Member-Functions%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">2）多重继承下，指向Member Functions的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Inline-Functions"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 Inline Functions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.</span> <span class="toc-text">第5章 构造、析构、拷贝语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%97%A0%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">4.1.</span> <span class="toc-text">5.1 无继承情况下的对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89C-struct%E7%9A%84Point%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">1）C struct的Point声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">2）抽象数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8C%85%E5%90%AB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84Point%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">3）包含虚函数的Point声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">4.2.</span> <span class="toc-text">5.2 继承体系下的对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vptr%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">vptr的设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.3.</span> <span class="toc-text">5.3 对象拷贝语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">虚继承中的拷贝赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.4.</span> <span class="toc-text">5.4 析构语意学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">5.</span> <span class="toc-text">第6章 执行期语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">6.1 静态对象的构造和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">1）全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">2）局部静态对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">3）对象数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">6.2 new和delete运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89new"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">1）new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89delete"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">2）delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89operator-new%E5%92%8Coperator-delete%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">3）operator new和operator delete的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%92%88%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84new%E8%AF%AD%E6%84%8F"><span class="toc-number">5.2.0.4.</span> <span class="toc-text">4）针对数组的new语意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">6.3 临时性对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%EF%BC%9A%E4%BD%BF%E7%94%A8gdb%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">附：使用gdb分析对象模型</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ap0l1o</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-07-17T12:04:46.522Z" class="dt-published" itemprop="datePublished">2023-07-17</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <!-- GFM-TOC -->
<ul>
<li><a href="#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6">第2章 构造函数语意学</a><ul>
<li><a href="#21-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C">2.1 默认构造函数的构造操作</a></li>
<li><a href="#22-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C">2.2 拷贝构造函数的构造操作</a></li>
<li><a href="#23-%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E8%AF%AD%E6%84%8F%E5%AD%A6">2.3 程序转换语意学</a></li>
<li><a href="#24-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">2.4 成员初始化列表</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC3%E7%AB%A0-data%E8%AF%AD%E6%84%8F%E5%AD%A6">第3章 Data语意学</a><ul>
<li><a href="#31-data-member%E7%9A%84%E7%BB%91%E5%AE%9A">3.1 Data Member的绑定</a></li>
<li><a href="#32-data-member%E7%9A%84%E5%B8%83%E5%B1%80">3.2 Data Member的布局</a></li>
<li><a href="#33-data-member%E7%9A%84%E5%AD%98%E5%8F%96">3.3 Data Member的存取</a></li>
<li><a href="#34-%E7%BB%A7%E6%89%BF%E4%B8%8Edata-member">3.4 继承与Data Member</a></li>
<li><a href="#35-%E6%8C%87%E5%90%91data-members%E7%9A%84%E6%8C%87%E9%92%88">3.5 指向Data Members的指针</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC4%E7%AB%A0-function%E8%AF%AD%E6%84%8F%E5%AD%A6">第4章 Function语意学</a><ul>
<li><a href="#41-member%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">4.1 Member的各种调用方式</a></li>
<li><a href="#42-virtual-member-functions%E8%99%9A%E5%87%BD%E6%95%B0">4.2 Virtual Member Functions虚函数</a></li>
<li><a href="#43-%E6%8C%87%E5%90%91member-function%E7%9A%84%E6%8C%87%E9%92%88">4.3 指向Member Function的指针</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC5%E7%AB%A0-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6">第5章 构造、析构、拷贝语意学</a><ul>
<li><a href="#51-%E6%97%A0%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.1 无继承情况下的对象构造</a></li>
<li><a href="#52-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.2 继承体系下的对象构造</a></li>
<li><a href="#53-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6">5.3 对象拷贝语意学</a></li>
<li><a href="#54-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6">5.4 析构语意学</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC6%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6">第6章 执行期语意学</a> <ul>
<li><a href="#61-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84">6.1 静态对象的构造和析构</a> </li>
<li><a href="#62-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6">6.2 new和delete运算符</a></li>
<li><a href="#63-%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1">6.3 临时性对象</a></li>
</ul>
</li>
<li><a href="#%E9%99%84%E4%BD%BF%E7%94%A8gdb%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">附：使用gdb分析对象模型</a><!-- GFM-TOC --></li>
</ul>
<br>
<br>
<br>
<br>
<br>
<br>

<h1 id="第2章-构造函数语意学"><a href="#第2章-构造函数语意学" class="headerlink" title="第2章 构造函数语意学"></a>第2章 构造函数语意学</h1><h2 id="2-1-默认构造函数的构造操作"><a href="#2-1-默认构造函数的构造操作" class="headerlink" title="2.1 默认构造函数的构造操作"></a>2.1 默认构造函数的构造操作</h2><p>考虑如下代码；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Foo *pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//程序要求bar&#x27;s members都被清为0</span></span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span>(bar.val || bar.pnext)</span><br><span class="line">        <span class="comment">// ... do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是否会合成默认的拷贝构造函数？首先需要提到2个需要：</p>
<ul>
<li><strong>编译器的需要</strong></li>
<li><strong>程序的需要</strong>：上述代码就是“程序的需要”，在这种情况下，为成员执行初始化应该是程序员的责任</li>
</ul>
<p>那么在来考虑是否会合成拷贝构造函数：</p>
<ul>
<li>在<strong>C++ Annotated Reference Manual</strong>(<strong>ARM</strong>)中：只有编译器需要时才会合成，所以上面的代码不会合成默认的拷贝构造函数</li>
<li><strong>C++ Standard</strong>：如果没有任何用户声明的构造函数，那么会有一个默认构造函数被隐式声明，但是这样被隐式声明的默认构造函数的trival（浅薄无能，没啥用）constructor。只有当一个默认构造函数是nontrivial时，才会被合成出来。所以，如果按照C++标准，上面的代码会声明一个trivial的默认构造函数，但是因为是tivial，所以并不会合成</li>
</ul>
<p>有4种情况，会造成“编译器必须为未声明构造函数的类合成一个默认构造函数”，即nontrivial的默认构造函数：</p>
<ol>
<li><strong>类包含带有默认构造函数的成员</strong></li>
<li><strong>类继承自带有默认构造函数的基类</strong></li>
<li><strong>类带有一个虚函数</strong><ul>
<li>类声明或继承了一个虚函数</li>
<li>类派生自一个继承串链，其中有一个或更多的虚基类</li>
</ul>
</li>
<li><strong>类带有一个虚基类</strong></li>
</ol>
<p><strong>被合成出来的构造器只能满足编译器（而非程序）的需要</strong>，它之所以能够完成任务，是借着“调用成员对象或基类的默认构造函数”或是“为每一个对象初始化其虚函数机制或虚基类机制”而完成的</p>
<p><strong>在合成的默认构造函数中，只有基类子对象和类成员对象会被初始化。所有其它的nonstatic数据成员（如整数、整数指针、整数数组等等）都不会被初始化。这些初始化操作对程序而言或许有需要，但对编译器则非必要</strong>。如果程序需要把一个“把某指针设为0”的默认构造函数，那么提供它的人应该是程序员</p>
<blockquote>
<p>总的来说就是，按照C++ Standrand，如果用户没有声明，那么会隐式的声明一个，但是会不会合成取决于声明出的是trivial还是nontrivial</p>
</blockquote>
<h2 id="2-2-拷贝构造函数的构造操作"><a href="#2-2-拷贝构造函数的构造操作" class="headerlink" title="2.2 拷贝构造函数的构造操作"></a>2.2 拷贝构造函数的构造操作</h2><ul>
<li>**默认逐成员初始化(Default Memberwise Initialization)**：</li>
<li>**逐成员初始化(Memberwise Initialization)**：</li>
<li><strong>位逐次拷贝(Bitwise Copy Semantics)</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下声明展现了bitwide copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">    ~<span class="built_in">Word</span>() &#123; <span class="keyword">delete</span> [] str;&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果类X没有显式的拷贝构造函数，那么在用一个类X的对象a初始化这个类的对象b时，内部采用的初始化就是<strong>默认逐成员初始化</strong>。具体来说，就是把a的数据成员一个个单独拷贝到b中。如果类X里面还包含有成员类对象(Member Class Object)，如类Y的对象，那么此时就不会把a的成员类对象拷贝到b中，而是递归的进行<strong>逐成员初始化</strong>，<strong>逐成员初始化</strong>用的就是<strong>位逐次拷贝</strong>和<strong>拷贝构造函数</strong>(Copy Constructor)</p>
<p><strong>就像默认拷贝构造函数一样，C++ Standard上说，如果class没有声明一个拷贝构造函数，就会有隐式的声明出现。C++ Standard把拷贝构造函数分为trivial和nontrivial两种。只有nontrivial的实例才会被合成于程序之中。如果展现出”bitwise copy semantics“（位逐次拷贝语意），那么拷贝构造函数就是trivial的</strong></p>
<p><strong>如果一个类没有定义显示的拷贝构造函数，那么编译器是否会为其合成取决于类是否展现“位逐次拷贝”</strong>：</p>
<ul>
<li><strong>如果类展现“位逐次拷贝”，则编译器不需要合成一个默认的拷贝构造函数</strong></li>
<li><strong>如果类不展现“位逐次拷贝”，则编译器必须合成出一个默认的拷贝构造函数。包括下列4种情况</strong>：<ol>
<li><strong>当类包含具有拷贝构造函数的成员时</strong></li>
<li><strong>当类继承自一个具有拷贝构造函数的基类时</strong></li>
<li><strong>当类声明了一个或多个虚函数时</strong></li>
<li><strong>当类派生自一个继承串链，其中有一个或多个虚基类时</strong></li>
</ol>
</li>
</ul>
<p>前2种情况中，编译器必须将成员或基类的“拷贝构造函数调用操作”安插到被合成的拷贝构造函数中</p>
<p>第3种情况不展现“位逐次拷贝”是因为需要正确的处理虚函数指针vptr。1）如果使用子类的一个对象初始化另一个子类的对象，可以直接靠“位逐次拷贝”完成；2）但假设用一个子类对象来初始化一个父类对象（会发生切割行为），父类对象的虚函数指针必须指向父类的虚函数表vtlb，如果使用“位逐次拷贝”，那么父类的虚函数指针会执行子类的vtlb</p>
<div align="center"> <img src="../pic/cppmode-2-1.png"/> </div>

<p>第4种情况不展现“位逐次拷贝”是因为虚基类子对象部分能够正确的初始化。1）如果使用虚基类子类的一个对象，初始化虚基类子类的另一个对象，那么“位逐次拷贝”绰绰有余；2）但是如企图以一个虚基类子类的子类的对象，初始化一个虚基类子类的对象，编译器就必须判断“后续当程序员企图存取其虚基类子对象时能否正确执行”，因此必须合成一个拷贝构造函数，安插一些代码以设定虚基类指针和偏移量的初值（或只是简单地确定它没有被抹消）</p>
<div align="center"> <img src="../pic/cppmode-2-2.png"/> </div>

<p>在下面的情况下，编译器无法知道“位逐次拷贝”是否还保持着，因为它无法知道Raccoon指针是否指向一个真正的Raccoon对象或是指向一个Raccoon的子类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Raccoon *ptr;</span><br><span class="line">Raccoon little_critter = *ptr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总的来说就是，按照C++ Standrand，如果用户没有声明，那么会隐式的声明一个，但是会不会合成取决于声明出的是trivial还是nontrivial</p>
</blockquote>
<h2 id="2-3-程序转换语意学"><a href="#2-3-程序转换语意学" class="headerlink" title="2.3 程序转换语意学"></a>2.3 程序转换语意学</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;t) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输出：默认构造函数</span></span><br><span class="line">    Test t = <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的应用，迫使编译器多多少少对程序代码做部分转化。尤其是当一个函数以传值的方式传回一个类对象，而该类有一个拷贝构造函数(无论是显式定义出来的还是合成的)时，这将导致深奥的程序转化——无论在函数的定义上还是在使用上。此外，编译器将拷贝构造的调用操作优化，以一个额外的第一参数(数值被直接存放于其中)取代NRV(named return value)。如果了解那些转换，已经拷贝构造函数优化后的可能状态，就比较能够控制程序的执行效率</p>
<h2 id="2-4-成员初始化列表"><a href="#2-4-成员初始化列表" class="headerlink" title="2.4 成员初始化列表"></a>2.4 成员初始化列表</h2><p>下列情况下，必须使用成员初始化列表：</p>
<ol>
<li><strong>当初始化一个引用成员时</strong></li>
<li><strong>当初始化一个常量成员时</strong></li>
<li><strong>当调用一个基类的构造函数，而它拥有一组参数时</strong></li>
<li><strong>当调用一个类类型成员的构造函数，而它拥有一组参数时</strong></li>
</ol>
<p><strong>编译器会对初始化列表一一处理并可能重新排序，以反映出成员的声明顺序。它会安插一些代码到构造函数体内，并置于任何显示用户代码(explicit user code)之前</strong></p>
<br>

<blockquote>
<p>和默认构造函数、拷贝构造函数相关的问题：是否可以使用memset来初始化一个对象、使用memcpy来拷贝一个对象？只有在”class不含任何由编译器产生的内部members“时才能有效运行。如果class声明一个或一个以上的virtual functions，或内含一个virtual base class，那么使用上述函数将会导致那些”被编译器产生的内部members“的初值被改写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//会改变内部的vptr</span></span><br><span class="line">  <span class="built_in">Shape</span>() &#123;<span class="built_in">memset</span>(<span class="keyword">this</span>,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Shape));&#125;</span><br><span class="line">  <span class="comment">//当传入一个子类对象的地址时，vptr会指向子类的虚函数表</span></span><br><span class="line">  <span class="built_in">Shape</span>(<span class="keyword">const</span> Shape &amp;rhs) &#123;<span class="built_in">memcpy</span>(<span class="keyword">this</span>,&amp;rhs,<span class="built_in"><span class="keyword">sizeof</span></span>(Shape));&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<br>

<h1 id="第3章-Data语意学"><a href="#第3章-Data语意学" class="headerlink" title="第3章 Data语意学"></a>第3章 Data语意学</h1><p>类X、Y、Z、A具有如下关系：</p>
<div align="center"> <img src="../pic/cppmode-3-1.png"/> </div>

<p>使用sizeof打印大小有如下结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;X:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(X);                <span class="comment">//X:1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  Y:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Y);              <span class="comment">//Y:8，和机器，编译器有关</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  Z:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Z);              <span class="comment">//Z:8，和机器，编译器有关</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  A:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;      <span class="comment">//A:16，和机器，编译器相关</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>对于X</strong>：编译器安插进一个char，使得类X的对象得以在内存中配置独一无二的地址</li>
<li><strong>对于Y和Z</strong>：Y和Z的大小受3个因素的影响<ul>
<li><strong>虚继承所造成的额外负担</strong>：这种额外负担反映在某种形式的<strong>指针</strong>身上，它或者指向“虚基类子对象”，或者指向一个相关表格（表格中存放的不是“虚基类子对象”的地址，就是其偏移位置）</li>
<li><strong>编译器对于特殊情况所提供的优化处理</strong>：<ul>
<li>传统上，虚基类X的1 byte大小也出现在Y和Z中，被放在子类的固定(不变动)部分的尾端（<strong>下图左</strong>）</li>
<li>“某些”编译器会对“空虚基类”提供特殊支持，“空虚基类”被视为子类对象最开头的一部分，即不花费任何空间。因此节省了传统情况下的1 byte，因为既然有了成员，就不需要原本为了“空类”而安插的一个char（<strong>下图右</strong>）</li>
</ul>
</li>
<li><strong>对齐的限制</strong>：类Y和Z的大小截至目前为止是5 bytes，在大部分机器上，聚合的结构体大小会受到对齐的限制，为了能够更有效地在内存中存放，会进行字节填充</li>
</ul>
</li>
<li><strong>对于A</strong>：类A的大小由下列因素决定<ul>
<li><strong>被共享的唯一一个类X实例</strong>，大小为1 byte（对于那些对“空虚基类”提供支持的编译器，这1 byte被拿掉）</li>
<li><strong>类Y的大小减去“因虚基类而配置的大小”</strong></li>
<li><strong>类Z的大小减去“因虚基类而配置的大小”</strong></li>
<li><strong>类A自己的大小</strong>（这里是0 byte）</li>
<li><strong>对齐的要求</strong></li>
</ul>
</li>
</ul>
<div align="center"> <img src="../pic/cppmode-3-2.png"/> </div>

<br>

<blockquote>
<p>C++标准并不强制规定如“基类子对象的排列顺序”或“不同存取层级的数据成员的排列顺序”这种琐碎细节。它也不规定“虚函数”或“虚基类”的实现细节。C++标准只说：这些细节由各家厂商自定</p>
</blockquote>
<p><strong>C++对象模型尽量以空间优化和存取速度优化的考虑来表现nonstatic data members，并且保持和C语言struct数据配置的兼容性。它把数据直接存放在每一个class object之中。对于继承而来的nonstatic data members（不管是虚继承还是一般继承）也是如此。不过并没有强制定义期间的排列顺序。至于static data memebers，则被放置在程序的一个全局数据段中，不会影响个别的class object的大小</strong></p>
<h2 id="3-1-Data-Member的绑定"><a href="#3-1-Data-Member的绑定" class="headerlink" title="3.1 Data Member的绑定"></a>3.1 Data Member的绑定</h2><ul>
<li><strong>成员函数体内的名字解析直到类的声明都出现了才开始</strong></li>
<li><strong>成员函数的参数列表不符合上一条规则，名字解析从参数第一次出现开始</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment"> * 成员函数体内的名字解析，x为Point3D的成员</span></span><br><span class="line"><span class="comment"> *******************************************************/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//对于函数本体的解析将延迟，直至class声明的右大括号出现才开始</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">float</span> x;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment"> * 成员函数参数列表的名字解析</span></span><br><span class="line"><span class="comment"> *******************************************************/</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="comment">//length被解析为int，_val被解析为类的成员变量</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span> </span>&#123;_val = val;&#125;</span><br><span class="line"> 	<span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="comment">//这里的length应该在类对它的第一个参考操作之前被看到，这样的声明将使先前的参考操作不合法</span></span><br><span class="line"> 	<span class="comment">//请总是把“内嵌的类型声明”放在class的起始处</span></span><br><span class="line"> 	<span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line"> 	length _val;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Data-Member的布局"><a href="#3-2-Data-Member的布局" class="headerlink" title="3.2 Data Member的布局"></a>3.2 Data Member的布局</h2><blockquote>
<p>access section：private、public、protected等区段</p>
</blockquote>
<ul>
<li><strong>同一access section中的Nonstatic data members在class object中的排列顺序将和其被声明的顺序一样</strong><ul>
<li><strong>C++标准要求，同一access section中，members的排列只需符合“较晚出现的members在class object中有较高的地址”即可，各个members并不一定得连续排列</strong>：<ul>
<li><strong>对齐可能会填充一些字节</strong></li>
<li><strong>编译器可能会合成一些内部使用的data members</strong>，如vptr（vptr传统上被放在所有显式声明的members的最后，如今有一些编译器把vptr放在一个class object的最前端。C++标准允许这些内部产生出来的members自由地放在任何位置上，甚至放在那些被程序员声明出来的members之间）</li>
</ul>
</li>
</ul>
</li>
<li><strong>C++标准允许多个access sections之中的data memebers自由排列，不必在乎它们出现在class声明中的顺序</strong></li>
</ul>
<h2 id="3-3-Data-Member的存取"><a href="#3-3-Data-Member的存取" class="headerlink" title="3.3 Data Member的存取"></a>3.3 Data Member的存取</h2><p>考虑下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point3d origin,*pt = &amp;origin;</span><br><span class="line"></span><br><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>通过origin存取和通过pt存取有什么差异？对x是静态数据成员与不是静态成员时进行分析</p>
<ul>
<li><strong>Static Data Members</strong>：这是C++中“通过一个指针和通过一个对象来存取member，结论完全相同”的唯一一种情况。这是因为“经由’.’对一个static data member进行存取操作”只是文法上的一种便宜行事。member其实并不在class object之中，因此存取static member并不需要通过class object（如果有两个类，每一个都声明了一个同名的static member，那么当它们都被放在程序的data segment时，就会导致命名冲突。编译器的解决方法是暗中对每一个static member编码，以获得一个独一无二的程序识别代码）</li>
<li><strong>Nonstatic Data Members</strong>：欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始位置加上data member的偏移位置。每一个nonstatic data member的偏移位置在编译时期即可获知，甚至如果member属于一个“基类子对象”也是一样，因此，存取一个nonstatic data member的效率和存取一个C struct member或一个非派生类的member是一样的。<strong>但是，虚继承将为“经由基类子对象存取class members”导入一层新的间接性，如果通过指针存取，这个存取操作必须延迟至执行期，经由一个额外的间接引导才能解决</strong>（原因在于，在继承体系中，”虚基类子对象“在不同派生类中的偏移量不同，指针所指的对象类型需要在运行时确定，因此只能在运行时得到”虚基类子对象“确切的偏移量）</li>
</ul>
<p>假设，x是一个Nonstatic Data Members，那么地址 <code>&amp;origin.x</code> 将等于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于指向Data Members的指针以及为什么要减1，见3.5</span></span><br><span class="line">&amp;origin + (&amp;Point3d::x - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-4-继承与Data-Member"><a href="#3-4-继承与Data-Member" class="headerlink" title="3.4 继承与Data Member"></a>3.4 继承与Data Member</h2><p>继承体系中类成员的布局分为以下几种情况来讨论：</p>
<ul>
<li>1）不使用继承</li>
<li>2）不含多态的继承</li>
<li>3）含多态的继承</li>
<li>4）多重继承</li>
<li>5）虚继承</li>
</ul>
<h4 id="1）不使用继承"><a href="#1）不使用继承" class="headerlink" title="1）不使用继承"></a>1）不使用继承</h4><div align="center"> <img src="../pic/cppmode-3-3.png"/> </div>

<h4 id="2）不含多态的继承"><a href="#2）不含多态的继承" class="headerlink" title="2）不含多态的继承"></a>2）不含多态的继承</h4><p>C++标准并未强制指定派生类和基类成员的排列顺序；理论上编译器可以自由安排。在大部分编译器上，基类成员总是先出现（属于虚基类的除外）</p>
<div align="center"> <img src="../pic/cppmode-3-4.png"/> </div>

<p>将两个原本独立不相干的类凑成一对“类型/子类型”，并带有继承关系，需要注意两点</p>
<ol>
<li>可能会重复设计一些相同操作的函数</li>
<li>把一个类分成两层或更多层，出现在派生类中的基类子对象具有完整原样性，因此可能会导致对象空间膨胀</li>
</ol>
<p>对于第2点，考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment"> * 不使用继承</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">char</span> c1;</span><br><span class="line">	<span class="keyword">char</span> c2;</span><br><span class="line">	<span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment"> * 使用继承，设计成多层</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">char</span> bit1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span> :</span> <span class="keyword">public</span> Concrete1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> bit2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete3</span> :</span> <span class="keyword">public</span> Concrete2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> bit3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="../pic/cppmode-3-5.png"/> </div>

<p>在使用继承时，派生类中的基类子对象具有完整原样性，派生类部分的成员不直接使用基类子对象的填充部分是因为：如果将一个父类对象拷贝给一个派生类对象，派生类对象的派生类成员会被覆盖：</p>
<div align="center"> <img src="../pic/cppmode-3-6.png"/> </div>

<h4 id="3）含多态的继承"><a href="#3）含多态的继承" class="headerlink" title="3）含多态的继承"></a>3）含多态的继承</h4><p>相比于不含多态的继承，这种情况下，每一个class object内含一个额外的vptr member；多了一个virtual table；此外每一个virtual member function的调用也比以前复杂了</p>
<p>某些编译器会把vptr放置在class object的尾端，另一些编译器会把vptr放置在class object的首端</p>
<ul>
<li><p>把vptr放在class object的尾端，可以保留base class C struct的对象布局，因而允许在C程序代码中也能使用。这种做法在C++最初问世时，被许多人采用</p>
<div align="center"> <img src="../pic/cppmode-3-11.png"/> </div></li>
<li><p>把vptr放在class object的首端，对于“在多重继承之下，通过指向class members的指针调用virtual function”，会带来一些帮助。否则，不仅“从class object起始点开始量起”的offset必须在执行期备妥，甚至与class vptr之间的offset也必须备妥。当然，vptr放在前端，代价就是丧失了C语言兼容性（但是似乎并没有多少程序会从一个C struct派生出一个具有多态性质的class）</p>
<div align="center"> <img src="../pic/cppmode-3-12.png"/> </div></li>
</ul>
<p>假设把vptr放在<strong>base class</strong>的尾端，则Point2d和Point3d的成员布局如下：</p>
<div align="center"> <img src="../pic/cppmode-3-7.png"/> </div>

<h4 id="4）多重继承"><a href="#4）多重继承" class="headerlink" title="4）多重继承"></a>4）多重继承</h4><ul>
<li>将vptr放在class object的尾端，提供了一种“自然多态”形式，基类和派生类的object都是从相同的地址开始，因此把一个派生类对象的地址指定给基类的指针或引用时，不需要编译器去调停或修改地址。它很自然地可以发生，提供了最佳执行效率</li>
<li>将vptr放在class object的首端，如果基类没有virtual function而派生类有，那么单一继承的“自然多态”就会被打破。这种情况下把一个派生类object转换为其基类型，就需要编译器的介入，用以调整地址</li>
</ul>
<p><strong>多重继承的问题主要发生于派生类和其第二或后继基类object之间的转换</strong></p>
<p><strong>对一个多重派生对象，将其地址指定给“最左端基类的指针”，情况将和单一继承时相同，因为二者都指向相同的起始地址。需付出的成本只有地址的指定操作而已；至于第二个或后继的基类的地址指定操作，则需要将地址修改过：加上(或减去，如果downcast的话)介于中间的基类子对象大小</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...（拥有virtual接口，所以Point2d对象之中会有vptr）</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...（拥有virtual接口，所以Point2d对象之中会有vptr）</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d , <span class="keyword">public</span> Vertex&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>假设将vptr放在class object的尾端，类的继承关系和members的布局如下：</p>
<div align="center"> <img src="../pic/cppmode-3-8.png"/> </div>

<p>C++标准并未要求Vertex3d中的基类Point3d和Vertex有特定的排列顺序。原始的cfront编译器是根据声明顺序来排列的。因此cfront编译器创作出来的Vertex3d对象，将被视为一个Point3d子对象（其中又有一个Point2d子对象）加上一个Vertex子对象，最后再加上Vertex3d自己的部分。目前各编译器仍然以此方式完成多重基类的布局（但如果加上虚拟继承，就不一样了）</p>
<p>在这个例子中：</p>
<ul>
<li><strong>如果将一个Vertex3d类的对象的地址指定给Vertex类的指针，那么需要编译器介入，执行相应的地址转换</strong></li>
<li><strong>如果指定给Point2d或Point3d类的指针，则不要编译器介入</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vertex3d v3d;</span><br><span class="line">Vertex *pv;</span><br><span class="line">Point2d *p2d;</span><br><span class="line">Point3d *p2d;</span><br></pre></td></tr></table></figure>

<p>那么 <code>pv = &amp;v3d;</code> 需要类似这样的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pv = (Vertex*)(((<span class="keyword">char</span>*)&amp;v3d) + <span class="built_in"><span class="keyword">sizeof</span></span>(Point3d));</span><br></pre></td></tr></table></figure>

<p>而 <code>p2d = &amp;v3d;</code> 或 <code>p3d = &amp;v3d;</code> 只需要简单地拷贝其地址就好</p>
<p>作为补充，必须提及下面一种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vertex3d *pv3d;</span><br><span class="line"><span class="comment">//一系列操作，使得pv3d可能指向NULL或者一个Vertex3d对象</span></span><br><span class="line">Vertex *pv;</span><br></pre></td></tr></table></figure>

<p>此时 <code>pv = pv3d;</code> 不能只是简单的被转换，因为如果pv3d为0，pv将获得sizeof(Point3d)的值。这明显是错误的，因此需要增加一个条件测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pv = pv3d ? (Vertex*)(((<span class="keyword">char</span>*)pv3d) + <span class="built_in"><span class="keyword">sizeof</span></span>(Point3d)) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5）虚继承"><a href="#5）虚继承" class="headerlink" title="5）虚继承"></a>5）虚继承</h4><p>要在编译器中实现多继承，实在是难度颇高。以iostream继承体系为例，实现技术的挑战在于，要找到一个足够有效的方法，将istream和ostream各自维护的一个ios子对象，折叠成为一个由iostream维护的单一ios子对象，并且还可以保持基类和派生类的指针之间的多态指定操作</p>
<p><strong>一般的实现方法是，如果一个类内含有一个或多个虚基类子对象，将被分割为2部分：一个不变区域和一个共享区域</strong></p>
<ul>
<li><strong>不变区域</strong>：不管后接如何衍化，总是拥有固定的offset(从object的开头算起)，所以这一部分数据可以被直接存取</li>
<li><strong>共享区域</strong>：所表现的就是“虚基类子对象”，这一部分的数据的位置会因为每次的派生操作而有变化，所以它们只可以被间接存取（<strong>各家编译器实现技术之间的差异就在于间接存取的方法不同</strong>）</li>
</ul>
<p><strong>一般的布局策略是先安排好派生类的不变部分，然后再建立其共享部分</strong>（对于共享部分的存取，cfront编译器会在每一个派生类对象中安插一些指针，每个指针指向一个虚基类。要存取继承得来的虚基类成员。可以通过相关指针间接完成）</p>
<div align="center"> <img src="../pic/cppmode-3-9.png"/> </div>

<p>这样的实现模型有两个主要的缺点：</p>
<ol>
<li>每一个对象必须针对其每一个virtual base class背负一个额外的指针（然而理想上我们希望class object有固定的负担，不因为其virtual base class的个数而有所变化）<ul>
<li>1）Microsoft编译器引入所谓的vitual base class table。每一个class object如果有一个或多个virtual base classes，就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，当然是放在该表格中 </li>
<li>2）在virtual  function table中放置virtual base class的offset(而不是地址)，将virtual base class offset和virtual function entries混杂在一起（<strong>下图展示了这种模型</strong>）</li>
</ul>
</li>
<li>由于虚拟继承串链的加长，导致间接存取层次的增加（意思是，如果有3层虚拟派生，就需要经由3个virtual base class指针进行3次间接存取。然而理想上却希望固定的存取时间，不因为虚拟派生的深度而改变）<ul>
<li>MetaWare和其它编译器仍然使用cfront的原始实现模型来解决这个问题，他们经由拷贝操作取得所有的nested virtual base class指针，放到派生类object之中。从而解决了“固定存取时间”的问题，虽然付出了一些空间上的代价</li>
</ul>
</li>
</ol>
<div align="center"> <img src="../pic/cppmode-3-10.png"/> </div>

<blockquote>
<p>一般而言，virtual base class最有效的一种运用形式就是：一个抽象的virtual base class，没有任何data members</p>
</blockquote>
<h2 id="3-5-指向Data-Members的指针"><a href="#3-5-指向Data-Members的指针" class="headerlink" title="3.5 指向Data Members的指针"></a>3.5 指向Data Members的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Point3d::*的意思是：“指向Point3d data member”的指针类型</span></span><br><span class="line">    <span class="keyword">float</span> Point3d::*p1 = &amp;Point3d::x;</span><br><span class="line">    <span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::y;</span><br><span class="line">    <span class="keyword">float</span> Point3d::*p3 = &amp;Point3d::z;</span><br><span class="line">    <span class="comment">//不可以用cout</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::x = %p\n&quot;</span> , p1);   <span class="comment">//0x8，根据机器和编译器决定</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::y = %p\n&quot;</span> , p2);   <span class="comment">//0xc，根据机器和编译器决定</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::z = %p\n&quot;</span> , p3);   <span class="comment">//0x10，根据机器和编译器决定</span></span><br><span class="line">    </span><br><span class="line">    Point3d p;</span><br><span class="line">    p.x = <span class="number">1.1</span>;</span><br><span class="line">    p.y = <span class="number">2.2</span>;</span><br><span class="line">    p.z = <span class="number">3.3</span>;</span><br><span class="line">    <span class="comment">//x:1.1 y:2.2 z:3.3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; p.*p1 &lt;&lt; <span class="string">&quot; y:&quot;</span> &lt;&lt; p.*p2 &lt;&lt; <span class="string">&quot; z:&quot;</span> &lt;&lt; p.*p3 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;Point3d::z</strong>将得到z坐标在class object中的偏移位置。最低限度其值将是x和y的大小总和，因为C++要求同一access section中的members的排列顺序应该和其声明顺序相同</p>
<p>如果vptr放在对象的尾端，三个坐标值在对象的布局中的偏移量分别是0，4，8。如果vptr放在对象的头部，三个坐标值在对象的布局中的offset分别是8，12，16（64位机器）。然后<strong>结果可能会加1，即1，5，9或者9，13，17。这是为了区分一个“没有指向任何data member”的指针，和一个指向“第一个data member”的指针（对象的内存分布并没有增加1，这里只是编译器可能对指针的处理）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d::x;</span><br></pre></td></tr></table></figure>

<p>为了区分p1和p2，每一个真正的member offset的值都被加上1（如我测的结果所示，<strong>如果没有增加1，可能是编译器做了特殊处理</strong>）。因此，无论编译器或使用者都必须记住，在真正使用该值以指出一个member之前请减掉1</p>
<br>
<br>

<h1 id="第4章-Function语意学"><a href="#第4章-Function语意学" class="headerlink" title="第4章 Function语意学"></a>第4章 Function语意学</h1><p>假设有一个Point3d的指针和对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d obj;</span><br><span class="line">Point3d *ptr = &amp;obj;</span><br></pre></td></tr></table></figure>

<p>这一章主要讨论，在进行如下调用时，会发生什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">normalize</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//normalize函数的定义</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::normalize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="built_in">magnitude</span>();</span><br><span class="line">    Point3d normal;</span><br><span class="line"></span><br><span class="line">    normal._x = _x/mag;</span><br><span class="line">    normal._y = _y/mag;</span><br><span class="line">    normal._z = _z/mag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//magnitude函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x * _x + _y * _y + _z * _z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-Member的各种调用方式"><a href="#4-1-Member的各种调用方式" class="headerlink" title="4.1 Member的各种调用方式"></a>4.1 Member的各种调用方式</h2><h4 id="1）Nonstatic-Member-Functions-非静态成员函数"><a href="#1）Nonstatic-Member-Functions-非静态成员函数" class="headerlink" title="1）Nonstatic Member Functions(非静态成员函数)"></a>1）Nonstatic Member Functions(非静态成员函数)</h4><p>C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmember function有相同的效率。因此编译器内部会将”member函数实例“转换为对等的”nonmember函数实例“</p>
<p>member function按照下列步骤转化为nonmember function：</p>
<ol>
<li>改写函数原型，安插一个额外的参数到member function中，提供一个存取管道，使class object得以将此函数调用。额外参数被称为this指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">Point3d::magnitude</span><span class="params">(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果member function是const，则变成</span></span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::magnitude</span><span class="params">(<span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将每一个”对nonstatic data member的存取操作“改为经由this指针来存取：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">        <span class="keyword">this</span>-&gt;_x * <span class="keyword">this</span>-&gt;_x +</span><br><span class="line">        <span class="keyword">this</span>-&gt;_y * <span class="keyword">this</span>-&gt;_y +</span><br><span class="line">        <span class="keyword">this</span>-&gt;_z * <span class="keyword">this</span>-&gt;_z );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将member function重新写成一个外部函数。将函数名称经过”mangling“处理，使其在程序中成为独一无二的语汇：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">magnitude__7Point3dFv</span><span class="params">(<span class="keyword">register</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数转换好之后，每一个调用操作也会进行转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">magnitude</span>();</span><br><span class="line"><span class="built_in">magnitude__7Point3dFv</span>(&amp;obj);</span><br><span class="line"></span><br><span class="line">ptr-&gt;<span class="built_in">magnitude</span>();</span><br><span class="line"><span class="built_in">magnitude__7Point3dFv</span>(ptr);</span><br></pre></td></tr></table></figure>

<h4 id="名称的特殊处理"><a href="#名称的特殊处理" class="headerlink" title="名称的特殊处理"></a>名称的特殊处理</h4><p>一般而言，member的名称前会被加上class名称，形成独一无二的命名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> ival; ...&#125;;</span><br><span class="line"><span class="comment">//ival有可能变成：ival__3Bar</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span><span class="keyword">public</span> Bar &#123;<span class="keyword">public</span>: <span class="keyword">int</span> ival; ...&#125;;</span><br><span class="line"><span class="comment">//可能会变成这样：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ival__3Bar;</span><br><span class="line">    <span class="keyword">int</span> ival_3Foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数重载的处理"><a href="#成员函数重载的处理" class="headerlink" title="成员函数重载的处理"></a>成员函数重载的处理</h4><p>为了支持重载，“mangling”处理肯定不能只使用函数名和类名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Point中重载的x函数，可能会变成这样：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x__5PointFf</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x__5PointFv</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）Static-Member-Functions-静态成员函数"><a href="#2）Static-Member-Functions-静态成员函数" class="headerlink" title="2）Static Member Functions(静态成员函数)"></a>2）Static Member Functions(静态成员函数)</h4><p>static member function也会被转换成一般的nonmember function，但是不同于普通的member function，static member function没有this指针，因此差不多等同于nonmember function。每一个调用操作会进行类似如下转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj.normalize();</span></span><br><span class="line"><span class="built_in">normalize__7Point3dSFv</span>();</span><br><span class="line"><span class="comment">//ptr-&gt;normalize();</span></span><br><span class="line"><span class="built_in">normalize__7Point3dSFv</span>();</span><br></pre></td></tr></table></figure>

<p>假设Point3d类存在一个名为object_count的static member function：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Point3d::object_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会被cfront转化为：</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">object_count__5Point3dSFv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_count__5Point3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SFv表示它是一个static member function，拥有一个void参数链表</p>
<p>如果取一个static member function的地址，获得的将是其在内存中的位置，也就是其地址。由于static member function没有this指针，所以其地址的类型并不是一个“指向class member function的指针”，而是一个”nonmember函数指针”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;Point3d::<span class="built_in">object_count</span>();</span><br><span class="line"><span class="comment">//会得到一个数值，类型是：</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//而不是</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(Point3d::*)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3）Virtual-Member-Functions-虚函数"><a href="#3）Virtual-Member-Functions-虚函数" class="headerlink" title="3）Virtual Member Functions(虚函数)"></a>3）Virtual Member Functions(虚函数)</h4><p>还是考虑以下两种调用会如何转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">normalize</span>();</span><br><span class="line">obj.<span class="built_in">normalize</span>();</span><br></pre></td></tr></table></figure>

<p>通过ptr调用时，会被转化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment"> * 1是virtual table slot的索引值，关联到normalize()函数</span></span><br><span class="line"><span class="comment"> * 第二个ptr表示this指针</span></span><br><span class="line"><span class="comment"> ****************************************************/</span></span><br><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure>

<p>那么通过obj调用时，会如何转化？如果类似ptr，虽然语意正确，却没有必要。上述经由obj调用的函数实例只可能是Point3d::normalize()。<strong>“经由一个class object调用一个virtual function”，这种操作应该总是被编译器像对待一般nonstatic member function一样地解析</strong>，因此转化如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normalize__7Point3dFv</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Virtual-Member-Functions虚函数"><a href="#4-2-Virtual-Member-Functions虚函数" class="headerlink" title="4.2 Virtual Member Functions虚函数"></a>4.2 Virtual Member Functions虚函数</h2><h4 id="1）单继承中的虚函数"><a href="#1）单继承中的虚函数" class="headerlink" title="1）单继承中的虚函数"></a>1）单继承中的虚函数</h4><p>考虑下面3个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> :</span> <span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>) : <span class="built_in">Point</span>(x),_y(y) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Point2d</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写base class virtual functions</span></span><br><span class="line">    <span class="function">Point2d&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Point2d</span>(x,y),_z(z) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Point3d</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写base class virtual functions</span></span><br><span class="line">    <span class="function">Point3d&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3个类的虚函数表如下：</p>
<div align="center"> <img src="../pic/cppmode-4-1.png"/> </div>

<p>对于如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>

<p>如何有足够的信息在编译时期设定virtual function的调用呢？</p>
<ul>
<li>一般而言，每次调用z()时，并不知道ptr所指的真正类型。然而却知道经由ptr可以存取到该对象的virtual table</li>
<li>虽然不知道哪一个z()函数实例会被调用，但却知道每一个z()函数地址都放在slot4中</li>
</ul>
<p>这些信息使得编译器可以将该调用转化成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>])(ptr);</span><br></pre></td></tr></table></figure>

<p>唯一一个在执行期才能知道的东西是：slot4所指的到底是哪一个z()函数实例</p>
<blockquote>
<p>在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，对virtual functions的支持就没有那么好了</p>
</blockquote>
<h4 id="2）多继承中的虚函数"><a href="#2）多继承中的虚函数" class="headerlink" title="2）多继承中的虚函数"></a>2）多继承中的虚函数</h4><p><strong>在多重继承中支持virtual functions，其复杂度围绕在第二个及后继的base classes身上，以及“必须在执行期调整this指针”这一点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speakClearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1 , <span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Derived;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在多重继承下，一个derived class内含n-1个”额外”的virtual tables，n表示其上一层base classes的个数（因此，单一继承将不会有额外的virtual tables）。对于上面的Derived类而言，会有2个virtual tables被编译器产生出来：</p>
<ol>
<li>一个主要实例，与Base1(最左端base class)共享</li>
<li>一个次要实例，与Base2(第二个base class)有关</li>
</ol>
<p>针对每一个virtual tables，Derived对象中有对应的vptr</p>
<p>用以支持“一个class拥有多个virtual tables”的传统方法是，将每一个tables以外部对象的形式产生出来，并给予独一无二的名称。例如，Derived所关联的两个tables可能有这样的名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vtbl__Derived;          <span class="comment">//主要表格</span></span><br><span class="line">vtbl__Base2__Derived;   <span class="comment">//次要表格</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将一个Derived对象地址指定给一个Base1指针或Derived指针时，被处理的virtual table是主要表格vtbl__Derived</li>
<li>将一个Derived对象地址指定给一个Base2指针时，被处理的virtual table是次要表格vtbl__Base2__Derived</li>
</ul>
<div align="center"> <img src="../pic/cppmode-4-2.png"/> </div>

<p><strong>有3种情况，第二或后继的base class会影响对virtual functions的支持</strong>：</p>
<ol>
<li><strong>通过一个“指向第二个base class”的指针，调用derived class virtual function</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用Derived::~Derived，ptr必须被向后（实际是向上）调整sizeof(Base1)个bytes</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>

<p>ptr指向Derived对象中的Base2 subobject；为了能够正确执行，ptr必须调整指向Derived对象的起始处</p>
<ol start="2">
<li><strong>通过一个“指向derived class”的指针，调用一个从第二个base class中继承而来的virtual function</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用Base2::mumble()，pder必须被向前（实际是向下）调整sizeof(Base1)个bytes</span></span><br><span class="line">pder-&gt;<span class="built_in">mumble</span>();</span><br></pre></td></tr></table></figure>

<p>在这种情况下，pder必须调整，指向第二个base subobject</p>
<ol start="3">
<li><strong>允许一个virtual function的返回值类型有所变化，可能是base type，也可能是derived type。clone函数的Derived版本传回一个Derived class指针</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用Derived* Derived::clone()，返回值必须被调整，以指向Base2 subobject</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure>

<p>当进行pb1-&gt;clone()时，pb1会被调整指向Derived对象的起始地址，于是clone()的Derived版会被调用。它会传回一个新的Derived对象。该对象的地址在被指定给pb2之前，必须先经过调整，以指向Base2 subobject</p>
<h4 id="3）虚继承下的虚函数"><a href="#3）虚继承下的虚函数" class="headerlink" title="3）虚继承下的虚函数"></a>3）虚继承下的虚函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>(<span class="keyword">float</span> = <span class="number">0.0</span>,<span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point2d</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> = <span class="number">0.0</span>,<span class="keyword">float</span> = <span class="number">0.0</span>,<span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    ~<span class="built_in">Point3d</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>virtual table布局如下：</p>
<div align="center"> <img src="../pic/cppmode-4-3.png"/> </div>

<p>虽然Point3d有唯一一个base class，即Point2d，但Point3d和Point2d的起始部分并不像“非虚拟的单一继承”情况那样一致。如上图所示，由于Point2d和Point3d的对象不再相符，两者之间的转换也就需要调整this指针。至于在虚拟继承的情况下要消除thunks，一般而言已经被证明是一项高难度技术</p>
<h2 id="4-3-指向Member-Function的指针"><a href="#4-3-指向Member-Function的指针" class="headerlink" title="4.3 指向Member Function的指针"></a>4.3 指向Member Function的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>) : _x(x),_y(y),_z(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y,_z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point3d p;</span><br><span class="line">    Point3d *pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义并初始化Member Function指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (Point3d::*pmf1)() = &amp;Point3d::x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    (p.*pmf1)();    <span class="comment">//会被编译器转换为：(pmf1)(&amp;p);</span></span><br><span class="line">    (pp-&gt;*pmf1)();  <span class="comment">//会被编译器转换为：(pmf1)(pp);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::x = %p\n&quot;</span> , &amp;Point3d::x);   <span class="comment">//0x10d81fec0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::y = %p\n&quot;</span> , &amp;Point3d::y);   <span class="comment">//0x10d81fee0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::z = %p\n&quot;</span> , &amp;Point3d::z);   <span class="comment">//0x10d81ff00</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取一个nonstatic memeber function的地址，如果函数非虚，得到的结果是它在内存中真正的地址</p>
<p>static member functions(没有this指针)的类型是“函数指针”，而不是“指向member function的指针”</p>
<p>使用一个“member function指针”，如果并不用于virtual function、多重继承、virtual base class等情况的话，并不会比使用一个“nonmember function指针”的成本更高，对于那些没有virtual functions、virtual base class或多重继承的类而言，编译器可以为它们提供相同的效率</p>
<h4 id="1）支持指向Virtual-Member-Functions的指针"><a href="#1）支持指向Virtual-Member-Functions的指针" class="headerlink" title="1）支持指向Virtual Member Functions的指针"></a>1）支持指向Virtual Member Functions的指针</h4><p>将上面的x()、y()、z()函数换成虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>) : _x(x),_y(y),_z(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">x</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y,_z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point3d p;</span><br><span class="line">    Point3d *pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义并初始化Member Function指针</span></span><br><span class="line">    <span class="built_in"><span class="keyword">float</span></span> (Point3d::*pmf1)() = &amp;Point3d::x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    (pp-&gt;*pmf1)();<span class="comment">//会被编译器转换为：(*pp-&gt;vptr[(int)pmf1])(pp);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::x = %p\n&quot;</span> , &amp;Point3d::x);   <span class="comment">//0x1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::y = %p\n&quot;</span> , &amp;Point3d::y);   <span class="comment">//0x9</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;Point3d::z = %p\n&quot;</span> , &amp;Point3d::z);   <span class="comment">//0x11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果显示，对虚函数取值得到的不是该函数在内存中的地址，而是一个索引值（或偏移量）</p>
<p>pmf1能够指向一般成员函数和虚拟成员函数，因此编译器必须定义pmf1，使它能够：1）持有两种数值；2）其数值可以被区别代表内存地址还是virtual table中的索引值（或偏移量）。在cfront2.0非正式版中，这两个值都被内含在一个普通的指针内。cfront使用如下技巧识别两种数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="keyword">int</span>)pmf1) &amp; ~<span class="number">127</span>) ? (*pmf1)(ptr) : (*pp-&gt;vptr[(<span class="keyword">int</span>)pmf1](ptr));</span><br></pre></td></tr></table></figure>

<p>这种实现技巧必须假设继承体系中最多只有128个virtual functions，这并不是我们所希望的，但却证明是可行的。然而多重继承的引入，导致需要更多一般化的实现模式，并趁机除去对virtual functions的个数限制</p>
<h4 id="2）多重继承下，指向Member-Functions的指针"><a href="#2）多重继承下，指向Member-Functions的指针" class="headerlink" title="2）多重继承下，指向Member Functions的指针"></a>2）多重继承下，指向Member Functions的指针</h4><p>为了让指向member functions的指针也能够支持多重继承和虚拟继承，Stroustrup设计了下面一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般结构，用以支持在多重继承之下指向member functions的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mptr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;              <span class="comment">//this指针的偏移</span></span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//virtual table索引（不指向virtual table时，会被设为-1）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        ptrtofunc faddr;    <span class="comment">//nonvirtual member function的地址</span></span><br><span class="line">        <span class="keyword">int</span> v_offset;       <span class="comment">//virtual base class的vptr的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此模型下，像下面的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br></pre></td></tr></table></figure>

<p>会变成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pmf.index &lt; <span class="number">0</span>) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure>

<p>这种方法存在下面两个问题：</p>
<ul>
<li>每一个调用操作都得付出上述成本，检查其是否为virtual或nonvirtual</li>
<li>当传入一个不变值的指针给member function时，需要产生一个临时性对象</li>
</ul>
<br>

<h2 id="4-4-Inline-Functions"><a href="#4-4-Inline-Functions" class="headerlink" title="4.4 Inline Functions"></a>4.4 Inline Functions</h2><p>暂略</p>
<br>
<br>

<h1 id="第5章-构造、析构、拷贝语意学"><a href="#第5章-构造、析构、拷贝语意学" class="headerlink" title="第5章 构造、析构、拷贝语意学"></a>第5章 构造、析构、拷贝语意学</h1><h2 id="5-1-无继承情况下的对象构造"><a href="#5-1-无继承情况下的对象构造" class="headerlink" title="5.1 无继承情况下的对象构造"></a>5.1 无继承情况下的对象构造</h2><h4 id="1）C-struct的Point声明"><a href="#1）C-struct的Point声明" class="headerlink" title="1）C struct的Point声明"></a>1）C struct的Point声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C++称这是一种所谓的Plain O1&#x27; Data声明形式。如果以C++来编译，观念上，编译器会为</span></span><br><span class="line"><span class="comment"> * Point声明一个trivial default construct、一个trivial destructor、一个</span></span><br><span class="line"><span class="comment"> * trivial copy constructor，以及一个trivial copy assignment operator。</span></span><br><span class="line"><span class="comment"> * 但实际上，编译器会分析这个声明，并为它贴上Plain OI&#x27; Data标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 观念上Point的trivial constructor和destructor都会被产生并被调用，constructor</span></span><br><span class="line"><span class="comment"> * 在程序起始处被调用而destructor在程序的exit()处被调用。然而，事实上那些</span></span><br><span class="line"><span class="comment"> * trivial members要不是没被定义，就是没被调用，程序的行为一如它在C中的表现一样</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 那么在C和C++中有什么区别？</span></span><br><span class="line"><span class="comment"> * 1）在C中，global被视为一个“临时性的定义”，因为它没有显式的初始化操作。一个“临时性的定义”</span></span><br><span class="line"><span class="comment"> * 可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实例，被放在程序</span></span><br><span class="line"><span class="comment"> * data segment中一个“特别保留给未初始化之global objects使用”的空间。由于历史的原因，</span></span><br><span class="line"><span class="comment"> * 这块空间被称为BSS</span></span><br><span class="line"><span class="comment"> * 2）C++并不支持“临时性的定义”，这是因为class构造行为的隐式应用的缘故。虽然大家公认这个语言</span></span><br><span class="line"><span class="comment"> * 可以判断一个class objects或是一个Plain O1&#x27; Data，但似乎没有必要搞这么复杂。因此，</span></span><br><span class="line"><span class="comment"> * global在C++中被视为完全定义（它会阻止第二个或更多的定义）。C和C++的一个差异就在于，</span></span><br><span class="line"><span class="comment"> * BSS data segment在C++中相对地不重要。C++的所有全局对象都被以“初始化过的数据”来对待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//既没有被构造也没有被析构</span></span><br><span class="line">    Point local;</span><br><span class="line">    <span class="comment">//没有default constructor实施于new运算符所传回的Point object身上</span></span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">    <span class="comment">//如果local曾被适当初始化过，一切就没问题，否则会产生编译警告</span></span><br><span class="line">    <span class="comment">//观念上，这样的指定操作会触发trivial copy assignment operator做拷贝搬运操作。</span></span><br><span class="line">    <span class="comment">//然而实际上该object是一个Plain OI&#x27; Data，所以赋值操作将只是像C那样的纯粹位搬移操作</span></span><br><span class="line">    *heap = local;</span><br><span class="line">    <span class="comment">//观念上，会触发trivial destructor，但实际上destructor要不是没有被产生就是没有被调用</span></span><br><span class="line">    <span class="keyword">delete</span> heap;</span><br><span class="line">    <span class="comment">//观念上会触发trivial copy constructor，不过实际上return操作只是一个简单的位拷贝操作，</span></span><br><span class="line">    <span class="comment">//因为对象是个Plain O1&#x27; Data</span></span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的global在C和C++中的区别：</p>
<div align="center"> <img src="../pic/cppmode-5-1.png"/> </div>

<h4 id="2）抽象数据类型"><a href="#2）抽象数据类型" class="headerlink" title="2）抽象数据类型"></a>2）抽象数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 提供了完整的封装性，但没有提供任何virtual function</span></span><br><span class="line"><span class="comment"> * 这个经过封装的Point class，其大小并没有改变，还是三个连续的float</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义了一个构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>)</span><br><span class="line">        : _x(x) , _y(y) , _z(z) &#123;&#125;</span><br><span class="line">    <span class="comment">//除此之外，没有定义其它成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x , _y , _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在有了default constructor作用于其上。由于global被定义在全局范畴中，其初始化操作</span></span><br><span class="line"><span class="comment">//在程序启动时进行</span></span><br><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * local的定义会被附上default Point constructor的inline expansion:</span></span><br><span class="line"><span class="comment">     * Point local;</span></span><br><span class="line"><span class="comment">     * local._x = 0.0, local._y = 0.0, local._z = 0.0;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Point local;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在则被附加一个“对default Point constructor的有条件调用操作”：</span></span><br><span class="line"><span class="comment">     * Point *heap = __new(sizeof(Point));</span></span><br><span class="line"><span class="comment">     * if(heap != 0)</span></span><br><span class="line"><span class="comment">     *     heap-&gt;Point::Point();</span></span><br><span class="line"><span class="comment">     * 在条件内才又被编译器进行inline expansion操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">    <span class="comment">//保持着简单的位拷贝操作</span></span><br><span class="line">    *heap = local;</span><br><span class="line">    <span class="comment">//并不会导致destructor被调用</span></span><br><span class="line">    <span class="keyword">delete</span> heap;</span><br><span class="line">    <span class="comment">//return时，同样保持着简单的位拷贝操作，并没有拷贝构造</span></span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，观念上，Point class有一个相关的default copy constructor、copy operator、和destructor。然而它们都是无关痛痒的，而且编译器实际上根本没有产生它们</p>
<h4 id="3）包含虚函数的Point声明"><a href="#3）包含虚函数的Point声明" class="headerlink" title="3）包含虚函数的Point声明"></a>3）包含虚函数的Point声明</h4><p>包含虚函数时，除了每一个class object多负担一个vptr之外，virtual function的导入也引发编译器对于Point class产生膨胀作用（如，编译器会在构造函数中插入初始化vptr的代码）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>) : _x(x) , _y(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x , _y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义构造函数中会安插初始化vptr的代码</li>
<li>因为需要处理vptr，所以会合成一个copy constructor和一个copy assignment operator，这两个函数不再是trivial（但隐式的destructor任然是trivial）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point * <span class="title">Point::Point</span><span class="params">(Point *<span class="keyword">this</span>,<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span> : _x(x) , _y(y)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="comment">//设定object的virtual table pointer(vptr)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展member initialization list</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_y = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传回this对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point* <span class="title">Point::Point</span><span class="params">(Point *<span class="keyword">this</span>,<span class="keyword">const</span> Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设定object的virtual table pointer(vptr)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将rhs左边中的连续位拷贝到this对象，</span></span><br><span class="line">    <span class="comment">//或是经由member assignment提供一个member...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器在优化状态下可能会把object的连续内容拷贝到另一个object身上，</span></span><br><span class="line"><span class="comment">//而不会实现一个精确地“以成员为基础的赋值操作”</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和前一版本相同</span></span><br><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//和前一版本相同</span></span><br><span class="line">    Point local;</span><br><span class="line">    <span class="comment">//和前一版本相应</span></span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">    <span class="comment">//这里可能触发copy assignment operator的合成，及其调用操作的一个</span></span><br><span class="line">    <span class="comment">//inline expansion（行内扩张），以this取代heap，而以rhs取代local</span></span><br><span class="line">    *heap = local;</span><br><span class="line">    <span class="comment">//和前一版本相同</span></span><br><span class="line">    <span class="keyword">delete</span> heap;</span><br><span class="line">    <span class="comment">//最具戏剧性的改变在这，下面讨论</span></span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于copy constructor的出现，foobar很可能被转化为下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    local.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heap的部分与前面相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy constructor的应用</span></span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(local);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁local对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果支持named return value(NRV)优化，会进一步被转化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heap的部分与前面相同...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般而言，如果设计之中有许多函数都需要以传值方式传回一个local class object，那么提供一个copy constructor就比较合理——甚至即使default memberwise语意已经足够。它的出现会触发NRV优化。然而，就像前面例子展现的那样，NRV优化后将不再需要调用copy constructor，因为运算结果已经被直接计算于“将被传回的object”内了</p>
</blockquote>
<h2 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h4><p>假设具有如下继承体系：</p>
<div align="center"> <img src="../pic/cppmode-5-2.png"/> </div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Point</span>(x,y),_z(z) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">const</span> Point3d &amp;rhs) : <span class="built_in">Point</span>(rhs),_z(rhs._z) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Point3d</span>();</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point3d&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PVertex</span> :</span> <span class="keyword">public</span> Vertex3d &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在虚拟继承下，一个主要的问题是如何初始化“虚基类子对象”，调用虚基类的构造函数初始化”虚基类子对象“应该在最底层的派生类中进行</strong></p>
<p>因此，Point3d的构造函数可能被编译器扩充成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d* <span class="title">Point3d::Point3d</span><span class="params">(Point3d *<span class="keyword">this</span>,<span class="keyword">bool</span> __most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(__most_derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d = __vtbl__Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d__Point;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更深层的继承情况下，例如Vertex3d，调用Point3d和Vertex的constructor时，总是会把__most_derived参数设为false，于是就压制了两个constructors中对Point constructor的调用操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vertex3d* <span class="title">Vertex3d::Vertex3d</span><span class="params">(Vertex3d *<span class="keyword">this</span>,<span class="keyword">bool</span> __most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(__most_derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x,y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用上一层base classes设定__most_derived为false</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::<span class="built_in">Point3d</span>(<span class="literal">false</span>,x,y,z);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::<span class="built_in">Vertex</span>(<span class="literal">false</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定vptrs，安插user code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>Point3d origin;</code> 和 <code>Vertex3d cv;</code> 都能正确的调用Point constructor</p>
<blockquote>
<p>某些新进的编译器把每个constructor分裂为二，一个针对完整的object，另一个针对subobject。”完整object“版无条件地调用virtual base constructor，设定所有的vptrs等。”subobject“版则不调用virtual base constructors，也可能不设定vptrs等。constructor的分裂可带来程序速度的提升，但是使用这个技术的编译器似乎很少，或者说没有</p>
</blockquote>
<h4 id="vptr的设置"><a href="#vptr的设置" class="headerlink" title="vptr的设置"></a>vptr的设置</h4><p><strong>vptr会在构造函数中进行初始化，关键是vptr应该在构造函数中何时执行初始化。考虑这个问题是因为：如果在构造函数中调用虚拟函数，那么vptr的初始化时机可能会给使得程序产生不一致的表现</strong></p>
<p>当定义一个PVertex object时，constructors的调用顺序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(x,y);         <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Point3d</span>(x,y,z);     <span class="comment">//2</span></span><br><span class="line"><span class="built_in">Vertex</span>(x,y,z);      <span class="comment">//3</span></span><br><span class="line"><span class="built_in">Vertex3d</span>(x,y,z);    <span class="comment">//4</span></span><br><span class="line"><span class="built_in">PVertex</span>(x,y,z);     <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>假设这个继承体系中的每一个class都定义了一个virtual function size()，函数负责传回class的大小，并且在每一个构造函数中调用这个size()函数。那么当定义PVertex object时，5个constructors会如何？每一次size()都是调用PVertex::size()？或者每次调用会被决议为”目前正在执行的constructor所对应的class“的size()函数实例？答案是后者，关键是编译器如何处理，来实现这一点</p>
<ul>
<li>如果调用操作限制必须在constructor中直接调用，那么将每一个调用操作以静态方式决议，而不使用虚拟机制。例如，在Point3d constructor中，就显式调用Point3d::size()。然而，如果size()之中又调用一个virtual function，会发生什么？这种情况下，这个调用也必须决议为Point3d的函数实例。而在其它情况下，这个调用是纯正的virtual，必须经由虚拟机制来决定其归向。也就是说，虚拟机制本身必须知道是否这个调用源自于一个constructor之中</li>
<li><strong>根本的解决之道是，在执行一个constructor时，必须限制一组virtual functions候选名单</strong>。因此需要处理virtual table，而处理virtual table又需要通过vptr。所以为了控制一个class中有所作用的函数，编译系统只要简单地控制vptr的初始化和设定操作即可</li>
</ul>
<p><strong>vptr应该在base class constructors调用之后，在程序员提供的代码及member initialization list中所列的members初始化操作之前进行初始化</strong></p>
<ul>
<li>如果每一个constructor都一直等待到其base class constructors执行完毕之后才设定其对象的vptr，那么每次都能调用正确的virtual function实例</li>
<li>在程序员提供的代码之前设定vptr是因为程序员提供的代码中可能会调用virtual function，因此必须先设定</li>
<li>在member initialization list之前设定是因为member initialization list中也可能调用virtual function。因此需要先进行设定</li>
</ul>
<p>那么这种方式是否安全？考虑下列两种情况：</p>
<ul>
<li><strong>在class的constructor的member initialization list中调用该class的一个虚函数</strong>：vptr能在member initialization list被扩展之前由编译器正确设定好。而虚函数本身可能还得依赖未被设立初值的members，所以语意上可能是不安全的。然而从vptr的整体角度来看，是安全的</li>
<li><strong>在member initialization list中使用虚函数为base class constructor提供参数</strong>：这是不安全的，由于base class constructor的执行在vptr的设定之前，因此，此时vpt若不是尚未被设定好，就是被设定指向错误的class。更进一步地说，该函数所存取的任何class’s data members一定还没有被初始化</li>
</ul>
<h2 id="5-3-对象拷贝语意学"><a href="#5-3-对象拷贝语意学" class="headerlink" title="5.3 对象拷贝语意学"></a>5.3 对象拷贝语意学</h2><p>一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意：</p>
<ol>
<li>当class内含有一个member object，而其class有一个copy assignment operator时</li>
<li>当一个class的base class有一个copy assignment operator时</li>
<li>当一个class声明了任何virtual functions时（一定不要拷贝右端class object的vptr地址，因为它可能是一个derived class object）</li>
<li>当class继承自一个virtual base class时（无论此base class有没有copy operator）时</li>
</ol>
<p>C++标准上说，copy assignment operator在不表现出bitwise copy semantics时，是nontrivial的，只有nontrivial的实例才会被合成出来 </p>
<p>以上面的2.为例子看看编译器合成的copy assignment operator是什么样子，在为Point类显式定义一个copy assignment operator，然后Point3d继承类Point，但是不显式定义copy assignment operator：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    _x = p._x;</span><br><span class="line">    _y = p._y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>,<span class="keyword">float</span> y = <span class="number">0.0</span>,<span class="keyword">float</span> z = <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器为Point3d合成的copy assignment operator，类似如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point3d&amp; Point3d::<span class="keyword">operator</span>=(Point3d* <span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">const</span> Point3d &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用base class的函数实例</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(p);  <span class="comment">//或(*(Point*)this) = p;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐成员拷贝派生类的成员</span></span><br><span class="line">    _z = p._z;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>copy assignment operator是一个非正交性情况，它缺乏一个member assignment list（平行于member initialization list的东西）</p>
</blockquote>
<h4 id="虚继承中的拷贝赋值"><a href="#虚继承中的拷贝赋值" class="headerlink" title="虚继承中的拷贝赋值"></a>虚继承中的拷贝赋值</h4><p>假设编译器按上面的形式合成子类的copy assignment operator，现在假设另一个类Vertex，和Point3d一样，派生自Point，那么编译器为Vertex合成的copy assignment operator，类似如下形式：：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex&amp; Vertex::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    _next = v._next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在又从Point3d和Vertex中派生出Vertex3d。编译器也会为Vertex3d合成copy assignment operator：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp; Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::<span class="keyword">operator</span>=(v);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行Point3d和Vertex的copy assignment operator时，会重复调用Point的copy assignment operator</p>
<p>事实上，copy assignment operator在虚拟继承情况下行为不佳，需要小心地设计和说明。许多编译器甚至并不尝试取得正确的语意，它们在每一个中间的copy assignment operator中调用每一个base class instance，于是造成virtual base class copy assignment operator的多个实例被调用。cfront、Edison Design Group的前端处理器、Borland C++ 4.5以及Symantec最新版C++编译器都这么做，而C++标准对此其实也并没有做限制</p>
<h2 id="5-4-析构语意学"><a href="#5-4-析构语意学" class="headerlink" title="5.4 析构语意学"></a>5.4 析构语意学</h2><p>如果class没有定义destructor，那么只有在class内含的member object（抑或class自己的base class）拥有destructor的情况下，编译器才会自动合成出一个来</p>
<p>一个destructor被扩展的方式类似constructor被扩展的方式，但是顺序相反：</p>
<ol>
<li>destructor的函数本体首先被执行</li>
<li>如果class拥有member class object，而后者拥有destructors，那么它们会以其声明顺序的相反顺序被调用</li>
<li>如果object内含一个vptr，现在被重新设定，指向适当base class的virtual table</li>
<li>如果有任何直接的（上一层）nonvirtual base classes拥有destructors，那么它们会以其声明顺序的相反顺序被调用</li>
<li>如果有任何virtual base classes拥有destructor，而目前讨论的这个class是最尾端的class，那么它们会以其原来的构造顺序的相反顺序被调用</li>
</ol>
<blockquote>
<p>就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实例：</p>
<ul>
<li>一个complete object实例，总是设定好vptr(s)，并调用virtual base class destructor</li>
<li>一个base class subobject实例；除非在destructor函数中调用一个virtual function，否则它绝不会调用virtual base class destructors并设定vptr（因为如果不调用虚函数就没必要修改vptr）</li>
</ul>
<p>一个object的生命结束于其destructor开始执行之时。由于每一个base class destructor都轮番被调用，所以derived object实际上变成了一个完整的object。例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象，一个Point3d对象，最后成为一个Point对象。当我们在destructor中调用member functions时，对象的蜕变会因为vptr的重新设定（在每一个destructor中，在程序员所提供的代码执行之前）而受到影响</p>
</blockquote>
<br>
<br>

<h1 id="第6章-执行期语意学"><a href="#第6章-执行期语意学" class="headerlink" title="第6章 执行期语意学"></a>第6章 执行期语意学</h1><h2 id="6-1-静态对象的构造和析构"><a href="#6-1-静态对象的构造和析构" class="headerlink" title="6.1 静态对象的构造和析构"></a>6.1 静态对象的构造和析构</h2><h4 id="1）全局对象"><a href="#1）全局对象" class="headerlink" title="1）全局对象"></a>1）全局对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Matrix identity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//identity必须在此处被初始化</span></span><br><span class="line">    Matrix m1 = identity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++保证，一定会在main()函数中第一次用到identity之前，把identity构造出来，而在main()函数结束之前吧identity摧毁掉。像identity这样的所谓global object如果有constructor和destructor的话，我们说它需要<strong>静态的初始化操作和内存释放操作</strong></p>
<p>当cfront还是唯一的C++编译器，而且跨平台移植性比效率的考虑更重要的时候，有一个可移植但成本颇高的**静态初始化(以及内存释放)**方法，称为munch策略：</p>
<ol>
<li>为每一个需要静态初始化的文件产生一个_sti()函数，内含必要的constructor调用操作或inline expansions。例如前面的identity对象会在matrix.c中产生出下面的__sti()函数：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__sti__matrix_c__identity()</span><br><span class="line">&#123;</span><br><span class="line">    identity.Matrix::<span class="built_in">Matrix</span>();  <span class="comment">//静态初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在每一个需要静态的内存内存释放操作的文件中，产生一个__std()函数，内含必要的destructor调用操作，或是其inline expansions</p>
</li>
<li><p>提供一组runtime library “munch”函数；一个_main()函数（用以调用可执行文件中的所有__sti()函数）,以及一个exit()函数（以类似方式调用所有的__std()函数）</p>
</li>
</ol>
<div align="center"> <img src="../pic/cppmode-6-1.png"/> </div>

<p>cfront2.0版之前并不支持noclass object的静态初始化操作；也就是说C语言的限制仍然残留着。所以下面的每一个初始化操作都被标为不合法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部都要求静态初始化，在2.0版之前的C和C++中，都是不合法的</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(i);</span><br><span class="line"><span class="keyword">double</span> sal = <span class="built_in">compute_sal</span>(<span class="built_in">get_employee</span>(i));</span><br></pre></td></tr></table></figure>

<p>使用被静态初始化的objects，有下列缺点：</p>
<ul>
<li>如果exception handling被支持，那些objects将不能够被放置于try区段之内。这对于被静态调用的constructors可能是特别无法接受的，因为任何的throw操作将必然触发exception handling library默认的terminate()函数</li>
<li>为了控制”需要跨越模块做静态初始化“的objects的相依顺序，而扯出来的复杂度</li>
</ul>
<blockquote>
<p>作者建议根本就不要用那些需要静态初始化的global objects（虽然这项建议几乎普遍不为C程序员所接受）</p>
</blockquote>
<h4 id="2）局部静态对象"><a href="#2）局部静态对象" class="headerlink" title="2）局部静态对象"></a>2）局部静态对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Matrix&amp; <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Matrix mat_identity;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mat_identity的constructor必须只能执行一次，虽然上述函数可能被调用多次</li>
<li>mat_identity的destructor必须只能执行一次，虽然上述函数可能会被调用多次</li>
</ul>
<p>编译器的<strong>策略之一</strong>是，无条件地在程序起始时构造出对象来。然而这会导致所有的local static class objects都在程序起始时被初始化，即使它们所在的那个函数从不曾被调用过</p>
<p><strong>实际上identity()被调用时才把mat_identity构造起来是一种更好的做法，现在的C++标准已经强制要求这一点了</strong>。<br>cfront实现的方法是：首先，导入一个临时性对象以保护mat_identity的初始化操作。第一次处理identity()时，这个临时对象被评估为false，于是constructor会被调用，然后临时对象被改为true。这样就解决了构造的问题。而在相反的一端，destructor也需要有条件地实施于mat_identity身上，只有在mat_identity已经被构造起来才调用，可以通过临时对象是否为true来判断mat_identity是否已经构造</p>
<h4 id="3）对象数组"><a href="#3）对象数组" class="headerlink" title="3）对象数组"></a>3）对象数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>如果Point没有定义一个constructor和destructor，那么上述代码执行的工作不会比建立一个”内建类型所组成的数组“更多（即，不会调用下面所要讲到的vec_new()），也就是说只要配置足够内存以存储10个连续的Point元素即可</p>
<p>在cfront中，使用一个命名为vec_new()的函数，产生出以class objects构造而成的数组。（比较新的编译器，则是提供两个函数，一个用来处理”没有virtual base class“的class，另一个用来处理”内含virtual base class“的class，后一个函数通常被称为vec_vnew()）函数vec_new()类型通常如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vec_new</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *array,                        <span class="comment">//数组起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> elem_size,                   <span class="comment">//每一个class object的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> elem_count,                     <span class="comment">//数组中的元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*constructor)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*,<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>constructor是class的default constructor的函数指针</li>
<li>destructor是class的default destructor的函数指针</li>
<li>array持有的若不是具名数组的地址，就是0。如果是0，那么数组将经由应用程序的new运算符被动态配置于heap中</li>
</ul>
<p>假设Point定义了一个constructor，以下是编译器可能对10个Point元素所做的vec_new()调用操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">vec_new</span>(&amp;knots,<span class="built_in"><span class="keyword">sizeof</span></span>(Point),<span class="number">10</span>,&amp;Point::Point,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果Point也定义了一个destructor，当knots的生命结束时，该destructor也必须实施于10个Point元素身上，经由一个类似的vec_delete()的runtime library函数完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vec_delete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *array,                        <span class="comment">//数组起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> elem_size,                   <span class="comment">//每一个class object的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> elem_count,                     <span class="comment">//数组中的元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*,<span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-new和delete运算符"><a href="#6-2-new和delete运算符" class="headerlink" title="6.2 new和delete运算符"></a>6.2 new和delete运算符</h2><h4 id="1）new"><a href="#1）new" class="headerlink" title="1）new"></a>1）new</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>实际上是由两个步骤完成的：</p>
<ol>
<li>通过适当的new运算符函数实例，配置所需内存：<code>int *pi = __new(sizeof(int));</code></li>
<li>将配置得来的对象设置初值：<code>*pi = 5;</code></li>
</ol>
<p>更进一步，初始化操作应该在内存配置成功后才执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">if</span>(pi = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))) <span class="comment">//（__new即下面会说到的operator new）</span></span><br><span class="line">    *pi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以constructor来配置一个class object的情况类似</p>
</blockquote>
<h4 id="2）delete"><a href="#2）delete" class="headerlink" title="2）delete"></a>2）delete</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure>

<p>delete pi时，如果pi是0，C++要求delete运算符不要有操作。因此”编译器“必须为此调用构造一层保护：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pi != <span class="number">0</span>)</span><br><span class="line">    __delete(pi);   <span class="comment">//（__delete即下面会说到的operator delete）释放内存，但是pi并不会设为为0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>destructor的应用极为相似，在__delete前会调用destructor</p>
</blockquote>
<h4 id="3）operator-new和operator-delete的实现"><a href="#3）operator-new和operator-delete的实现" class="headerlink" title="3）operator new和operator delete的实现"></a>3）operator new和operator delete的实现</h4><p>一般的library对于new运算符的实现操作都很直截了当，但有两个精巧之处值得斟酌（以下版本并未考虑exception handling）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *last_alloc;</span><br><span class="line">    <span class="keyword">while</span>(!(last_alloc = <span class="built_in">malloc</span>(size)))&#123;</span><br><span class="line">        <span class="keyword">if</span>(_new_handler)</span><br><span class="line">            (*_new_handler)();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这虽然这样是合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> T[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>但语言要求每一次对new的调用都必须传回一个独一无二的指针。解决此问题的传统方法是传回一个指针，指向一个默认为1 byte的内存区块（上述代码中将size设为1的原因）</p>
<p>上述实现允许使用者提供一个属于自己的_new_handler()函数</p>
<blockquote>
<p>operator new实际上总是以标准的C malloc完成，虽然并没有规定一定得这么做</p>
</blockquote>
<p>operator delete也总是以标准的C free()完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr)</span><br><span class="line">        <span class="built_in">free</span>((<span class="keyword">char</span>*)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）针对数组的new语意"><a href="#4）针对数组的new语意" class="headerlink" title="4）针对数组的new语意"></a>4）针对数组的new语意</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>vec_new()不会真正被调用，因为它的主要功能是把default constructor施行于class objects所组成的数组的每一个元素身上，倒是operator new会被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_array = (<span class="keyword">int</span>*)__new(<span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>相同的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct simple_aggr&#123;float f1,f2;&#125;;</span></span><br><span class="line">simple_aggr *p_aggr = <span class="keyword">new</span> simple_aggr[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>vec_new()也不会被调用。因为simple_aggr并没有定义一个constructor或destructor，所以配置数组以及清除p_aggr数组的操作，只是单纯地获得内存和释放内存而已。由operator new和operator delete来完成绰绰有余</p>
<p>如果class定义了一个default constructor，某些版本的vec_new()就会被调用</p>
<p>当 <code>delete</code> 一个指向数组的指针时，C++2.0版之前，需要提供数组的大小。而2.1版后，不需要提供数组大小，只有在 <code>[]</code> 出现时，编译器才寻找数组的维度。否则它便假设只有单独一个object要被删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的代码应该是delete [] p_array;</span></span><br><span class="line"><span class="keyword">delete</span> p_array;</span><br></pre></td></tr></table></figure>

<p>只有第一个元素会被析构。其它元素仍然存在——虽然相关的内存已经被要求归还了</p>
<p>由于新版可以不提供数组大小，那么如何记录数组的元素，以便在 <code>delete [] arr;</code> 时使用？</p>
<ul>
<li>一个明显的方法是为vec_new()所传回的每一个内存区块配置一个额外的word，然后把元素个数包藏在这个word之中，通常这种被包藏的数值称为cookie</li>
<li>Jonathan和Sun编译器决定维护一个”联合数组“，防止指针及大小。Sun也把destructor的地址维护于此数组之中</li>
</ul>
<p>cookie策略有一个普遍引起忧虑的话题，如果一个坏指针被交给delete_vec()，取出来的cookie自然是不合法的。一个不合法的元素个数和一个坏指针的起始地址，会导致destructor以非预期的次数被实施于一段非预期的区域。然而在”联合数组“的策略下，坏指针的可能结果就只是取出错误的元素个数而已</p>
<p><strong>避免以一个base class指针指向一个derived class objects所组成的数组</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point *ptr = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>实施于数组上的destructor，是根据交给vec_delete()函数的”被删除的指针类型的destructor“——在本例中就是Point destructor，与我们的期望不符。此外，每一个元素的大小也一并被传递过去（本例中是Point class object的大小）。这就是vec_delete()如何迭代走过每一个数组元素的方式。因此整个过程失败了，不只是因为执行了错误的destructor，而且自从第一个元素之后，该destructor即被施行于不正确的内存区块中</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() &#123;cout &lt;&lt; <span class="string">&quot;base constructor&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived</span>() &#123;cout &lt;&lt; <span class="string">&quot;derived constructor&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">derived</span>() &#123;cout &lt;&lt; <span class="string">&quot;derived destructor&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base *arr = <span class="keyword">new</span> derived[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">delete</span> [] arr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//new时构造出了5个子类对象，delete时，调用的是基类的析构函数</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base constructor</span><br><span class="line">derived constructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br><span class="line">base destructor</span><br></pre></td></tr></table></figure>

<h2 id="6-3-临时性对象"><a href="#6-3-临时性对象" class="headerlink" title="6.3 临时性对象"></a>6.3 临时性对象</h2><p>分析下列3个语句产生的临时对象：</p>
<ol>
<li><code>T c = a + b;</code></li>
<li><code>c = a + b;</code></li>
<li><code>a + b;</code></li>
</ol>
<p>对于 <code>T c = a + b;</code> C++标准允许编译器厂商有完全的自由度：</p>
<ul>
<li>编译器可以产生一个临时对象，放置a+b的结果，然后再使用T的copy constructor，把该临时性对象当作C的初始值</li>
<li>编译器也可以直接以拷贝构造的方式，将a+b的值放到C中（2.3节），于是不需要临时对象，以及对其的constructor和destructor</li>
<li>视operator+()的定义而定，NRV(named return value)优化也可能实施，这将导致直接在c对象中求表达式结果，避免执行copy constructor和具名对象的destructor</li>
</ul>
<p>实际上，由于市场竞争，几乎保证任何表达式<code>T c = a + b;</code> 背后的operator+()的实现都不会产生一个临时对象</p>
<p>对于 <code>c = a + b;</code> ，不能忽略临时对象，它将会导致下面的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T temp = a + b;</span></span><br><span class="line">T temp;</span><br><span class="line">temp.<span class="keyword">operator</span>+(a,b);</span><br><span class="line"><span class="comment">//c = temp</span></span><br><span class="line">c.<span class="keyword">operator</span>=(temp);</span><br><span class="line">temp.T::~<span class="built_in">T</span>();</span><br></pre></td></tr></table></figure>

<p>直接传递c到运算符函数中都是有问题的。由于运算符函数并不为其外加参数调用一个destructor（它期望一块”新鲜的“内存），所以必须在此调用之前先调用destructor</p>
<p>对于 <code>a + b;</code>，没有出现目标对象，这时候有必要产生一个临时对象以外置运算后的结果。这种情况在子表达式中十分普遍。<strong>这种情况下的一个问题是何时销毁临时对象，C++标准规定，临时对象的被销毁，应该是对完整表达式求值过程中的最后一个步骤，该完整表达式造成临时对象的产生</strong>，但是，这个规则也存在2个例外：</p>
<ol>
<li>发生在表达式被用来初始化一个object时，此时在object初始化完成后才销毁临时对象：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> verbose;</span><br><span class="line">...</span><br><span class="line">String progNameVersion = !verbose ? <span class="number">0</span> : progName + progVersion;</span><br></pre></td></tr></table></figure>

<p>如果在完整的”? : 表达式“结束后就销毁临时的progName + progVersion对象，那么就无法正确初始化progNameVersion</p>
<p>但是，即使遵守这个规则，程序员还是可能让一个临时对象在控制中被摧毁，最终初始化操作失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *progNameVersion = progName + progVersion;</span><br></pre></td></tr></table></figure>

<p>产生的临时对象会调用转换函数转换为char*，然后赋值给progNameVersion，在初始化完成后，临时对象的销毁会使得指针指向未定义的内存</p>
<ol start="2">
<li>”当一个临时对象被一个reference绑定“时，临时对象应该在reference的生命结束后才销毁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String &amp;space = <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果临时对象在初始化space后就销毁，那么reference也就没用了</p>
<blockquote>
<p>在类似 <code>if(s + t || u + v)</code> 这种表达式中，临时对象是根据程序的执行期语意，有条件地被产生出来的，如果把临时对象的destructor放在每一个子算式的求值过程中，可以免除”努力追踪第二个子算式是否真的需要被评估“。然后现在C++标准以及要求这类表达式在整个完整表达式结束后才销毁临时对象，因此某些形式的测试会被安插进来，以决定是否要摧毁和第二算式有关的临时对象</p>
</blockquote>
<br>
<br>

<h1 id="附：使用gdb分析对象模型"><a href="#附：使用gdb分析对象模型" class="headerlink" title="附：使用gdb分析对象模型"></a>附：使用gdb分析对象模型</h1><p><a target="_blank" rel="noopener" href="https://github.com/arkingc/note/blob/master/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md#3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7gdb">gdb的使用</a></p>
<p>环境信息：</p>
<div align="center"> <img src="../pic/cppmode-f-0.png"/> </div>

<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::f()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::g()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::h()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;Derived::print&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Derived d;</span><br><span class="line"></span><br><span class="line">    func pFunc1 = (func)(*(<span class="keyword">long</span> *)*(<span class="keyword">long</span> *)(&amp;d));</span><br><span class="line">    func pFunc2 = (func)(*((<span class="keyword">long</span> *)*(<span class="keyword">long</span> *)(&amp;d) + <span class="number">1</span>));</span><br><span class="line">    func pFunc3 = (func)(*((<span class="keyword">long</span> *)*(<span class="keyword">long</span> *)(&amp;d) + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pFunc1</span>();   <span class="comment">//Base::f()</span></span><br><span class="line">    <span class="built_in">pFunc2</span>();   <span class="comment">//Base::g()</span></span><br><span class="line">    <span class="built_in">pFunc3</span>();   <span class="comment">//Base::h()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<strong>对象的内存布局</strong>：</p>
<ul>
<li><p>可以使用<code>p 对象</code>直接打印对象：</p>
<div align="center"> <img src="../pic/cppmode-f-2.png"/> </div></li>
<li><p>可以通过打印对象地址查看虚函数表：</p>
<div align="center"> <img src="../pic/cppmode-f-1.png"/> </div></li>
</ul>
<p>查看<strong>虚函数表</strong>：</p>
<ul>
<li><p>通过虚函数表的地址打印出每个虚函数的地址</p>
<div align="center"> <img src="../pic/cppmode-f-3.png"/> </div></li>
<li><p>使用<code>info line 行号</code>打印出虚函数的地址，使用<code>x</code>命令核对虚函数表中虚函数指针的布局：</p>
<div align="center"> <img src="../pic/cppmode-f-4.png"/> </div></li>
</ul>
<p>画图表示如下（typeinfo在虚函数表上方）：</p>
<div align="center"> <img src="../pic/cppmode-f-5.png"/> </div>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/running/">跑步</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">第2章 构造函数语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 默认构造函数的构造操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 拷贝构造函数的构造操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 程序转换语意学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 成员初始化列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Data%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">2.</span> <span class="toc-text">第3章 Data语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Data-Member%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 Data Member的绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Data-Member%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 Data Member的布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Data-Member%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 Data Member的存取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BB%A7%E6%89%BF%E4%B8%8EData-Member"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 继承与Data Member</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">1）不使用继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8D%E5%90%AB%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">2）不含多态的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%90%AB%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">3）含多态的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.4.</span> <span class="toc-text">4）多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.0.5.</span> <span class="toc-text">5）虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%8C%87%E5%90%91Data-Members%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.</span> <span class="toc-text">3.5 指向Data Members的指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">3.</span> <span class="toc-text">第4章 Function语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Member%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 Member的各种调用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Nonstatic-Member-Functions-%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">1）Nonstatic Member Functions(非静态成员函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">名称的特殊处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">成员函数重载的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Static-Member-Functions-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">2）Static Member Functions(静态成员函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Virtual-Member-Functions-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">3）Virtual Member Functions(虚函数)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Virtual-Member-Functions%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 Virtual Member Functions虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">1）单继承中的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">2）多继承中的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">3）虚继承下的虚函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%8C%87%E5%90%91Member-Function%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 指向Member Function的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%94%AF%E6%8C%81%E6%8C%87%E5%90%91Virtual-Member-Functions%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">1）支持指向Virtual Member Functions的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%EF%BC%8C%E6%8C%87%E5%90%91Member-Functions%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">2）多重继承下，指向Member Functions的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Inline-Functions"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 Inline Functions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.</span> <span class="toc-text">第5章 构造、析构、拷贝语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%97%A0%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">4.1.</span> <span class="toc-text">5.1 无继承情况下的对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89C-struct%E7%9A%84Point%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">1）C struct的Point声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">2）抽象数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8C%85%E5%90%AB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84Point%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">3）包含虚函数的Point声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">4.2.</span> <span class="toc-text">5.2 继承体系下的对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vptr%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">vptr的设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.3.</span> <span class="toc-text">5.3 对象拷贝语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">虚继承中的拷贝赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">4.4.</span> <span class="toc-text">5.4 析构语意学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="toc-number">5.</span> <span class="toc-text">第6章 执行期语意学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">6.1 静态对象的构造和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">1）全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">2）局部静态对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">3）对象数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">6.2 new和delete运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89new"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">1）new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89delete"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">2）delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89operator-new%E5%92%8Coperator-delete%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">3）operator new和operator delete的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%92%88%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84new%E8%AF%AD%E6%84%8F"><span class="toc-number">5.2.0.4.</span> <span class="toc-text">4）针对数组的new语意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">6.3 临时性对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%EF%BC%9A%E4%BD%BF%E7%94%A8gdb%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">附：使用gdb分析对象模型</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&text="><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&is_video=false&description="><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&title="><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&name=&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/17/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/&t="><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    ap0l1o
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
