<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C/C++网络编程入门</title>
    <link href="/2022/09/20/C%E5%92%8CC++/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/09/20/C%E5%92%8CC++/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基于TCP"><a href="#基于TCP" class="headerlink" title="基于TCP"></a>基于TCP</h1><h2 id="0x00-服务器端函数用法"><a href="#0x00-服务器端函数用法" class="headerlink" title="0x00 服务器端函数用法"></a>0x00 服务器端函数用法</h2><p>下面各小节将按照TCP服务器端默认的函数调用顺序来介绍其用法。绝大部分的TCP服务器端都按照该顺序调用。</p><h3 id="0x01-socket-创建套接字"><a href="#0x01-socket-创建套接字" class="headerlink" title="0x01 socket() 创建套接字"></a>0x01 <code>socket()</code> 创建套接字</h3><p>在进入正题之前，先简单介绍一下文件与Socket。<br>在Linux系统中，socket也被认为是文件的一种，因此在网络数据传输过程中也会用到文件I/O相关的函数。在Linux系统中成功调用<code>open()</code>函数打开一个文件时会返回一个文件描述符（File Descriptor）。文件描述符是系统分配给文件或套接字的整数，用于方便称呼操作系统创建的文件或套接字。（文件描述符有时也被称为「文件句柄」，但「句柄」主要是Windows系统中的术语）<br>文件和套接字一般经过创建过程才会被分配文件描述符，而有三种输入输出对象即使未经过特殊的创建过程，在程序开始运行后也会被自动分配文件描述符。这三种输入输出对象为：<br>| 文件描述符 | 输入输出对象 |<br>| :—-: | :—-: |<br>| 0 | 标准输入|<br>| 1 | 标准输出 |<br>| 2 | 标准错误 |<br>因为0、1、2是分配给标准I/O的描述符，所以系统在创建文件和套接字时所获的的文件描述符是从3开始以由小到大的顺序编号的。</p><p>好了，下面开始进入正题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回对象：成功时返回一个文件描述符，失败时返回-1；</li><li><code>domain</code>：套接字中使用的协议簇（protocol family，PF）信息；</li><li><code>type</code>：套接字所选用的数据传输类型；</li><li><code>protocol</code>：计算机间通信所采用的协议；</li></ul><p>下面介绍各个参数的可选择传递对象。</p><h4 id="协议簇（Protocol-Family，PF）"><a href="#协议簇（Protocol-Family，PF）" class="headerlink" title="协议簇（Protocol Family，PF）"></a>协议簇（Protocol Family，PF）</h4><p>常用的互联网协议簇为IPv4互联网协议簇，该协议簇在头文件<code>sys/socket.h</code>中被定义为<code>PF_INET</code></p><h4 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h4><p>套接字类型值得是套接字的数据传输方式，在IPv4协议簇中也存在多种数据传输方式，因此需要指定具体采用哪种数据传输方式。具体的传输方式有：</p><ul><li><code>SOCK_STREAM</code> ：创建面向连接的套接字，其特征为<ul><li>传输过程中数据不会丢失；</li><li>按序传输数据；</li><li>传输的数据不存在数据边界，收到数据并不意味着马上调用<code>read()</code>函数，<code>read()</code>函数和<code>write()</code>函数的调用次数并无太大意义；</li></ul></li><li><code>SOCK_DGRAM</code>：创建面向消息的套接字，其特征为<ul><li>强调快速传输而非传输顺序；</li><li>传输的数据有可能丢失也有可能损毁；</li><li>传输的数据有数据边界，这意味着接受数据的次数应和传输次数相同，也即<code>read()</code>函数和<code>write()</code>函数的调用次数一致；</li><li>限制每次传输的数据大小；</li></ul></li></ul><h4 id="协议的选择"><a href="#协议的选择" class="headerlink" title="协议的选择"></a>协议的选择</h4><p>大多数情况下，通过前两个参数（协议簇和套接字类型）已经决定了所采用的传输协议，所以大部分情况下可以向第三个参数传递0，除非遇到「同一协议簇中存在多个数据传输方式相同的协议」的情况。<br>参数<code>PF_INET</code>指IPv4网络协议簇，<code>SOCK_STREAM</code>是面向连接的数据传输，满足这两个条件的协议只有<code>IPPROTO_TCP</code>，因此可以用如下方式创建TCP套接字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-keyword">int</span> tcp_socket = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);<br></code></pre></td></tr></table></figure><p>满足IPv4协议簇和面向消息数据传输方式的协议只有IPPROTO_UDP，因此可以用如下方式创建UDP套接字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-keyword">int</span> udp_socket = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_DGRAM, IPPROTO_UDP);<br></code></pre></td></tr></table></figure><h3 id="0x02-bind"><a href="#0x02-bind" class="headerlink" title="0x02 bind()"></a>0x02 <code>bind()</code></h3><p>创建套接字后需要使用bind()函数为其分配IP地址和端口号。IP地址用于区分网络上的计算机，而端口号用于区分计算机程序中所创建的套接字。<br>这里的IP地址主要是指的常用的IPv4地址，标准的IPv4地址用4字节表示。端口号由2个字节表示，可分配的端口号范围为0～65535，但0～1023是知名端口号，一般分配给特定的应用程序，所以应当分配此范围之外的值。<br>另外，虽然端口号不能重复，但TCP套接字和UDP套接字不会共用端口号，所以允许重复。<br><code>bind()</code>函数负责为套接字分配地址信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr* myaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回0，失败时返回-1。</li><li><code>sockfd</code>：要分配地址信息（IP地址和端口号）的套接字文件描述符。</li><li><code>myaddr</code>：存有地址信息的结构体变量地址。</li><li><code>addrlen</code>：存有地址信息的结构体变量的长度。</li></ul><p>下面介绍描述地址信息的结构体。</p><h4 id="表示IPv4地址的结构体"><a href="#表示IPv4地址的结构体" class="headerlink" title="表示IPv4地址的结构体"></a>表示IPv4地址的结构体</h4><p>可以看到<code>bind()</code>函数需要的存有地址信息的结构体类型为<code>sockaddr</code>，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span> sin_family; <span class="hljs-comment">// 地址族（Address Family）</span><br>    <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>]; <span class="hljs-comment">// 地址信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此结构体类型成员<code>sa_data</code>保存的地址信息中需包含IP地址和端口号，剩余部分应填充0，而这对于构造地址信息来说比较麻烦，因而有了表示IPv4地址的结构体类型<code>sockaddr_in</code>，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span> sin_family; <span class="hljs-comment">// 地址族（Address Family）</span><br>    <span class="hljs-keyword">uint16_t</span> sin_port; <span class="hljs-comment">// 16位TCP/UDP端口号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span> <span class="hljs-comment">// 32位IP地址</span><br>    <span class="hljs-keyword">char</span> sin_zero[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 不使用，用于与sockaddr进行地址对齐</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体中提到的另一个结构体<code>in_addr</code>的定义如下，它用来存放32位IP地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">in_addr_t</span> s_addr; <span class="hljs-comment">// 32位IPv4地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>结构体<code>sockaddr_in</code>的成员分析：</p><ul><li><code>sin_family</code>：每种协议族适用的地址族不同，<code>AF_INET</code>表示IPv4协议族，该协议族使用4字节地址族。</li><li><code>sin_port</code>：保存16位端口号，以网络字节序保存（大端序，数据的高位字节放到低位地址）。</li><li><code>sin_addr</code>：保存32位IP地址信息，也以网络字节许保存。</li><li><code>sin_zero</code>：无特殊含义，只用为了使结构体<code>sockaddr_in</code>的大小与<code>sockaddr</code>结构体保持一致而插入的填充成员。</li></ul><h4 id="字符串IP地址转为网络字节序的整数型IP地址"><a href="#字符串IP地址转为网络字节序的整数型IP地址" class="headerlink" title="字符串IP地址转为网络字节序的整数型IP地址"></a>字符串IP地址转为网络字节序的整数型IP地址</h4><p><code>sockaddr_in</code>中所保存的地址信息成员位32位整数，因此，为了分配IP地址，需要将其表示为32位整数型数据。<br>而对于IP地址的表示，我们熟悉的是「点分十进制表示法」（Dotted Decimal Notation），而非整数型数据表示法。幸运的是有两个函数会帮我们把字符串形式的IP地址换成32位整数型数据，并同时完成网络字节序的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 成功时返回32位大端序整数型值，失败时返回INADDR_NONE</span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* string)</span></span>; <br><br><span class="hljs-comment">// 成功时返回1（true），失败时返回0（false）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* string, struct in_addr* addr)</span></span>;<br><br></code></pre></td></tr></table></figure><p><code>inet_addr()</code>函数不仅可以把IP地址转为32位整数型网络字节序，而且可以检测无效的IP地址。<br>而<code>inet_aton()</code>函数与<code>inet_addr()</code>函数在功能上完全相同，也将字符串形式的IP地址转换为32位网络字节序整数型IP地址，只不过该函数使用了<code>in_addr</code>的结构体，且其使用频率更高。</p><h4 id="网络地址初始化并与套接字绑定"><a href="#网络地址初始化并与套接字绑定" class="headerlink" title="网络地址初始化并与套接字绑定"></a>网络地址初始化并与套接字绑定</h4><p>结合前面内容，套接字创建过程中常见的网络地址信息初始化方法，及其与套接字的绑定过程示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">int</span> tcp_socket = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="hljs-comment">// 创建一个TCP套接字</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span> <span class="hljs-comment">// 声明一个网络地址类型</span><br><span class="hljs-keyword">char</span>* server_ip = <span class="hljs-string">&quot;1.2.3.4&quot;</span>; <span class="hljs-comment">// 声明IP地址字符串</span><br><span class="hljs-keyword">char</span>* server_port = <span class="hljs-string">&quot;8080&quot;</span>; <span class="hljs-comment">// 声明端口号字符串</span><br><span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr)); <span class="hljs-comment">// 将结构体变量addr的所有成员初始化位0</span><br>addr.sin_family = AF_INET; <span class="hljs-comment">// 指定地址族</span><br>addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(server_ip); <span class="hljs-comment">// 基于字符串的IP地址初始化</span><br>addr.sin_port = <span class="hljs-built_in">htos</span>(<span class="hljs-built_in">atoi</span>(server_port)); <span class="hljs-comment">// 基于字符串的端口号初始化</span><br><br><span class="hljs-comment">// 将套接字与网络地址信息绑定</span><br><span class="hljs-built_in">bind</span>(tcp_socket, (struct sockaddr*)&amp;addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr));<br></code></pre></td></tr></table></figure><h3 id="0x03-listen-等待连接（监听）"><a href="#0x03-listen-等待连接（监听）" class="headerlink" title="0x03 listen() 等待连接（监听）"></a>0x03 <code>listen()</code> 等待连接（监听）</h3><p>在调用<code>bind()</code>函数为套接字分配了网络地址后，接下来就要通过调用<code>listen()</code>函数进入「等待连接请求」状态。服务器端只有调用了<code>listen()</code>函数，客户端才能进入可发出连接请求的状态。<br>服务器处于「等待连接请求」状态是指在客户端发出「请求连接」之前，服务器一直处于等待状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, <span class="hljs-keyword">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回0，失败时返回-1。</li><li><code>sock</code>：希望进入「等待连接请求」状态的套接字文件描述符，传递的文件描述符所属套接字将称为服务器端套接字（监听套接字）。</li><li><code>backlog</code>：连接请求等待队列的长度，表示最多允许进入等待队列的连接请求数量。</li></ul><h3 id="0x04-accept-受理客户端连接请求"><a href="#0x04-accept-受理客户端连接请求" class="headerlink" title="0x04 accept() 受理客户端连接请求"></a>0x04 <code>accept()</code> 受理客户端连接请求</h3><p>调用<code>listen()</code>函数后，若有新的连接请求，则按序受理。「受理请求」意味着进入「可接受数据」的状态，这种状态下需要创建一个新套接字来专门与客户端进行数据交换，<code>accpet()</code>函数会自动创建套接字并连接到发起请求的客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, struct sockaddr*  addr, <span class="hljs-keyword">socklen_t</span>* addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回创建的套接字文件描述符，失败时返回-1。</li><li><code>sock</code>：服务器套接字（监听套接字）的文件描述符。</li><li><code>addr</code>：保存发起连接请求的客户端地址信息的变量地址值，调用函数后会向该地址变量参数填充客户端的地址信息。</li><li><code>addrlen</code>：第二个参数<code>addr</code>结构体的长度，但是存有长度的变量地址，调用函数后向该变量填充客户端地址长度。<h3 id="0x05-read-write-以及close"><a href="#0x05-read-write-以及close" class="headerlink" title="0x05 read()/write()以及close()"></a>0x05 <code>read()/write()</code>以及<code>close()</code></h3>直接上代码示例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> server_fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> client_fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">char</span> SERVER_IP[] = <span class="hljs-string">&quot;101.76.220.10&quot;</span>;<br>    <span class="hljs-keyword">uint16_t</span> SERVER_PORT = <span class="hljs-number">1234</span>;<br>    <span class="hljs-comment">// 创建服务器端的套接字</span><br>    server_fd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span> <span class="hljs-comment">// 服务器地址信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span> <span class="hljs-comment">// 客户端地址信息</span><br><br>    server_addr.sin_family = AF_INET; <span class="hljs-comment">// 设置协议簇</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">inet_aton</span>(SERVER_IP, &amp;server_addr.sin_addr)) &#123; <span class="hljs-comment">// 设置IP地址</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip error!\n&quot;</span>);<br>    &#125;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT); <span class="hljs-comment">// 设置端口号</span><br>    <br>    <span class="hljs-comment">// 将服务器端套接字保定到指定的地址和端口</span><br>    <span class="hljs-built_in">bind</span>(server_fd, (struct sockaddr*)&amp;server_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(server_addr));<br>    <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">listen</span>(server_fd, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 接受客户端的连接</span><br>    <span class="hljs-keyword">socklen_t</span> client_addr_size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(client_addr);<br>    client_fd = <span class="hljs-built_in">accept</span>(server_fd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_size);<br><br>    <span class="hljs-comment">// 向套接字写数据</span><br>    <span class="hljs-keyword">char</span> buffer[] = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    <span class="hljs-built_in">write</span>(client_fd, buffer, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer));<br><br>    <span class="hljs-comment">// 关闭所有套接字</span><br>    <span class="hljs-built_in">close</span>(client_fd);<br>    <span class="hljs-built_in">close</span>(server_fd);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="0x10-客户端函数用法"><a href="#0x10-客户端函数用法" class="headerlink" title="0x10 客户端函数用法"></a>0x10 客户端函数用法</h2><p>客户端相比服务器端要简单的多，因为创建套接字和请求连接就是客户端的全部内容。<br>创建套接字的过程同服务器端一样，区别在于客户端套接字用于「请求连接」，也即创建客户端套接字后向服务器端发起连接请求。因此这里只介绍发起连接请求的方法。</p><h3 id="0x11-connect-发起连接请求"><a href="#0x11-connect-发起连接请求" class="headerlink" title="0x11 connect()发起连接请求"></a>0x11 <code>connect()</code>发起连接请求</h3><p>服务器端调用<code>listen()</code>函数后创建「连接请求等待队列」，之后客户端即可请求连接，发起请求连接的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, struct sockaddr* servaddr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回0，失败时返回-1 。</li><li><code>sock</code>：客户端套接字文件描述符。</li><li><code>servaddr</code>：保存有目标服务器地址信息的变量地址值。</li><li><code>addrlen</code>：第二个结构体参数<code>servaddr</code>的地址变量长度。</li></ul><p>客户端调用<code>connect()</code>函数后，发生以下情况之一才会返回（完成函数调用）：</p><ul><li>服务器端接受连接请求。</li><li>发生断网等异常情况而中断连接请求。</li></ul><p>需要注意亮点：</p><ul><li>所谓的「接受连接」并不意味着服务器端调用<code>accept()</code>函数，实际情况是服务器端把连接请求信息记录到「等待连接请求队列」。因此<code>connect()</code>函数返回后并不立即进行数据交换。</li><li>客户端套接字创建过程中并没有调用<code>bind()</code>函数进行分配IP地址和端口，客户端套接字的IP地址和端口在调用<code>connect()</code>函数时会自动分配。</li></ul><h3 id="0x12-read-write-以及close"><a href="#0x12-read-write-以及close" class="headerlink" title="0x12 read()/write()以及close()"></a>0x12 <code>read()/write()</code>以及<code>close()</code></h3><p>客户端代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">char</span> SERVER_IP[] = <span class="hljs-string">&quot;101.76.220.10&quot;</span>; <span class="hljs-comment">// 服务器IP地址信息</span><br>    <span class="hljs-keyword">uint16_t</span> SERVER_PORT = <span class="hljs-number">1234</span>; <span class="hljs-comment">// 服务器监听端口</span><br><br>    <span class="hljs-comment">// 创建客户端套接字</span><br>    fd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;fail create socket!&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span> <span class="hljs-comment">// 创建服务器端地址信息变量</span><br>    server_addr.sin_family = AF_INET; <span class="hljs-comment">// 设置协议簇</span><br>    <span class="hljs-comment">// server_addr.sin_addr.s_addr = inet_addr(SERVER_IP); // 设置IP地址</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">inet_aton</span>(SERVER_IP, &amp;server_addr.sin_addr)) &#123; <span class="hljs-comment">// 设置IP地址</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;ip error!&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(SERVER_PORT); <span class="hljs-comment">// 设置端口号（并转为网络字节序</span><br><br>    <span class="hljs-comment">// 客户端套接字连接到服务器端的套接字</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(fd, (struct sockaddr*)&amp;server_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sockaddr)) == <span class="hljs-number">-1</span>) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;connect error&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从套接字中读取数据</span><br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">2024</span>];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>        std::cout&lt;&lt;buffer&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;read error!&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">// 关闭套接字</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于UDP的服务器端-客户端"><a href="#基于UDP的服务器端-客户端" class="headerlink" title="基于UDP的服务器端/客户端"></a>基于UDP的服务器端/客户端</h1><p>为了提供可靠的数据传输，TCP在不可靠的IP层进行流控制，而UDP就缺少这种流控制。UDP的主要作用就是根据端口号姜传到主机的数据包交付给最终的UDP套接字。<br>没有流控制的UDP相比TCP通常更快，主要原因有以下两点：</p><ul><li>收发数据前后进行的连接设置及清除过程。</li><li>收发数据过程中为保证可靠性而添加的流控制。  </li></ul><p>因此，当收发的数据量小但需要频繁连接时，UDP比TCP更高效。<br>UDP服务器端/客户端不像TCP那样在连接状态下交换数据，也即不需要调用TCP连接过程中调用的<code>listen()</code>和<code>connect()</code>函数，UDP中只有创建套接字的过程和数据交换过程。也因此，UDP套接字不会保持连接状态，每次传输数据时都要添加目标信息。</p><h2 id="0x00-基于UDP的数据I-O函数"><a href="#0x00-基于UDP的数据I-O函数" class="headerlink" title="0x00 基于UDP的数据I/O函数"></a>0x00 基于UDP的数据I/O函数</h2><p>下面介绍填写数据接收地址并输出数据时调用的UDP函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, <span class="hljs-keyword">void</span>* buff, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">int</span> flags, </span></span><br><span class="hljs-params"><span class="hljs-function">               struct sockaddr* to, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回传输的字节数，失败时返回-1 。</li><li><code>sock</code>：用于传输数据的UDP套接字文件描述符。</li><li><code>buff</code>：保存待传输数据的缓冲地址值。</li><li><code>nbytes</code>：待传输数据的长度，以字节为单位。</li><li><code>flags</code>：可选项参数，若没有则传递0。</li><li><code>to</code>：存有目标地址信息的<code>sockaddr</code>结构体变量的地址值。</li><li><code>addrlen</code>：参数to的地址值结构体变量长度。</li></ul><p>上述函数与之前的TCP输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收UDP数据的函数。<br>UDP数据的发送端并不固定，因此该函数定义为可接收「发送端信息」的形式，也即可以同时返回UDP数据包中的「发送端信息」。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock, <span class="hljs-keyword">void</span> *buff, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                 struct sockaddr* from, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回接收的字节数，失败时返回-1 。</li><li>buff：保存接收数据的缓冲地址值。</li><li>nbytes：可接受的最大字节数，故不能超过参数buff所指定的缓冲区大小。</li><li>flags：可选项参数，若没有则传入0 。</li><li>from：用于保存接收到的发送端地址信息的sockaddr结构体变量的地址值。</li><li>addrlen：用于保存参数from的结构体变量长度的变量地址值。</li></ul><h2 id="0x10-基于UDP的「回声」服务器端-客户端"><a href="#0x10-基于UDP的「回声」服务器端-客户端" class="headerlink" title="0x10 基于UDP的「回声」服务器端/客户端"></a>0x10 基于UDP的「回声」服务器端/客户端</h2><p>UDP不同于TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端。这里只是把提供服务的一端称为服务器端，把请求服务的一端称为客户端。</p><h2 id="0x11-UDP服务器端"><a href="#0x11-UDP服务器端" class="headerlink" title="0x11 UDP服务器端"></a>0x11 UDP服务器端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> serv_sock;<br>    <span class="hljs-keyword">char</span> message[BUF_SIZE];<br><br>    <span class="hljs-keyword">int</span> str_len;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_adr</span>, <span class="hljs-title">clnt_adr</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> clnt_adr_sz;<br><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    serv_sock = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(serv_sock == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;UDP socket creation error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;serv_adr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_adr));<br>    serv_adr.sin_family = AF_INET;<br>    serv_adr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    serv_adr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(serv_sock, (struct sockaddr*)&amp;serv_adr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_adr)) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        clnt_adr_sz = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(clnt_adr);<br>        str_len = <span class="hljs-built_in">recvfrom</span>(serv_sock, message, BUF_SIZE, <span class="hljs-number">0</span>, (struct sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);<br>        <span class="hljs-built_in">sendto</span>(serv_sock, message, str_len, <span class="hljs-number">0</span>, (struct sockaddr*)&amp;clnt_adr, clnt_adr_sz);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(serv_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, stderr);<br>    <span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, stderr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面介绍于上述服务器端协同工作的客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sock;<br>    <span class="hljs-keyword">char</span> message[BUF_SIZE];<br><br>    <span class="hljs-keyword">int</span> str_len;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>, <span class="hljs-title">from_addr</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> adr_sz;<br><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;IP&gt; : &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    sock = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sock == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;socket() error!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Please input message(Q to quit) : &quot;</span>, stdout);<br>        <span class="hljs-built_in">fgets</span>(message, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(message), stdin);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;q\n&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;Q\n&quot;</span>)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">sendto</span>(sock, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>, (struct sockaddr*)&amp;serv_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br>        adr_sz = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(from_addr);<br>        str_len = <span class="hljs-built_in">recvfrom</span>(sock, message, BUF_SIZE, <span class="hljs-number">0</span>, (struct sockaddr*)&amp;from_addr, &amp;adr_sz);<br>        message[str_len] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message from server : %s&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, stderr);<br>    <span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, stderr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>UDP程序中，调用<code>sendto()</code>函数传输数据前应完成对套接字的地址分配工作，因此需要调用<code>bind()</code>函数，该函数不区分TCP和UDP，也即在UDP和TCP程序中均可调用。<br>另外，如果调用<code>sendto()</code>函数时发现尚未分配地址信息，则在首次调用<code>sendto()</code>时给相应的套接字自动分配IP地址和端口。因此，UDP客户端中通常无需额外的地址分配过程。</p><h2 id="0x20-存在数据边界的UDP套接字"><a href="#0x20-存在数据边界的UDP套接字" class="headerlink" title="0x20 存在数据边界的UDP套接字"></a>0x20 存在数据边界的UDP套接字</h2><p>TCP数据传输过程中不存在数据边界，这表示「数据传输过程中调用I/O函数的次数不具有任何意义」。<br>而UDP是具有数据边界的协议，数据传输过程中调用I/O函数的次数非常重要。因此，输入函数的调用次数应该和输出函数的调用次数完全一致，这样才能保证接收端能够接收到所有已发送数据。</p><p> UDP套接字传输的数据包又称为「数据报」，实际上数据报也属于数据包的一种。UDP中存在数据边界，一个数据包即可成为一个完整数据，因此称为数据报。</p><h2 id="0x30-已连接UDP套接字和未连接UDP套接字"><a href="#0x30-已连接UDP套接字和未连接UDP套接字" class="headerlink" title="0x30 已连接UDP套接字和未连接UDP套接字"></a>0x30 已连接UDP套接字和未连接UDP套接字</h2><p> TCP套接字中需要调用<code>connect()</code>函数注册待传输数据的目标IP和端口号，而UDP中则无需注册。因此，通过<code>sendto()</code>函数传输数据的过程大致可以分为以下3个阶段：</p><ul><li>第一阶段：向UDP套接字注册目标IP和端口号。</li><li>第二阶段：传输数据。</li><li>第三阶段：删除UDP套接字中注册的目标地址信息。</li></ul><p>每次调用<code>sendto()</code>函数时都会重复上述过程，每次都变更目标地址，因此可以重复利用同一个UDP套接字向不同的目标地址传输数据。<br>这种未注册目标地址信息的套接字被称为未连接套接字，反之，注册了目标地址的套接字称为连接（connected）套接字。显然，UDP套接字默认属于未连接套接字。<br>在上述三个阶段中，第一个和第三个阶段占用整个通信过程将近1/3的时间，缩短这部分时间则将大大提高整体性能。因此，若要与同一主机进行长时间通信，将UDP套接字变成已连接套接字将会大大提高效率。</p><h3 id="0x31-创建已连接套接字"><a href="#0x31-创建已连接套接字" class="headerlink" title="0x31 创建已连接套接字"></a>0x31 创建已连接套接字</h3><p>要创建已连接UDP套接字只需要对UDP套接字调用<code>connect()</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">sock = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br>serv_addr.sin_family = AF_INET;<br>serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br>serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br><span class="hljs-built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br><br></code></pre></td></tr></table></figure><p>针对UDP套接字调用<code>connect()</code>函数并不意味着要与对方UDP套接字连接，这只是向UDP套接字注册目标IP和端口信息。<br>注册之后就与TCP套接字一样，每次调用<code>sendto()</code>函数时只需传输数据。因为已经指定了收发对象，所以不仅可以使用<code>sendto()</code>、<code>recvfrom()</code>函数，还可以使用<code>write()</code>、<code>read()</code>函数进行通信。<br>可以对上文提到的UDP客户端程序进行修改，改为已连接UDP套接字，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 30</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sock;<br>    <span class="hljs-keyword">char</span> message[BUF_SIZE];<br><br>    <span class="hljs-keyword">int</span> str_len;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>, <span class="hljs-title">from_addr</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> adr_sz;<br><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;IP&gt; : &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    sock = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sock == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">error_handling</span>(<span class="hljs-string">&quot;socket() error!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br><br>    <span class="hljs-comment">// 向UDP套接字注册目标IP和端口信息</span><br>    <span class="hljs-built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serv_addr));<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Please input message(Q to quit) : &quot;</span>, stdout);<br>        <span class="hljs-built_in">fgets</span>(message, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(message), stdin);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;q\n&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(message, <span class="hljs-string">&quot;Q\n&quot;</span>)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// sendto(sock, message, strlen(message), 0, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));</span><br>        <span class="hljs-comment">// 注册目标IP和端口信息后可以使用write()和read()函数传输数据</span><br>        <span class="hljs-built_in">write</span>(sock, message, <span class="hljs-built_in">strlen</span>(message)); <br><br>        adr_sz = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(from_addr);<br>        <span class="hljs-comment">// str_len = recvfrom(sock, message, BUF_SIZE, 0, (struct sockaddr*)&amp;from_addr, &amp;adr_sz);</span><br>        <span class="hljs-built_in">read</span>(sock, message, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(message) - <span class="hljs-number">1</span>);<br>        message[str_len] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message from server : %s&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_handling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, stderr);<br>    <span class="hljs-built_in">fputc</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, stderr);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「TriangleKV」论文阅读。</title>
    <link href="/2022/07/27/%E8%AF%BB%E8%AE%BA%E6%96%87/TriangleKV/"/>
    <url>/2022/07/27/%E8%AF%BB%E8%AE%BA%E6%96%87/TriangleKV/</url>
    
    <content type="html"><![CDATA[<h1 id="TriangleKV"><a href="#TriangleKV" class="headerlink" title="TriangleKV"></a>TriangleKV</h1><ul><li>论文名称：TriangleKV_Reducing_Write_Stalls_and_Write_Amplification_in_LSM-tree_Based_KV_Stores_with_Triangle_Container_in_NVM</li><li>期刊：TPDS</li><li>时间：2022</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h2><p>为了更好的理解基于LSM的KV存储，论文对传统使用DRAM-SSD的RocksDB进行了实验评估，发现了两个具有挑战性的问题，及其根本原因：</p><ul><li><strong>写停滞（write stalls）</strong>会导致应用程序的吞吐量周期性的骤降到接近为0，从而会导致性能的剧烈波动和长尾延迟。论文的研究表明，导致<strong>写停滞</strong>的主要原因是L0-L1之间Compaction的数据量过大，发生L0-L1之间的Compaction时，几乎涉及到这两个Level的所有数据（L0的数据是无序的，SSTable之间有Key Range的重叠）。</li><li><strong>写放大（write amplification，WA）</strong>会降低系统的性能和存储设备的耐用性。写放大与LSM-Tree的深度直接相关，更大的数据集会产生更深的LSM-Tree，从而增加Compaction的数量。</li></ul><p>已有的大量研究都局限于解决上述的单个问题，而本篇论文的研究旨在同时解决这两个挑战。</p><p>针对这两个挑战和其根本原因，本篇论文提出了TriangleKV，一个使用DRAM-NVM-SSD混合存储设备的LSM-Tree KV存储。</p><p>TriangleKV的设计原则包括：</p><ul><li>利用NVM来为L0和L1提供代价更低，更细粒度的Compaction操作；</li><li>减少LSM-Tree的深度以减少写放大；</li></ul><h2 id="Background-and-Motivation"><a href="#Background-and-Motivation" class="headerlink" title="Background and Motivation"></a><strong>Background and Motivation</strong></h2><p>NVM是一种按字节寻址，持久化的快速存储设备。它有望以更低的成本提供类似DRAM的性能、磁盘的持久性和比DRAM更高的容量。和SSD相比，NVM有望提供100倍的低读写延迟和10倍的高带宽。</p><p>NVM既可以作为通过PCIe接口访问的持久化块存储设备，也可以作为通过内存总线访问的主存。现有的研究表明，第一种使用方式只能实现边缘性能的提高，浪费了NVM的高介质性能；对于第二种方式来说，NVM可以替代或者作为DRAM的补充，比如作为一个单级内存系统、一个NVM-SSD混合系统或一个DRAM-NVM-SSD混合系统。</p><p>基于以下原因，具有DRAM-NVM-SSD的混合存储系统被认为是利用NVM的最高效方式：</p><ul><li>NVM在未来几年有望与大容量SSD共存；</li><li>与DRAM相比，NVM仍然有低5倍的带宽和高3倍的读延迟；</li><li>混合系统平衡了TCP（Total Cost of Ownership）和系统性能；</li></ul><p>因此，TriangleKV旨在具有DRAM、NVM和SSD的混合存储系统中更有效的使用NVM作为持久存储。</p><h3 id="写停滞（Write-Stalls）"><a href="#写停滞（Write-Stalls）" class="headerlink" title="写停滞（Write Stalls）"></a>写停滞（Write Stalls）</h3><p>在基于LSM的KV存储中，存在三种类型的「停滞」：</p><ul><li>插入停滞（Insert Stalls）：如果<code>MemTable</code>在后台完成刷新操作之前写满了，所有的插入操作都会停滞；</li><li>刷新停滞（Flush Stalls）：如果L0中的SSTable数量达到上限，后台刷新操作就会被阻塞；</li><li>压缩停滞（Compaction Stalls）：挂起的Compaction操作太多会阻塞前台操作；</li></ul><p>这三种停滞都会对写性能造成影响，并导致写停滞。</p><h3 id="NoveLSM"><a href="#NoveLSM" class="headerlink" title="NoveLSM"></a><strong>NoveLSM</strong></h3><p>如图1(a)所示，NoveLSM利用NVM为具有DRAM-NVM-SSD的系统提供高吞吐量。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/1.png" alt="Untitled"></p><p>NoveLSM的设计选择包括：</p><ul><li>采用NVMs作为DRAM的备选来增加<code>MemTable</code>和 <code>immutable MemTable</code>的大小；</li><li>使NVM中的<code>MemTable</code>可变，允许直接更新，从而减少<code>Compaction</code>的次数；</li></ul><p>但是这些设计选择仅仅只是推迟了「写停滞」。当数据集的大小超过NVM MemTable的容量时，「刷新停滞」还是会发生，并阻塞前台的请求。</p><p>此外，当NVM中扩大的<code>MemTable</code>刷新到L0，会显著增加L0-L1的Compaction中的数据量，这会导致更长的Compaction延迟和更严重的写停滞（如图4所示）。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F2.png" alt="Untitled"></p><p>通过以上分析可以得出，L0-L1之间的Compaction中涉及的大量数据是导致「写停滞」的主要原因，而「写放大」增加的主要原因是LSM-Tree深度的加深。「写停滞」和「写放大」的综合影响会降低系统吞吐量，并延长尾延迟。</p><h3 id="MatrixKV"><a href="#MatrixKV" class="headerlink" title="MatrixKV"></a>MatrixKV</h3><p>如图5所示，MatrixKV仍然使用DRAM来管理<code>MemTable</code>和<code>ImmMemTable</code>，但是使用NVM来管理WAL。没有将<code>MemTable</code>和<code>ImmMemTable</code>放在NVM是因为：</p><ul><li>与DRAM相比，NVM仍然有5倍高的低带宽和3倍高的读延迟，使用NVM可能会降低读写性能；</li><li>往MemTable中插入数据需要查询「跳表」，并且会涉及到多个指针的修改，这些操作对于NVM来说开销也是昂贵的；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F3.png" alt="Untitled"></p><p>此外，MatrixKV还将L0移动到NVM中，将L0放在NVM中有以下优势：</p><ul><li>与SSD相比，NVM有更高的带宽和更低的延迟，因此在将ImmMemTable刷新到L0中时会更快，这会减少「插入停滞」；此外，这还隔离了L0-L1的Compaction操作和刷新操作之间的交互，此时两者之间没有带宽的竞争，从而能减少写停滞；</li><li>NVM是字节寻址的，这意味着L0-L1的Compaction可以在非常细的粒度上完成，并且<strong>在每次细粒度Compaction之后可以立即释放空间，而将L0放在SSD上不能实现这一点，因为SSD上的SSTable在整个文件压缩之前不能被删除</strong>；</li></ul><p>MatrixKV使用「矩阵容器」来管理L0，其中包括一个「接收器（Receiver）」和一个「压缩器（Compactor）」。不可变的MemTable首先被「刷新」到「接收器」，当「接收器」达到其大小限制时，它被转换为「压缩器」，并生成一个新的「接收器」来接受「刷新」操作。</p><p>通过一个「细粒度列压缩（Column Compaction）」，「压缩器」中的数据被Compacted到SSD上的L1中。每次只Compact特定键范围内的一小部分数据，这大大减少了「写停滞」。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F4.png" alt="Untitled"></p><p>但是列压缩只能对「压缩器」使用，「接收器」中与「压缩器」重叠的键范围并不能参与「列压缩」过程。</p><p>如图6所示，「压缩器」中的<code>a-c</code>键范围首先通过「列压缩」被Compact到L1，而「接收器」中与其重叠的键范围仍然在L0中。当「接收器」转变为「压缩器」后，这些键范围需要被再次执行Compact操作，这意味着在L1中写入了两次键范围为<code>a-c</code>的数据，带来了额外的「写放大」。</p><h2 id="TriangleKV-Design"><a href="#TriangleKV-Design" class="headerlink" title="TriangleKV Design"></a>TriangleKV Design</h2><p>TriangleKV 在MatrixKV的基础上进行了改进，将后者的Matrix数据结构替换为Triangle数据结构，来对L0进行更有效的管理。</p><p>图7展示了TriangleKV的架构，从上到下依次为：</p><ul><li>DRAM，用于批量写<code>MemTable</code>；</li><li><code>MemTable</code>刷新到L0，并由NVM中的「三角形容器」（Triangle Container）来存储和管理；</li><li>L0中的数据通过「直角边压缩」（right-angle side compaction）压缩到SSD中的L1层；</li><li>SSD中存储一个扁平化的LSM-Tree的剩余Level；</li></ul><h3 id="TriangleKV-Container"><a href="#TriangleKV-Container" class="headerlink" title="TriangleKV Container"></a>TriangleKV Container</h3><p>L0-L1的Compaction所带来的大量I/O被认为是导致「写停滞」的根本原因。因此，基于LSM-Tree的KV存储，最小化或者消除「写停滞」的设计原则就是<strong>降低L0和L1的Compaction粒度</strong>以及<strong>减少SSD上的I/O次数。</strong></p><p>基于以上设计原则，TriangleKV将L0从SSD移动到NVM，并将L0组织为一个「三角形容器」，以利用NVM的可字节寻址和高速随机访问能力。所谓的「三角形容器」是L0的一种数据管理结构（图8展示了其组织结构）。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F5.png" alt="Untitled"></p><p><strong>三角形数据结构</strong>：</p><p>在三角形容器中，从DRAM刷新下来的ImmMemTable按「row」堆在NVM中。每一个这样的MemTable根据其键范围被重组为一个RowTable。RowTable作为三角形的底边不断堆叠增加，也即从0到n。三角形数据结构的大小从一个RowTable开始，当三角形数据结构达到其大小上限时（例如NVM容量的60%），会触发一个L0-L1的「子范围合并」操作。</p><p>参与「子范围合并」合并操作的是三角形数据结构的「垂直直角边的数据」，也即最长时间未被合并的子键值范围数据。</p><p>L0-L1的子范围合并操作与DRAM的刷新操作是同步执行的，因此NVM中的数据结构保持在三角平衡状态。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F6.png" alt="Untitled"></p><p>图9展示了在刷新和L0-L1子范围合并过程中三角形数据结构的动态变化示例。</p><p>在图9(a)中共有9个RowTable，序号从0到5。假设总键值空间为<code>a-f</code>，则参与合并的子键值范围为<code>a</code>。完成子范围<code>a</code>的L0-L1合并后，所有属于此范围的数据都被写到SSD中，此时NVM中的每个RowTable都不再包含属于键值范围<code>a</code>的数据。</p><p>如图9(b)所示，当DRAM刷新另一个<code>ImmMemTable</code>时，一个RowTable 6被添加到NVM的三角形数据结构中，RowTable 6的键值范围为<code>a-f</code>，此时只有RowTable 6包含键值范围<code>a</code>。L0-L1子范围合并被旋转到键值范围<code>b</code>，这样每个RowTable中属于键值范围<code>b</code>的数据都会被合并到L1层。</p><p>如图9所示，在L0-L1的不断子范围合并过程中，RowTable从DRAM刷新到NVM，并不断地向三角形数据结构的底部增加新的RowTable。始终选择最长时间未参与子范围合并的子键范围进行合并，并将新添加的RowTable相关子范围旋转到后面，如图9(a)所示，将未参与子范围<code>a</code>合并的RowTable 5的范围<code>a</code>旋转到了尾部。这会构成一个「动态三角形」，也即「三角形数据结构」的名称来源。</p><p><strong>RowTable：</strong></p><p>图10(a)展示了RowTable的结构组成：数据区域和元数据区域。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F7.png" alt="Untitled"></p><p>为了构造一个RowTable，首先将ImmMemTable中的KV项按照键顺序序列化，并将其存储在数据区域。然后用一个排序数组构建所有KV项的元数据。每个数组元素维护「键」、「页编号」、「页内偏移量」和一个「前向指针」。</p><p>为了定位RowTable中的一个KV项，对有序元数据数组执行二分查找，以获取Key，并通过页编号和页偏移量获取Key对应的Value。每个数组元素中的前向指针用于「跨行提示搜索」，这有助于提高三角形容器内的读取效率。</p><p>图10(b)展示了一个传统LSM-Tree SSTable的结构。SSTable是使用SSD和HDD的存储单元以「块」为基本单元进行组织的。而RowTable使用NVM中的「页」作为它的基本单元。</p><p><strong>L0-L1 sub-range merge：</strong></p><p>「三角形容器」的一个主要作用就是从L0中选择数据并合并到NVM上的L1中去。利用NVM的可字节寻址能力，以及前面所提出的RowTable，TriangleKV允许L0中的指定子键范围与L1中SSTable的子集进行合并，实现了更低代价的Compaction操作，而不需要合并整个的L0和L1。</p><p>这种新的L0-L1合并方式被称为「直角边压缩」。</p><p>在「三角形容器」中，KV项采用逻辑三角形数据结构进行管理。三角形数据结构的「直角边」是具有有限数据量的键空间的子集，它是三角形容器中「直角边压缩」的基本单元。</p><p>具体来说，来自不同RowTable的属于「直角边压缩」键范围的的KV项在逻辑上构成直角边。这些KV项的数量是直角边的大小，这个大小不是严格固定的，而是受「直角边压缩」大小的阈值所决定的。</p><p><strong>Space management：</strong></p><p>完成「直角边压缩」后，「直角边」所占用的NVM空间会被释放。为了管理这些空闲空间，TriangleKV应用了「分页算法」。</p><p>「直角边压缩」后释放的空闲页作为一组页单元加入到一个「空闲列表」中。然后将使用「空闲列表」中的空闲页来存储从DRAM刷新得到RowTable。</p><p>8GB大小的「三角形容器」包含$2^{11}$个4KB大小的页。每个页由一个<code>unsigned integer</code>作为页编号来标识。为每个列表元素添加一个8字节的指针，因此列表中每个页的元数据大小为12字节。</p><p>空间管理的元数据包含一个「空闲列表」以及一个将RowTable 编号映射到对应元数据页的「数组列表」，在NVM中总共只占用24KB的空间。</p><h3 id="Right-angle-Side-Compaction"><a href="#Right-angle-Side-Compaction" class="headerlink" title="Right-angle Side Compaction"></a>Right-angle Side Compaction</h3><p>「直角边压缩」是一种细粒度的L0-L1压缩，每次只压缩直角边，也即特定键范围内数据的一个子集。因此「直角边压缩」能显著减少「写停滞」。</p><p>「直角边压缩」的主要工作过程可以描述为以下七步：</p><ol><li>TriangleKV将L1的键空间划分为多个连续的键范围。由于L1中的SSTable是有序的，且每个SSTable都有一个最大和最小Key，L1中所有SSTable的最大和最小Key组成一个有序的Key列表。每两个相邻的Key组成一个键范围，由此得到L1中的多个连续键范围。</li><li>「直角边压缩」从L1的第一个键范围开始。它选择L1中的一个键范围作为压缩键范围。</li><li>在三角形容器中，压缩键范围内的KV项从多个RowTable中<strong>并发选取</strong>；</li><li>如果当前「直角边压缩」的键范围内的数据量小于压缩的下限，则将L1中的下一个键范围也加入压缩过程，这个键范围扩展过程持续到参与压缩的键范围内的数据量处于压缩下限和压缩上限之间。这个边界保证了压缩过程的适当开销。</li><li>在压缩键范围内的N个RowTable中的KV项组成一条逻辑直角边。</li><li>直角边中的数据和L1中SSTable重叠数据在内存中进行合并排序；</li><li>合并排序后生成的SSTable被写回SSD中的L1。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F8.png" alt="Untitled"></p><p>图10展示了一个「直角边压缩」的例子。</p><ul><li>首先，TriangleKV从L1中选择具有键范围<code>0-3</code>的SSTable作为参与压缩过程的候选SSTable；</li><li>然后，查询「三角形容器」中4个RowTable的元数据数组，如果键范围<code>0-3</code>内的数据量小于压缩下限，则下一个邻接键范围也加入压缩，构成一个更大的键范围<code>0-5</code>，如果此键范围内的数据还小于压缩下限则键范围<code>5-8</code>内的数据也加入压缩，键范围扩大到<code>0-8</code>。</li><li>最后，一旦键范围内的数据查过压缩下限，便构成了压缩过程的一个逻辑直角边。键范围<code>0-8</code>所组成的逻辑直角边与SSD上L1中的前两个SSTable进行合并。</li></ul><h3 id="Reducing-LSM-tree-Depth"><a href="#Reducing-LSM-tree-Depth" class="headerlink" title="Reducing LSM-tree Depth"></a>Reducing LSM-tree Depth</h3><p>LSM-Tree中Level的数量随着数据库中数据量的增加而增加。而将SSTable压缩到更高的Level会带来AF（Amplification Factor）级别的的写放大，因此总体WA会随着LSM-Tree深度的增加而增加。</p><p>因此TriangleKV的另一个设计原则是减小LSM-Tree的深度来缓解写放大。TriangleKV增加每一Level的大小限制，使相邻的AF保持不变，从而减少了LSM-Tree的深度。</p><p>因此，对于L1及以上级别的Compaction操作，SSTable到下一Level的压缩WA保持不变，但由于Level的减少，整体的写放大会减少。</p><p>使传统的LSM-Tree扁平化会带来两个负面影响：</p><ul><li>首先，放大L0后会有更多的SSTable与L0有范围重叠，这增加了参与L0-L1压缩的数据量，这不仅增加了压缩开销，而且延长了「写停滞」的持续时间。</li><li>其次，当遍历一个更大的未排序的L0时，搜索效率会降低；</li></ul><p>TriangleKV不存在第一个问题，因为「直角边压缩」使L0-L1压缩始终处于细粒度。「直角边」所涉及的数据量在很大程度上与水平宽度无关，因为直角边所包含的数据量是有限的。唯一的缺点是，搜索较大的L0的效率比较低，这可能会降低读取效率。</p><h3 id="Cross-row-Hint-Search"><a href="#Cross-row-Hint-Search" class="headerlink" title="Cross-row Hint Search"></a>Cross-row Hint Search</h3><p>为了提高「三角形容器」内的读效率，TriangleKV构建了一个「跨行提示搜索」。</p><p><strong>Constructing cross-row hints：</strong></p><p>当在「三角形容器」中构建一个RowTable时，为有序元数据数组中的每个元素添加一个前向指针（如图10）。具体来说，对于RowTable <code>i</code>中的键<code>x</code>，其前向指针指向前面RowTable <code>i-1</code>中的键<code>y</code>，键<code>y</code> 是第一个不小于<code>x</code>的键，也即<code>y≥x</code> 。</p><p>这些前向指针提供了对于不同行的所有键进行逻辑排序的提示。由于每个前向指针只记录前一个RowTable的数组索引，所以前向指针的大小只有4字节，因此存储开销非常小。</p><p><strong>Search process in the triangle container：</strong></p><p>查询过程从最后到达的RowTable <code>i</code>开始。如果该RowTable的键范围并没有覆盖目标键，则跳到它的前一个RowTable，也即RowTable <code>i-1</code>；如果覆盖了目标键，则在RowTable <code>i</code>中执行二分查找，以找到目标键所在的键范围。</p><p>使用前向指针可以缩小前面RowTable中的搜索区域。因此，不需要完全遍历所有表来获得一个键或扫描一个键范围。跨行提示搜索通过显著减少搜索过程中涉及的表和元素的数量，提高了L0的读取效率。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/TriangleKV/F9.png" alt="Untitled"></p><p>图12展示了一个跨行提示搜索的例子。其中蓝色箭头表示前向指针所提供的跨行提示。</p><p>假设我们想在三角形容器中查找一个目标键<code>k=12</code> 。</p><ul><li>首先对RowTable <code>1</code>执行二分查找，得到一个缩小的从<code>key=10</code>到<code>key=23</code>的键范围。</li><li>通过它们的前向指针提示，查找到RowTable <code>3</code>中的键<code>13</code>和键<code>36</code>。当目标键不在两个提示键的键范围内时，将上述键添加到搜索区域。</li><li>接下来，在<code>key=8</code>和<code>key=36</code>之间执行二分查找，如果找不到目标键，就根据前向指针的提示查找RowTable <code>2</code>，然后是查找RowTable <code>1</code>，最后在RowTable <code>1</code>中查找到键<code>12</code> 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-07-25记</title>
    <link href="/2022/07/25/%E4%BA%BA%E7%94%9F%E4%B8%80%E4%BA%8B/2022-07-25/"/>
    <url>/2022/07/25/%E4%BA%BA%E7%94%9F%E4%B8%80%E4%BA%8B/2022-07-25/</url>
    
    <content type="html"><![CDATA[<p>我听人说，这世界第一快乐的是只顾自己的人，第二快乐的是不会回头的人。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人生一事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamo论文阅读</title>
    <link href="/2022/07/10/%E8%AF%BB%E8%AE%BA%E6%96%87/Dynamo/"/>
    <url>/2022/07/10/%E8%AF%BB%E8%AE%BA%E6%96%87/Dynamo/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Amazon的很多服务仅需要通过一个「主键」来访问数据库，因此Dynamo只提供了一个简单的「主键」接口来满足这些服务的需求。</p><p>Dynamo综合使用了一些已有的技术来实现可扩展性和可用性：</p><ul><li>数据通过「一致性哈希」进行分区和复制；</li><li>通过将「对象」进行版本化来促进一致性；</li><li>在更新过程中，通过一种类似Quorum的技术和一个分布式副本同步协议来维护副本之间的一致性；</li><li>Dynamo使用了一种基于Gossip的分布式故障检测和成员协议；</li></ul><p>Dynamo是一个完全分布式的系统，极少需要人工干预。在Dynamo中添加和删除节点时不需要手动分区和再分配。</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>传统的生产系统通常将它们的数据存储在关系数据库中。然而，对于许多更常见的数据持久性使用模式来说，关系数据库并不是一个理想的解决方案。这些服务中的大多数只通过「主键」存储和检索数据，不需要RDBMS提供的复杂查询和管理功能。这些多余的功能往往需要昂贵的硬件和熟练的操作人员，这使其成为一种非常低效的解决方案。</p><p>商业系统中使用的数据复制算法通常采用「同步协调复制」，以提供强一致性的数据访问接口。为了实现这个级别的一致性，这些算法必须对一些故障场景下的可用性进行权衡。</p><p>从很早的数据库复制工作中可以知道，在可能出现网络故障时，无法同时实现「强一致性」和「高可用性」。</p><p>Dynamo被设计为提供最终一致性的数据库，也就是说所有的更新最终都会到达所有的副本节点。</p><p>一个重要的设计考虑因素时什么时候去解决「更新冲突」，例如：冲突可以在读或写操作时执行更新。很多传统的数据库在执行写入操作时解决冲突，尽量降低读操作的复杂性。在这种情况下，如果写请求的数据无法在规定的时间内到达所有副本节点，则写请求可能会被拒绝。另一方面，Dynamo的设计目标是实现一个总是可写的数据库（「always writeable」），也就是说数据库对于写操作来说是高可用的。</p><p>另一个设计选择是由谁来执行「冲突解决」，数据库和用户应用程序都可以用来执行「冲突解决」。如果冲突解决是由数据库来完成，那么它能选择的处理方式就非常受限，在这种情况下，数据库只能使用简单的策略来解决更新冲突（例如「最后写者获胜」，也即「last write wins」）。另一方面，由于用户应用程序了解数据模式，它可以决定最适合客户体验的冲突解决方案。</p><p>Dynamo的一些其他<strong>设计原则</strong>包括：</p><ul><li><strong>增量可伸缩性</strong>：Dynamo必须支持扩展存储节点，并且对系统操作人员和系统本身的影响最小。</li><li><strong>对称性</strong>：Dynamo中的每个节点具有完全相同的职责，不应该有一个或多个承担特殊角色或额外职责的节点，这种对称性设计能简化系统配置和维护的过程。</li><li><strong>去中心化</strong>：去中心化是对称性设计的延伸，设计应该更倾向于去中心化的「点对点技术」，而不是「集中控制」（经验表明，集中控制会容易导致服务中断）。</li><li><strong>异构性</strong>：系统需要能够利用其基础设施中的异构性（节点之间的异构性），例如：工作分配必须与单个服务器的能力成正比。</li></ul><p>Dynamo的<strong>目标需求</strong>包括：</p><ul><li>首先，Dynamo的目标用户是那些需要「总是可写」的数据库的用户应用程序，更新操作并不会因为故障或并发写入而被拒绝；</li><li>其次，Dynamo是为单个管理域中的基础设施构建的，这<strong>假定所有节点都是可信的</strong>；</li><li>第三，使用Dynamo的用户应用不要求支持层次命名空间或复杂的关系模式；</li><li>第四，Dynamo是为需要至少99.9%的读写操作在几百毫秒内执行的对延迟非常敏感的应用程序所构建的。为了满足这些严格的延迟要求，必须<strong>避免通过多个节点路由读写请求</strong>（Dynamo可以被描述为0跳DHT，也即「Zero-Hop Distributed Hash Table」，其中每个节点在本地维护足够多的路由信息，以便将请求直接路由到适当的节点）；</li></ul><h2 id="System-Architectures"><a href="#System-Architectures" class="headerlink" title="System Architectures"></a>System Architectures</h2><p>Dynamo使用到的主要技术，以及它们的优势：</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/dynamo-1.png"></p><h3 id="System-interface"><a href="#System-interface" class="headerlink" title="System interface"></a>System interface</h3><p>Dynamo公开了两个简单的接口来执行数据的存取：<code>put()</code>和<code>get()</code> 。</p><ul><li><code>get(key)</code> 操作在数据库中查找与该key相关的对象副本，<strong>返回单个对象或者存在冲突的对象列表</strong>（这是因为Dynamo将冲突处理交给了用户应用程序，所以需要将所有的冲突对象都返回给用户）；</li><li><code>put(key, context, object)</code> 操作根据对应的key决定对象副本放置位置，并将副本写入磁盘。</li></ul><p>Dynamo将调用方提供的键和对象都视为不透明的字节数组，使用MD5算法对Key进行加密操作，得到一个128位的标识，然后根据此标识来选择节点进行存储。</p><h3 id="Partitioning-Algorithm"><a href="#Partitioning-Algorithm" class="headerlink" title="Partitioning Algorithm"></a>Partitioning Algorithm</h3><p>Dynamo的分区方案依赖于「一致性哈希」来跨节点分配负载。</p><p>在「一致性哈希」算法中，哈希函数的输出范围被视为一个固定的圆形空间或「环」。系统中的每个节点在这个空间内被分配以一个随机值，代表它在环中的「位置」。对数据项的Key进行哈希计算可以得到在环中的一个位置，从这个位置沿顺时针方向找到的第一个节点就是负责存储该数据项的节点。因此，每个节点负责存储环中一个区域的数据，也就是在环中当前节点和其前驱节点之间的区域中的数据。</p><p>这种设计的优点是，一个节点的加入或离开只影响它的相邻节点，其他节点不受影响。</p><p>基本的一致性哈希算法存在两个挑战：</p><ul><li>首先，环中 每个节点的位置分配是随机的，这可能会导致数据和负载分布不均衡；</li><li>此外，该算法没有考虑节点的异构性（不同节点的性能可能不同）；</li></ul><p>为了解决以上问题，Dynamo使用了一致性哈希算法的变体：每个节点被分配到环中的多个位置（也称为分配了多个<code>Token</code>），一个节点被划分为多个「虚拟节点」。</p><p>加入虚拟节点的优点包括：</p><ul><li>当某个节点不可用时，由该节点处理的负载将会被均匀的分布到其他可用节点上；</li><li>当一个节点再次可用，或者新加入一个节点时，该节点可从其他可用节点接收大致相同的负载；</li><li>可以根据节点的性能（异构性）为其分配虚拟节点的数量；</li></ul><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>为了实现高可用性和持久性，Dynamo将其数据复制到多个主机上。每个数据项复制到N个主机上，其中N是一个通过「per- instance」配置的参数。</p><p>对于每一个键<code>K</code>，首先通过一致性哈希将其分配给一个「协调者节点」（coordinator node）。协调者节点负责复制落到其负责范围内的数据项。协调者节点除了将其负责范围内的数据项存储到本地以外，还在环中其顺时针方向的N-1个节点中复制存储这些数据项，由此完成多副本存储。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/dynamo-2.png" alt="dynamo-2"></p><p>如图2所示，节点B除了将键<code>K</code>存储到本地，还将其复制存储到节点C、D中。也就是说，节点D不光要存储范围<code>(C, D)</code>内的数据项（作为这个范围的协调者节点），还要存储范围<code>(A, B)</code>和范围<code>(B, C)</code>内的数据项（作为这两个范围的备份副本节点）。</p><p>负责存储特定Key的节点列表被称为「偏好列表」或「首选项列表」（Preference List）。需要注意的是，由于使用了虚拟节点，所以存储特定Key的N个节点可能并不是来自N个不同的物理节点。为了解决这个问题，可以通过跳过环中的一些位置来构造键的「首选项列表」，以确保该列表中的节点都来自不同的物理节点。</p><h3 id="Data-Versioning"><a href="#Data-Versioning" class="headerlink" title="Data Versioning"></a>Data Versioning</h3><p>Dynamo提供最终一致性，允许更新操作异步传播到所有副本节点。</p><p>Dynamo将每次修改的结果视为数据的一个新的、不可变的版本。系统允许一个对象的多个版本存在。大多数时候，新版本包含了以前的版本，系统本身可以确定权威版本。</p><p>但是当发生故障并进行并发更新时，可能会出现版本分支，导致对象的版本冲突。在这种情况下，系统本身无法协调同一对象的多个版本分支，必须交由用户来执行版本分支的协调合并。</p><p>Dynamo使用向量时钟来捕捉同一对象的不同版本之间的因果关系。向量时钟是一个<code>&lt;node, counter&gt;</code>对，可以通过检查向量时钟来判断一个对象的两个版本是在同一分支上存在因果顺序，还是在不同的分支上无因果顺序。如果两个版本的counter相同，则说明这两个版本没有因果顺序，发生了分支。</p><p>在Dynamo中，当客户端希望更新一个对象时，它必须指定更新的是哪个版本。<br><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/dynamo-3.png"></p><ol><li>如图3所示，客户端写入了一个新的对象，负责处理这个写操作的节点为Sx，其生成的向量时钟为<code>[Sx,1]</code>，系统现在有对象D1和它对应的向量时钟<code>([Sx, 1])</code>。</li><li>该客户端继续更新该对象，还是节点Sx处理该操作请求，生成向量时钟<code>[Sx, 2]</code>，系统现在有对象D2和它对应的向量时钟<code>([Sx, 2])</code> ，对象D2由对象D1衍生而来，对象D2覆盖了对象D1 。但是可能会有D1的副本仍然存在于尚未见过D2的节点上（异步更新，最终一致性）。</li><li>该客户端再次更新对象，此时是另一个节点Sy处理该操作请求，生成新对象D3和对应的向量时钟<code>([Sx, 2], [Sy, 1])</code> 。</li><li>接下来假设另一个客户端读取D2，然后尝试对它更新，由另一个节点Sz执行操作请求，生成对象D4和对应的向量时钟<code>([Sx, 2], [Sz, 1])</code>。</li><li>已经知道D1或D2的节点在接收到D4及其向量时钟后可以确定D1和D2被新数据D4覆盖，D1和D2可以被垃圾回收；但是知道D3的节点在收到对象D4后，发现这两个对象之间没有因果关系。此时，当客户端进行读取时，这两个对象版本必须都响应给客户端，由客户端进行冲突处理，协调后生成的对象为D5，其向量时钟为<code>([Sx, 3], [Sy, 1], [Sz, 1])</code> 。</li></ol><h3 id="Execution-of-get-and-put-operations"><a href="#Execution-of-get-and-put-operations" class="headerlink" title="Execution of get() and put() operations"></a>Execution of get() and put() operations</h3><p>Dynamo中的任何存储节点都可以接受客户端对任意键的<code>get()</code>和<code>put()</code>操作。</p><p>客户端可以通过两种方式来选择节点：</p><ol><li>通过一个通用的负载均衡器根据负载信息来路由其请求信息，其优点是客户端不需要链接任何额外代码；</li><li>通过一个可以感知分区信息的客户端库来将请求直接路由到适当的协调节点（Coordinator Nodes），其优点是可以实现更低的延迟，因为这跳过了潜在的路由请求转发；</li></ol><p>处理读写请求的节点被称为协调者（Coordinator），通常这是「Preference List」中前N个节点的第一个节点。如果通过负载均衡器接受请求，访问<code>key</code>的请求可能会被路由到环中的任何随机节点。在此情况下，如果接受请求的节点不在被请求键的「Preference List」的前N位，那么该节点将不会对此请求进行协调，而是将请求转发给「Preference List」中前N个节点中的第一个节点。</p><p>读写操作涉及「Preference List」中的前N个健康节点，这会跳过那些宕机或不可访问的节点。</p><p>为了维护副本之间的一致性，Dynamo使用了类似于Quorum System中的一致性协议。该协议有两个可配置参数：</p><ul><li>R：成功读取的最小节点数；</li><li>W：成功写入的最小节点数；</li></ul><p>设置R和W使其满足<code>R + W &gt; N</code>，得到一个类Quorum的系统（此时R和W有交集，必定有一个节点同时完成了写入和读取）。在此模型下，操作延迟由最慢的R或W副本决定。</p><p>当收到一个<code>put()</code>请求时，协调者生成一个新的版本和对应的向量时钟，并将新的版本写到本地。然后，协调者将新的版本发送给其他副本节点，只有当至少<code>W-1</code>个节点响应写入成功时，该<code>put()</code>操作才被认为是成功的。</p><h3 id="Handling-Failures-Hinted-Handoff"><a href="#Handling-Failures-Hinted-Handoff" class="headerlink" title="Handling Failures: Hinted Handoff"></a>Handling Failures: Hinted Handoff</h3><p>暗示切换：如果节点A在写操作期间出现故障无法访问，那么本应存储在A上的副本将会被发送给节点D。</p><p>这样做的目的是为了保障持久性和可用性。</p><p>发送到D的副本会在元数据中保留一个「提示」，提示该副本原来应该发送给哪个节点，在这里原来应该发送给节点A。</p><p>当一个节点收到一个带有「提示」的副本时，该节点会将收到的相关副本数据保存储在一个单独的本地数据库中，定期扫描。当检测到节点A已经恢复正常时，节点D会尝试将该副本数据发送给节点A，发送成功后，节点D会在不减少系统中副本总数的前提下从本地存储中删除相关数据。</p><p>通过「暗示切换」，Dynamo确保读写操作不会因为临时的节点或网络故障而失败。</p><h3 id="Handling-permanent-failures-Replica-synchronization"><a href="#Handling-permanent-failures-Replica-synchronization" class="headerlink" title="Handling permanent failures: Replica synchronization"></a>Handling permanent failures: Replica synchronization</h3><p>Dynamo通过一个「反熵协议」来保持副本的同步。</p><p>Dynamo通过Merkle树来快速检测副本之间的不一致，并最小化需要传输的数据量。</p><p>每个物理节点为每个<code>Key Range</code>维护一个单独的Merkle树（每个物理节点分为多个虚拟节点，每个虚拟节点保存一个<code>Key Range</code>的数据）。</p><p>两个节点通过交换Merkle根来检查数据是否一致。这种方案的缺点是，当有节点加入或离开时，节点的<code>Key Range</code>会发生变化，Merkle树也需要重新计算。</p><h3 id="Membership-and-Failure-Detection"><a href="#Membership-and-Failure-Detection" class="headerlink" title="Membership and Failure Detection"></a>Membership and Failure Detection</h3><p>在Amazon环境中，节点中断（由于故障和维护任务）通常是短暂的，但可能会持续较长时间。节点中断很少会表示为永久中断，因此不应该导致分区分配的再平衡和不可访问副本的修复。</p><p>因此，更恰当的方法是通过显式的方式向Dynamo环中添加或删除节点。</p><p>管理员可以通过命令行工具或浏览器连接到Dynamo节点，并发出成员关系修改，以将节点加入环中或从环中删除节点。服务该请求的节点会将「成员关系更改」和「更改发生时间」写入到其持久存储中。成员关系更改会形成一个历史记录，因为一个节点可以被多次删除或添加。</p><p>Dynamo通过一个基于Gossip的协议传播成员关系更改，并最终达成一致的成员关系视图。每个节点每秒钟联系一个随机选择的节点，两个节点会有效的协调它们持久化存储中的「成员关系更改历史」。</p><p>当一个节点第一次启动时，它会选择它的「Token Set」（令牌集，也就是一致性哈希空间中的虚拟节点集），并将节点映射到它们自己的令牌集。映射持久化到磁盘上，并且最初只包含本地节点和令牌集。存储在不同节点中的映射关系在协调成员关系更改历史时得到协调。</p><p>因此，分区和放置信息也基于Gossip的协议传播，并且每个节点都知道所有「对等节点」（peers）处理的令牌范围。这允许每个节点将Key的读写操作直接转发给其右边的节点集。</p><p>上述加入节点的机制有可能会产生一个临时的逻辑分区。例如，管理员联系节点A将其加入环中，然后再联系节点B将其加入环中。在这种情况下，节点A和B都认为自己是环中的成员，但它们都不会立刻意识到对方的存在。</p><p>为了防止逻辑分区，一些Dynamo节点担任「种子」的角色。「种子」是通过外部机制发现的节点，所有节点都知道这些节点。因为所有的节点最终都需要与「种子」节点进行成员关系的协调，所以不太可能会出现逻辑分区。</p><p>「种子」节点集可以从静态配置中获得，也可以从配置服务中获得，典型的「种子」节点是Dynamo环中功能完整的节点。</p><h3 id="Adding-Removing-Storage-Nodes"><a href="#Adding-Removing-Storage-Nodes" class="headerlink" title="Adding/Removing Storage Nodes"></a>Adding/Removing Storage Nodes</h3><p>当一个新的节点（比如X）被添加到系统中时，它会被分配一些令牌，这些令牌随机分布在环中。</p><p>对于分配给节点X的<code>Key Range</code>，可能当前已经有一些节点（小于等于N个节点）在负责这些Key Range。因为此时已经将这些<code>Key Range</code>分配给了节点X，所有此前负责这些<code>Key Range</code>的一些节点不再负责对其处理，这些节点将会把这些<code>Key Range</code>内的键转移给节点X。</p><p>例如，当一个节点X被加入到图2中的A与B节点之间时，它所负责的<code>Key Range</code>是<code>[(F,G), (G, A), (A,X)]</code>。因此，节点B、C和D不再需要存储对应<code>Key Range</code> 范围内的键，并将在得到节点X的确认后把对应的键传输给节点X。</p><p>当一个节点从系统中删除时，键的重新分配将以相反的过程进行。</p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Dynamo中，每个存储节点由三个软件组件组成：请求协调组件、成员关系和故障检测组件，以及一个本地持久化引擎组件。</p><p>Dynamo的本地持久化组件允许使用不同的存储引擎，以满足不同应用的访问模式。</p><p>如果某个节点响应了一个旧版本对象，协调节点将会对这些节点的旧版本对象进行更新，这个过程被称为「读时修复」（read repair）。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>分布式存储</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-07-05记</title>
    <link href="/2022/07/05/%E4%BA%BA%E7%94%9F%E4%B8%80%E4%BA%8B/2022-07-05/"/>
    <url>/2022/07/05/%E4%BA%BA%E7%94%9F%E4%B8%80%E4%BA%8B/2022-07-05/</url>
    
    <content type="html"><![CDATA[<p>别让最初的兴趣成为负担。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人生一事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSD简单了解</title>
    <link href="/2022/05/29/%E5%AD%98%E5%82%A8/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"/>
    <url>/2022/05/29/%E5%AD%98%E5%82%A8/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="固态硬盘基础"><a href="#固态硬盘基础" class="headerlink" title="固态硬盘基础"></a>固态硬盘基础</h2><p>存储介质的革命为提高存储系统的性能同时带来了机会和挑战。面向传统磁盘设备所设计的存储系统很难发挥新型存储设备的性能优势。面向新型存储介质重构存储软件栈、重构存储系统是最近几年存储领域的热门技术话题。</p><h2 id="SSD概述"><a href="#SSD概述" class="headerlink" title="SSD概述"></a>SSD概述</h2><p>固态硬盘（solid-state drive，简称SSD），是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。SSD的结构如下图所示。</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/SSD/F-component-4.jpg" alt="08图.jpg" style="zoom:50%;" /><p>其采用的存储介质（存储单元）主要分为两种：</p><ul><li><p>一种是采用闪存（FLASH芯片）作为存储介质</p><p>闪存是<strong>非易失性随机访问存储器（NVRAM）</strong>的俗称，特点是断电后数据不会丢失，因此可以作为外部存储器使用。闪存也有不同类型，主要分为以下两大类：</p><ul><li>NOR型：NOR型闪存更像内存，有独立的地址线和数据线，容量比较小，价格比较贵；</li><li>NAND型：NAND型闪存的地址线和数据线是共用的I/O总线，与NOR型闪存相比容量更大，价格也相对较低。</li></ul><p>内存和NOR型闪存的基本存储单元是bit，用户可以随机访问任何一个bit的信息。而NAND型闪存的基本存储单元是页（Page）</p><p><strong>我们通常所说的固态硬盘指的就是使用NAND FLASH作为存储介质的存储设备。</strong></p></li><li><p>另一种是采用DRAM作为存储介质</p><p>采用DRAM作为存储介质，应用范围较窄。它仿效传统硬盘的设计，可被绝大部分操作系统的文件系统工具进行卷设置和管理，并提供工业标准的PCI和FC接口用于连接主机或者服务器。应用方式可分为SSD硬盘和SSD硬盘阵列两种。它是一种高性能的存储器，理论上可以无限写入，美中不足的是需要独立电源来保护数据安全。DRAM固态硬盘属于比较非主流的设备。</p></li><li><p>最新的还有英特尔的3D XPoint技术</p><p>原理上接近DRAM，但是属于非易失存储。读取延时极低，可轻松达到现有固态硬盘的百分之一，并且有接近无限的存储寿命。缺点是密度相对NAND较低，成本极高，多用于发烧级台式机和数据中心。</p></li></ul><h2 id="SSD通信层次"><a href="#SSD通信层次" class="headerlink" title="SSD通信层次"></a>SSD通信层次</h2><p>SSD的通信自上而下可以分为三层：</p><ul><li>传输协议：传输规范、传输标准，也就是数据传输的方式。</li><li>传输总线：总线就像一条公路，公路上的车好比总线上的电信号；公路的大小和车流量就决定了公路的车流量，故总线的位宽大小和传输频率决定了一次传输中能够提供的最大速度。</li><li>传输接口：硬盘的物理接口。</li></ul><p>三者的关系可以用下图表示。</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/SSD/F-relation-1.jpg" alt="01图.jpg" style="zoom:50%;" /><blockquote><p>类似TCP/IP协议的分层设计</p></blockquote><h3 id="传输接口"><a href="#传输接口" class="headerlink" title="传输接口"></a>传输接口</h3><img src="https://www.ajl-newtech.com/ueditor/php/upload/image/20201223/1608701936385215.jpg" alt="04.jpg" style="zoom:50%;" /><p>固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也完全与普通硬盘一致。常见的接口类型如下所示：</p><ul><li><p>SATA接口</p><p>SATA 3.0（SATA 6Gbps）是SATA接口中最为常见的固态硬盘接口。普通2.5英寸SSD以及HDD硬盘都使用这种接口，理论传输带宽6Gbps。SATA3.0接口将持续读写速度限制在550MB/s左右。</p></li><li><p>PCIe接口</p><p>在传统SATA硬盘中，当我们进行数据操作时，数据会先从硬盘读取到内存，再将数据提取至CPU内部进行计算，计算后再反馈给内存，最后写入至硬盘中。而PCIe接口就不一样了，数据直接通过总线与CPU直连，省去了内存调用硬盘的过程，传输效率与速度都成倍提升。</p></li><li><p>M.2固态硬盘接口</p><p>M.2是一种接口/插槽类型。M.2接口（硬盘上的叫接口）和插槽（插到主板上的位置叫插槽）又被细分为B Key（又称为Socket2）和M Key（又称为Socket3），因此M.2接口可以同时支持SATA及PCI-E通道。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/SSD/F-interface-3.png" alt="image-20220529105900503"></p></li><li><p>U.2 接口</p><p>主要用在服务器领域。</p></li></ul><h3 id="传输总线"><a href="#传输总线" class="headerlink" title="传输总线"></a>传输总线</h3><p>总线是计算机各功能部件之间传输信息的通信干线，也即数据传输要走的路。</p><p>在SSD存储领域，总线主要有</p><ul><li>SATA总线</li><li>PCIe总线</li></ul><p>两种总线最大的区别就是带宽，也即速度不同。SATA总线就像乡间小道儿，又窄又泥泞，数据走SATA路，最高传输速度是600MB/s；而PCIE总线就像高速公路，数据走PCIE路，最高传输速度可达2000MB/s。SATA接口只能走SATA总线；M.2接口的SSD绝大数走的是PCIE总线，也有少数是走SATA总线。</p><blockquote><p>目前，大多数主板、SSD接口使用的都PCIE3.0版本。</p><p>根据通道数量不同，PCIE3.0总线又分为x1、x2、x4、x8、x16。通道越多，带宽越高，读写速度越快。SSD固态多用x2、x4，而x8、x16多用在显卡上。</p></blockquote><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>传输协议定义了数据传输的方式，主要有以下几种：</p><ul><li><p>IDE</p></li><li><p>AHCI</p><p>Serial ATA Advanced Host Controller Interface，串行ATA高级主控接口/高级主机控制器接口，IDE速度太低，协议老旧，所以有了AHCI；但AHCI是为了机械硬盘而设计的产物。</p></li><li><p>SATA</p><p>Serial Advanced Technology Attachment即为Serial ATA，串行高级技术附件。支持的接口类型包括：SATA接口、mSATA接口、B-key M.2接口。</p></li><li><p>NVMe</p><p>一种建立在M.2接口上的类似AHCI的一种协议，是专门为闪存类存储设计的协议。NVMe协议本质上建立了多个计算机与存储设备的通路，多个通路其实就是多个队列。而在SATA中，计算机与存储设备只能有一个队列，即使是多CPU情况下，所有请求只能经过这样一个狭窄的道路。而NVMe协议可以最多有64K个队列，每个CPU或者核心都可以有一个队列，这样并发程度大大提升，性能也自然更高了。</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/83745666">https://blog.csdn.net/BtB5e6Nsu1g511Eg5XEg/article/details/83745666</a></li><li><a href="https://www.ajl-newtech.com/article-237.html">https://www.ajl-newtech.com/article-237.html</a></li><li><a href="https://www.ajl-newtech.com/article-234.html">https://www.ajl-newtech.com/article-234.html</a></li><li><a href="https://www.cnblogs.com/luxiaodai/p/13444756.html#_label2">https://www.cnblogs.com/luxiaodai/p/13444756.html#_label2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储</tag>
      
      <tag>固态硬盘</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《笑傲江湖》</title>
    <link href="/2022/05/15/%E8%AF%BB%E4%B9%A6/%E7%AC%91%E5%82%B2%E6%B1%9F%E6%B9%96/"/>
    <url>/2022/05/15/%E8%AF%BB%E4%B9%A6/%E7%AC%91%E5%82%B2%E6%B1%9F%E6%B9%96/</url>
    
    <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="第2章-灭门"><a href="#第2章-灭门" class="headerlink" title="第2章 灭门"></a>第2章 灭门</h3><p>郑镖头道：“咱们福威镖局在外走镖，杀几个绿林盗贼，当真稀松平常。这两只川耗子，鬼头鬼脑的，我瞧不是江洋大盗，便是采花大贼，多半是到福州府来做案的。咱们少镖头招子明亮，才把这大盗料理了，保得福州府一方平安，本可到官府领赏，只是少镖头怕麻烦，不图这个虚名。老头儿，你这张嘴可得紧些，漏了口风出来，我们便说这两个大盗是你勾引来的，你开酒店是假的，做眼线是真。听你口音，半点也不像本地人。否则为什么这二人迟不来，早不来，你一开酒店便来。天下的事情那有这门子巧法？”萨老头连声答应。 </p><p>江湖上的事，名头占了两成，功夫占了两成，馀下的六成，却要靠黑白两道的朋友们赏脸了。</p><p>林平之笑了笑，心下说不出的难过：“都为了我一时忍不住气，杀了一人，以致这许多人为我而死。我若再贪生怕死，何以为人？” </p><p>林平之悲愤难当，提着长剑冲出门去，站在那条血线的三步之外，朗声说道：“大丈夫一人做事一人当，那姓余的四川人，是我林平之杀的，可跟旁人毫不相干。要报仇，尽管冲着林平之来好了，千刀万剐，死而无怨，你们一而再、再而三的杀害良善，算是什么英雄好汉？我林平之在这里，有本事尽管来杀！不敢现身便是无胆匪类，是乌龟忘八羔子！”他越叫越大声，解开衣襟，袒露了胸膛，拍胸叫道：“堂堂男儿，死便死了，有种的便一刀砍过来，为什么连见我一面也不敢？没胆子的狗崽子，贼畜生！” </p><p>林震南坐在太师椅上，闭起双目，将旱烟管抽得呼呼直响，过了半天，才睁开眼来，说道：“平儿，你去通知局中上下人等，大家收拾收拾，天明时一齐离去。叫帐房给大家分发银两。待瘟疫过后，大家再回来。”林平之应道：“是！”心下好生奇怪，怎地父亲忽然又改变了主意。林夫人道：“你说要大家一哄而散？这镖局子谁来照看？”林震南道：“不用看了，这座闹鬼的凶宅，谁敢进来送死？再说，咱三人一走，馀下各人难道不走？”当下林平之出房传讯，局中登时四下里都乱了起来。 </p><h3 id="第3章-聆秘"><a href="#第3章-聆秘" class="headerlink" title="第3章 聆秘"></a>第3章 聆秘</h3><p>​    到得午间，腹中已饿得咕咕直叫，见路旁几株龙眼树上生满了青色的龙眼，虽然未熟，也可充饥。走到树下，伸手便要去摘，随即心想：“这些龙眼是有主之物，不告而取，便是作贼。林家三代干的是保护身家财产的行当，一直和绿林盗贼作对，我怎么能作盗贼勾当？倘若给人见到，当着我爹爹之面骂我一声小贼，教我爹爹如何做人？福威镖局的招牌从此再也竖不起来了。”他幼禀庭训，知大盗都由小贼变来，而小贼最初窃物，往往也不过一瓜一果之微，由小而多，终于积重难返，泥足深陷而不能自拔。想到此处，不由得背上出了一片冷汗，立下念头：“终有一日，爹爹和我要重振福威镖局的声威，大丈夫须当立定脚跟做人，宁做乞儿，不作盗贼。” </p><p>只听那王二叔又道：“还有些开镖局子的，要是赚得够了，急流勇退，乘早收业，金盆洗手，不再在刀头上找这卖命钱，也算得是聪明见机之举。”这几句话钻入林平之耳中，当真惊心动魄：“我爹爹倘若早几年便急流勇退，金盆洗手，却又如何？”<br>    只听那花白胡子又在自言自语：“瓦罐不离井上破，将军难免阵上亡。可是当局者迷，这‘急流勇退’四字，却又谈何容易？”那瞎子道：“是啊，因此这几天我老听人家说：‘刘三爷的声名正当如日中天，突然急流勇退，委实了不起，令人好生钦佩。’” </p><p>​    林平之瞧着七只半截茶杯和从茶杯上削下来的七个瓷圈，寻思：“这老人模样猥葸，似乎伸一根手指便能将他推倒，那知他长剑一晃，便削断了七只茶杯。我若不出福州，焉知世上竟有这等人物？我在福威镖局中坐井观天，只道江湖上再厉害的好手，至多也不过和我爹爹在伯仲之间。唉！我若能拜得此人为师，苦练武功，或者尚能报得大仇，否则是终身无望了。”又想：“我何不去寻找这位莫大先生，苦苦哀恳，求他救我父母，收我为弟子？”刚站起身来，突然又想：“他是衡山派掌门人，五岳剑派和青城派互通声气，他怎肯为我一个毫不相干之人去得罪朋友？”言念及此，复又颓然坐倒。 </p><p>那少女向外面望了一会，见雨兀自淅沥不停，自言自语：“倘若昨儿跟大夥一起来了，今日便不用冒雨赶路。” </p><p>​    陆大有笑道：“我想起侯人英、洪人雄两个家伙给大师哥踢得连跌七八个觔斗，还不知踢他们的人是谁，更不知好端端的为什么挨打。原来大师哥只是听到他们的名字就生气，一面喝酒，一面大声叫道：‘狗熊野猪，青城四兽。’这侯洪二人自然大怒，上前动手，却给大师哥从酒楼上直踢了下来，哈哈！” </p><p>那老者道：“师父他老人家训诫大师哥的话，大家须得牢记心中。师父说道：江湖上学武之人的外号什多，个个都是过什其辞，什么‘威震天南’，又是什么‘追风侠’、‘草上飞’等等，你又怎管得了这许多？人家要叫‘英雄豪杰’，你尽管让他叫。他的所作所为倘若确是英雄豪杰行径，咱们对他钦佩结交还来不及，怎能稍起仇视之心？但如他不是英雄豪杰，武林中自有公论，人人齿冷，咱们又何必理会？”众人听了，都点头称是。陆大有低声道：“倒是我这‘六猴儿’的外号好，包管没人听了生气。” </p><p>几名弟子都叫了起来：“原来那日你匆匆离山，是上青城去了？”那老者道：“是啊，当日师父命我不可向众位师兄弟说起，以免旁生枝节。”陆大有问道：“那有什么枝节可生？师父只是做事把细而已。师父他老人家吩咐下来的事，自然大有道理，又有谁能不服了？”<br>    那高个子道：“你知道什么？二师哥倘若对你说了，你定会向大师哥多嘴。大师哥虽不敢违抗师命，但想些刁钻古怪的事来再去跟青城派捣蛋，却也大有可能。” </p><h3 id="第4章-救难"><a href="#第4章-救难" class="headerlink" title="第4章 救难"></a>第4章 救难</h3><p>​    陆大有倒很守规矩，第一碗先给二师兄劳德诺，第二碗给三师兄梁发，以下依次奉给四师兄施戴子、五师兄高根明，第五碗本该他自己吃的，他端起放在那少女面前，说道：“小师妹，你先吃。”那少女一直和他说笑，叫他六猴儿，但见他端过馄饨，却站了起来，说道：“多谢师哥。”<br>​    林平之在旁偷眼相瞧，心想多半他们师门规矩什严，平时虽可说笑，却不能废了长幼的规矩。劳德诺等都吃了起来，那少女却等陆大有及其他两个师兄都有了馄饨，这才同吃。 </p><p>”<br>    那天门道人满脸煞气，似乎心中郁积着极大的愤怒要爆炸出来，左手在太师椅的靠手上重重一拍，喝道：“令狐冲呢？”他这句话声音极响，当真便如半空中打了个霹雳。<br>    大厅上众人远远听到他这声暴喝，尽皆耸然动容。<br>    那少女灵珊惊道：“三师哥，他们又在找大师哥啦。”梁发点了点头，并不说话，过了一会，低声道：“大家定些！大厅上各路英雄毕集，别让人小觑了我华山派。”<br>    林平之心想：“他们又在找令狐冲啦。这令狐老儿，闯下的乱子也真不少。” </p><p>​    仪琳道：“我听说再要进山洞去，很是害怕，但那时我对令狐师兄已很钦佩，他既这么说，总是不错的，便道：‘好！’他又抱起我窜进山洞，将我放落。我说：‘我衣袋里有天香断续胶，是治伤的灵药，请你……请你取出来敷上伤口。’他道：‘现在拿不大方便，等你手足能动之后再给我罢。’他拔剑割下了一幅衣袖，缚在左肩。这时我才明白，原来他为了保护我，躲在草丛中之时，田伯光一剑砍上他肩头，他一动不动，一声不哼，黑暗中田伯光竟没发觉。我心里难过，不明白取药有什么不方便……” </p><p>​    “先前我肩头一阵剧痛，原来是肩上的穴道解了，这时背心的穴道又痛了几下，我支撑着慢慢爬起，伸手想去摸地下那柄断剑。令狐师兄听到了声音，喜道：‘你穴道解开了，快走，快走。’我说：‘华山派的师兄，我和你一起跟这恶人拚了！’他说：‘你快走！我们二人联手，也打他不过。’田伯光笑道：‘你知道就好！何必枉自送了性命？喂，我倒佩服你是条英雄好汉，你叫什么名字？’令狐师兄道：‘你问我尊姓大名，本来说给你知，却也不妨。但你如此无礼询问，老子睬也不来睬你。’师父，你说好笑不好笑？令狐师兄又不是他爹爹，却自称是他‘老子’。” </p><p>刘正风微笑道：“定逸师太，令狐冲冒他师弟劳德诺之名，是有道理的。这位劳贤侄带艺投师，辈份虽低，年纪却已不小，胡子也这么大把了，足可做得仪琳师侄的祖父。”<br>    定逸登时恍然，才知令狐冲是为了顾全仪琳。其时山洞中一团漆黑，互不见面，仪琳脱身之后，说起救她的是华山派劳德诺，此人是这么一个乾瘪老头子，旁人自无闲言闲语，这不但保全了仪琳的清白名声，也保全了恒山派的威名，言念及此，不由得脸上露出了一丝笑意，点头道：“很好，这小子想得周到。仪琳，后来怎样？” </p><h3 id="第5章-坐斗"><a href="#第5章-坐斗" class="headerlink" title="第5章 坐斗"></a>第5章 坐斗</h3><p>。<br>    仪琳续道：“那时候令狐师兄便拔剑向田伯光疾刺。田伯光回刀挡开，站起身来。”<br>    定逸道：“这可不对了。天松道长接连刺他二三十剑，他都不用起身，令狐冲只刺他一剑，田伯光便须站起来。令狐冲的武功又怎能高得过天松道长？”<br>    仪琳道：“那田伯光是有道理的。他说：‘令狐兄，我当你是朋友，你出兵刃攻我，我如仍然坐着不动，那就是瞧你不起。我武功虽比你高，心中却敬你为人，因此不论胜败，都须起身招架。对付这牛……牛鼻……却又不同。’令狐师兄哼了一声，道：‘承你青眼，令狐冲脸上贴金。’嗤嗤嗤向他连攻三剑。师父，这三剑去势凌厉得很，剑光将田伯光的上盘尽数笼罩住了……” </p><p>“令狐师兄道：‘我如多待得片刻，这小尼姑岂非受了你的污辱？我跟你说，我虽然见了尼姑便生气，但恒山派总是五岳剑派之一。你欺到我们头上来，那可容你不得。’田伯光笑道：‘话虽如此，然而你这一剑若再向前送得三四寸，我一条胳臂就此废了，干么你这一剑刺中我后，却又缩回？’令狐师兄道：‘我是华山弟子，岂能暗箭伤人？你先在我肩头砍一刀，我便在你肩头还了一剑，大家扯个直，再来交手，堂堂正正，谁也不占谁的便宜。’田伯光哈哈大笑，道：‘好，我交了你这个朋友，来来来，喝一碗。’” </p><h3 id="第6章-治伤"><a href="#第6章-治伤" class="headerlink" title="第6章 治伤"></a>第6章 治伤</h3><p>曲非烟忽道：“喂，令狐冲，你会死么？”令狐冲道：“我怎么能死？我如死了，大损恒山派的令誉，太对不住人家了。”曲非烟奇道：“为什么？”令狐冲道：“恒山派的治伤灵药，给我既外敷，又内服，倘若仍然治不好，令狐冲岂非大大的对不住……对不住这位恒山派的师妹？”曲非烟笑道：“对，你要是死了，太也对不住人家了。” </p><p>令狐冲忽然赞道：“啊，真好看！”语气之中，充满了激赏之意。仪琳大羞，心想他怎么忽然赞我好看，登时便想站起身来逃走，可是一时却又拿不定主意，只觉全身发烧，羞得连头颈中也红了。<br>    只听得令狐冲又道：“你瞧，多美！见到了么？”仪琳微微侧身，见他伸手指着西首，顺着他手指望去，只见远处一道彩虹，从树后伸了出来，七彩变幻，艳丽无方，这才知他所说“真好看”，乃是指这彩虹而言，适才是自己会错了意，不由得又是一阵羞惭。只是这时的羞惭中微含失望，和先前又是忸怩、又是暗喜的心情却颇有不同了。 </p><p>​    仪琳听他第二次提到“灵珊师妹”，突然醒悟：“他重伤之下，一定要到瀑布旁来，不见得真是为了观赏风景，却是在想念他的灵珊师妹。”不知如何，心头猛地一痛，便如给人重重一击一般。只听令狐冲又道：“有一次在瀑布旁练剑，她失足滑倒，险些摔入下面的深潭之中，幸好我一把拉住了她，那一次可真危险。” </p><p>令狐冲闭上了眼睛，但只过得一会，便又睁了开来，道：“我只道这里风景好，但到得瀑布旁边，反而瞧不见彩虹了。”仪琳道：“瀑布有瀑布的好看，彩虹有彩虹的好看。”令狐冲点了点头，道：“你说得不错，世上那有十全十美之事。一个人千辛万苦的去寻求一件物事，等得到了手，也不过如此，而本来拿在手中的物事，却反而抛掉了。”仪琳微笑道：“令狐师兄，你这几句话，隐隐含有禅机，只可惜我修为太浅，不明白其中道理。倘若师父听了，定有一番解释。”令狐冲叹了口气，道：“什么禅机不禅机，我懂得什么？唉，好倦！”慢慢闭上了眼睛，渐渐呼吸低沉，入了梦乡。 </p><p>令狐冲听她念得虔诚，声音虽低，却显是全心全意的在向观世音菩萨求救，似乎整个心灵都在向菩萨呼喊哀恳，要菩萨显大神通，解脱自己的苦难，好像在说：“观世音菩萨，求求你免除令狐师兄身上痛楚，把他的痛楚都移到我身上。我变成畜生也好，身入地狱也好，只求菩萨解脱令狐师兄的灾难……”到得后来，令狐冲已听不到经文的意义，只听到一句句祈求祷告的声音，是这么恳挚，这么热切。不知不觉，令狐冲眼中充满了眼泪，他自幼没了父母，师父师母虽待他恩重，毕竟他太过顽劣，总是责打多而慈爱少；师兄弟姊妹间，人人以他是大师兄，一向尊敬，不敢拂逆；灵珊师妹虽和他交好，但从来没对他如此关怀过，只有这个恒山派的仪琳师妹，竟这般宁愿把世间千万种苦难都放到自己身上，只是要他平安喜乐。 </p><h3 id="第7章-洗手"><a href="#第7章-洗手" class="headerlink" title="第7章 洗手"></a>第7章 洗手</h3><p>刘正风仍不置答，数千道眼光都集中在他脸上。各人都觉刘正风答与不答，都是一样，他既然答不出来，便等于默认了。过了良久，刘正风点头道：“不错！曲洋曲大哥，我不但识得，而且是我生平唯一知己，最要好的朋友。” </p><p>刘正风脸上突然闪过一丝凄凉的笑容，说道：“曲大哥和我一见如故，倾盖相交。他和我十馀次联床夜话，偶然涉及门户宗派的异见，他总是深自叹息，认为双方如此争斗，殊属无谓。我和曲大哥相交，只研讨音律。他是七弦琴高手，我喜爱吹箫，二人相见，大多时候总是琴箫相和，武功一道，从来不谈。”他说到这里，微微一笑，续道：“各位或者并不相信，然当今之世，刘正风以为抚琴奏乐，无人及得上曲大哥，而按孔吹箫，在下也不作第二人想。曲大哥虽是魔教中人，但自他琴音之中，我深知他性行高洁，大有光风霁月的襟怀。刘正风不但对他钦佩，抑且仰慕。刘某虽是一介鄙夫，却决计不肯加害这位君子。” </p><p>​    岳不群起身说道：“刘贤弟，你只须点一点头，岳不群负责为你料理曲洋如何？你说大丈夫不能对不起朋友，难道天下便只曲洋一人才是你朋友，我们五岳剑派和这里许多英雄好汉，便都不是你朋友了？这里千馀位武林同道，一听到你要金盆洗手，都千里迢迢的赶来，满腔诚意的向你祝贺，总算够交情了罢？难道你全家老幼的性命，五岳剑派师友的恩谊，这里千百位同道的交情，一并加将起来，还及不上曲洋一人？” </p><h3 id="第8章-授谱"><a href="#第8章-授谱" class="headerlink" title="第8章 授谱"></a>第8章 授谱</h3><p>​    仪琳隔了半晌，才幽幽的道：“其实世上每个人也都这样，有的人早死，有的人迟死，或早或迟，终归要死。无常，苦，我佛说人人都不免生老病死之苦。但大彻大悟，解脱轮回，却又谈何容易？”令狐冲道：“是啊，因此你何必念念不忘那些清规戒律，什么不可杀生，不可偷盗。佛祖要是每一件事都管，可真忙坏了他。” </p><p>刘正风道：“令狐贤侄，你跟此事毫不相干，不必来赶这淌浑水，快快离去，免得将来让你师父为难。” </p><p>令狐冲哈哈一笑，说道：“刘师叔，咱们自居侠义道，与邪魔外道誓不两立，这‘侠义’二字，是什么意思？欺辱身负重伤之人，算不算侠义？残杀无辜幼女，算不算侠义？要是这种事情都干得出，跟邪魔外道又有什么分别？” </p><p>曲洋叹道：“这种事情，我们日月教也是不做的。令狐兄弟，你自己请便罢，嵩山派爱干这种事，且由他干便了。” </p><p>曲非烟笑道：“傻子，到现在还不明白人家的心意，她要陪你一块儿死……”一句话没说完，费彬长剑送出，刺入了她心窝。<br>    曲洋、刘正风、令狐冲、仪琳齐声惊呼。 </p><p>令狐冲脑中一片混乱：“他……他竟将这小姑娘杀了，好不狠毒！我这也就要死了。仪琳师妹为什么要陪我一块死？我虽救过她，但她也救了我，已补报了欠我之情。我跟她以前素不相识，不过同是五岳剑派的师兄妹，虽有江湖上的道义，却用不着以性命相陪啊。没想到恒山派门下弟子，竟如此顾全武林义气，定逸师太实是个了不起的人物。嘿，是这个仪琳师妹陪着我一起死，却不是我那灵珊小师妹。她……她这时候在干什么？”眼见费彬狞笑的脸渐渐逼近，令狐冲微微一笑，叹了口气，闭上了眼睛。<br>    忽然间耳中传入几下幽幽的胡琴声，琴声凄凉，似是叹息，又似哭泣，跟着琴声颤抖，发出瑟瑟瑟断续之音，犹如一滴滴小雨落上树叶。令狐冲大为诧异，睁开眼来。 </p><p>一点点鲜血从两柄长剑间溅了出来，费彬腾挪闪跃，竭力招架，始终脱不出莫大先生的剑光笼罩，鲜血渐渐在二人身周溅成了一个红圈。猛听得费彬长声惨呼，高跃而起。莫大先生退后两步，将长剑插入胡琴，转身便走，一曲《潇湘夜雨》在松树后响起，渐渐远去。<br>    费彬跃起后便即摔倒，胸口一道血箭如涌泉般向上喷出，适才激战，他运起了嵩山派内力，胸口中剑后内力未消，将鲜血逼得从伤口中急喷而出，既诡异，又可怖。 </p><p>曲洋叹道：“刘贤弟，你曾说你师兄弟不和，没想到他在你临危之际，出手相救。”刘正风道：“我师哥行为古怪，教人好生难解。我和他不睦，决不是为了什么贫富之见，只是说什么也性子不投。”曲洋摇了摇头，说道：“他剑法如此之精，但所奏胡琴一味凄苦，引人下泪，未免太也俗气，脱不了市井味儿。”刘正风道：“是啊，师哥奏琴往而不复，曲调又是尽量往哀伤的路上走。好诗好词讲究乐而不淫，哀而不伤，好曲子何尝不是如此？我一听到他的胡琴，就想避而远之。” </p><p>令狐冲心想：“这二人爱音乐入了魔，在这生死关头，还在研讨什么哀而不伤，什么风雅俗气。幸亏莫大师伯及时赶到，救了我们性命。” </p><p>曲洋向刘正风望了一眼，说道：“我和刘贤弟醉心音律，以数年之功，创制了一曲《笑傲江湖》，自信此曲之奇，千古所未有。今后纵然世上再有曲洋，不见得又有刘正风，有刘正风，不见得又有曲洋。就算又有曲洋、刘正风一般的人物，二人又未必生于同时，相遇结交。要两个既精音律，又精内功之人，志趣相投，修为相若，一同创制此曲，实是千难万难了。此曲绝响，我和刘贤弟在九泉之下，不免时发浩叹。”他说到这里，从怀中摸出一本册子来，说道：“这是《笑傲江湖曲》的琴谱箫谱，请小兄弟念着我二人一番心血，将这琴谱箫谱携至世上，觅得传人。” </p><p>岳不群叹了口气，说道：“我华山派向来的宗旨是‘人不犯我，我不犯人’，除了跟魔教是死对头之外，与武林中各门各派均无嫌隙。但自今而后，青城派……青城派……唉，既已身涉江湖，要想事事都不得罪人，那可谈何容易？”<br>    劳德诺道：“林师弟，这桩祸事，倒不是由于你打抱不平而杀了余沧海的儿子，全因余沧海觊觎你林家的家传辟邪剑谱而起。当年青城派掌门长青子败在林师弟曾祖远图公的辟邪剑法之下，那时就已种下祸根了。” </p><p>林平之只瞧得目瞪口呆，心道：“大师哥说话行事疯疯颠颠，武功却恁地了得，我以后须得片刻也不松懈的练功，才不致给人小看了。” </p><h3 id="第9章-面壁"><a href="#第9章-面壁" class="headerlink" title="第9章 面壁"></a>第9章 面壁</h3><p>他望着岳灵珊微微飞动的秀发，正自出神，忽听得她轻轻叫了一声：“姓林的小子，你不听话！过来，我揍你！”令狐冲一怔，见她双目兀自紧闭了，侧个身，又即呼吸匀净，知道她刚才是说梦话，不禁好笑，心想：“她一做师姊，神气得了不得，这些日子中，林师弟定然给她呼来喝去，受饱了气。她在梦中也不忘骂人。” </p><p>令狐冲见大雪已止，生怕师弟师妹们发觉不见了岳灵珊，若有风言蜚语，那可大大对不起小师妹了，说笑了一阵，便催她下崖。岳灵珊兀自恋恋不舍，道：“我要在这里多玩一会儿，爹爹妈妈都不在家，闷也闷死了。”令狐冲道：“乖师妹，这几日我又想出了几招冲灵剑法，等我下崖之后，陪你到瀑布中去练剑。”说了好一会，才哄得她下崖。</p><p>​    两人隔了这么久见面，均是悲喜交集。岳灵珊凝望他脸，惊道：“大师哥，你也生了病吗？怎地瘦得这般厉害？”令狐冲摇摇头，道：“我没生病，我……我……”岳灵珊陡地醒悟，突然哭了出来，道：“你……你是记挂着我，以致瘦成了这个样子。大师哥，我现下全好啦。”令狐冲握着她手，低声道：“这些日来，我日日夜夜望着这条路，就只盼着这一刻的时光，谢天谢地，你终于来了。” </p><p>​    这一天中，令狐冲感到了生平从未经历过的欢喜，坐在石上，忍不住自己笑出声来，突然间纵声长啸，山谷鸣响，这啸声中似乎在叫喊：“我好欢喜，我好欢喜！” </p><p>令狐冲默然不语，突然之间，心中涌现了一股说不出的烦扰，一只粽子只吃了两口，手中拿着半截粽子，只感一片茫然。 </p><p>岳灵珊拉了拉他衣袖，笑道：“大师哥，你把舌头吞下肚去了吗？怎地不说话了？”令狐冲一怔，将半截粽子送到口中，粽子清香鲜美，但黏在嘴里，竟没法下咽。岳灵珊指住了他，格格娇笑，道：“吃得这般性急，黏住了牙齿。”令狐冲脸现苦笑，努力把粽子吞下咽喉，心想：“我恁地傻！小师妹爱玩，我又不能下崖，她便拉林师弟作伴，那也寻常得很，我竟这等小气，为此介意！”言念及此，登时心平气和，笑道：“这只粽子定是你裹的，裹得也真黏，可将我牙齿和舌头都黏在一起啦。”岳灵珊哈哈大笑，隔了一会，说道：“可怜的大师哥，在这崖上坐牢，馋成了这副样子。” </p><p>这次她过了十馀日才又上崖，酒饭之外又有一只小小竹篮，盛着半篮松子、栗子。 </p><p>​    岳灵珊脸色苍白，呆呆的瞪着令狐冲，一言不发，上颚牙齿紧紧咬住下唇。<br>​    令狐冲叫声“啊哟！”忙冲到崖边，那剑早已落入了下面千丈深谷，无影无踪。突然之间，只见山崖边青影闪动，似是一片衣角，令狐冲定神看时，再也见不到什么，一颗心怦怦而跳，暗道：“我怎么了？我怎么了？跟小师妹比剑过招，不知已有过几千百次，我向来让她，从没一次如今日的出手不留情。我做事可越来越荒唐了。” </p><p>​    令狐冲闷闷不乐，寻思：“我往时对她什么事都尽量容让，怎地今日一指便弹去了她的宝剑？难道师娘传了她‘玉女剑十九式’，我便起了妒忌的念头么？不，不会，决无此事。‘玉女剑十九式’本是华山派女弟子的功夫，何况小师妹学的本领越好，我只有越高兴。唉，总是独个儿在崖上过得久了，脾气暴躁。只盼她明日又再上崖来，我好好给她赔不是，最好再来比剑，我让她施展高招，在我手臂上划上一剑。只要出血多了，她就会不好意思，不生我的气了。” </p><p>岳灵珊道：“六师哥怎么啦？你老是跟小林子过不去。人家是师弟，你做师哥的该当包涵点儿才是。”陆大有哼了一声，道：“他安份守己，那就罢了，否则我姓陆的第一个便容他不得。”岳灵珊道：“他到底怎么不安份守己了？”陆大有道：“他……他……他……”说了三个“他”字便不说下去了。岳灵珊道：“到底什么事啊？这么吞吞吐吐。”陆大有道：“但愿六猴儿走了眼，看错了事。”岳灵珊脸上微微一红，就不再问。陆大有嚷着要走，岳灵珊便也和他一同下崖。 </p><p>令狐冲倾听歌词，依稀只听到：“姊妹，上山采茶去”几个字，但她发音古怪，十分之八九只闻其音，不辨其义，心想：“小师妹几时学了这首新歌，好听得很啊，下次上崖来请她从头唱一遍。”<br>    突然之间，胸口忽如受了铁锤的重重一击，猛地省悟：“这是福建山歌，是林师弟教她的！” </p><p>这一晚心思如潮，令狐冲再也没法入睡，耳边便是响着岳灵珊那轻快活泼、语音难辨的山歌声。几番自怨自责：“令狐冲啊令狐冲，你往日何等潇洒自在，今日只为了一首曲子，心里却如此摆脱不开，枉自为男子汉大丈夫了。” </p><p>令狐冲心头涌上一股难以形容的苦涩滋味，随即想起后洞石壁上那招专破“有凤来仪”的绝招，从地下拾起一根树枝，随手摆了个姿式，便想将这一招传给陆大有，但转念一想：“六师弟对那姓林的小子恼恨已极，此招既出，定然令他重伤，师父师娘追究起来，我们二人定受重责，这事万万不可。”便道：“吃一次亏，学一次乖，以后别再上当，也就是了。自己师兄弟，过招时的小小胜败，也不必在乎。”<br>    陆大有道：“是。可是大师哥，我能不在乎，你……你也能不在乎吗？”<br>    令狐冲知他说的是岳灵珊之事，心头感到一阵剧烈痛楚，脸上肌肉也扭曲了起来。<br>    陆大有一言既出，便知这句话大伤师哥之心，忙道：“我……我说错了。”</p><p>岳灵珊不应，上得崖来，将饭篮往大石上重重一放，一眼也不向他瞧，转身便行。令狐冲大急，叫道：“小师妹，小师妹，你怎么了？”岳灵珊哼了一声，右足一点，纵身便即下崖，任由令狐冲一再叫唤，她始终不应一声，也始终不回头瞧他一眼。令狐冲心情激荡，一时不知如何是好，打开饭篮，但见一篮白饭，两碗素菜，却没了那一小葫芦酒。他痴痴的瞧着，不由得呆了。 </p><p>令狐冲踏上一步，道：“小师妹，我……”他本想说：“我确实没叫六师弟去向师父师娘告状。”但转念又想：“我问心无愧，并没做过此事，何必为此向你哀恳乞怜？”说了一个“我”字，便没接口说下去。 </p><p>令狐冲神色漠然，睁大了眼睛向她瞧着，眼光中流露出迷茫之色，似乎并不相识。岳灵珊道：“大师哥，是我啊。你怎么不睬我？”令狐冲仍呆呆瞪视，过了良久，闭眼睡着了，直至陆大有和岳灵珊离去，他始终没再醒来。<br>    这场病直生了一个多月，这才渐渐痊可。这一个多月中，岳灵珊曾来探视了三次。<br>    但自这次探病之后，她却又绝足不来。令狐冲自能起身行走之后，每日之中，倒有大半天是在崖边等待这小师妹的倩影，可是每次见到的，若非空山寂寂，便是陆大有佝偻着身子快步上崖的形相。</p><h3 id="第10章-邀客"><a href="#第10章-邀客" class="headerlink" title="第10章 邀客"></a>第10章 邀客</h3><p>岳不群摇了摇头，说道：“我查考他的不是身子强弱，而是内力修为，这跟生不生病无关。本门气功与别派不同，只须勤加修习，纵在睡梦中也能不断进步。何况冲儿修练本门气功已逾十年，若非身受外伤，本就不该生病，总之……总之是七情六欲不善控制之故。” </p><p>岳不群道：“武林之中，变故日多。我和你师娘近年来四处奔波，眼见所伏祸胎难以消解，来日必有大难，心下实是不安。”他顿了一顿，又道：“你是本门大弟子，我和你师娘对你期望什殷，盼你他日能为我们分任艰巨，抵挡祸患，光大华山一派。但你牵缠于儿女私情，不求上进，荒废武功，可令我们失望得很了。” </p><p>田伯光竖起右手拇指，大声道：“大丈夫，好汉子！”令狐冲问道：“田兄如何称赞小弟？”田伯光道：“田某是个无恶不作的淫贼，曾把你砍得重伤，又在华山脚边犯案累累，华山派上下无不想杀之而后快。今日担得酒来，令狐兄却坦然而饮，竟不怕酒中下了毒，也只有如此胸襟的大丈夫，才配喝这天下名酒。”<br>    令狐冲道：“取笑了。小弟与田兄交手两次，深知田兄品行不端，但暗中害人之事却不屑为。再说，你武功比我高得多，要取我性命，拔刀相砍便是，有何难处？” </p><p>令狐冲一怔，万没想到他大胜之馀，反肯赔罪，当下抱拳还礼，道：“不敢！”寻思：“礼下于人，必有所图。他对我如此敬重，不知有何用意？”苦思不得，索性便开门见山的相询，说道：“田兄，令狐冲心中有一事不明，不知田兄是否肯直言相告？”田伯光道：“田伯光事无不可对人言。奸淫掳掠、杀人放火之事，旁人要隐瞒抵赖，田伯光做便做了，何赖之有？”令狐冲道：“如此说来，田兄倒是个光明磊落的好汉子。”田伯光道：“‘好汉子’三字，可不敢当，总算得还是个言行如一的真小人。” </p><h3 id="第11章-传剑"><a href="#第11章-传剑" class="headerlink" title="第11章 传剑"></a>第11章 传剑</h3><p>那老者道：“唉，蠢才，蠢才！无怪你是岳不群的弟子，拘泥不化，不知变通。剑术之道，讲究如行云流水，任意所之。你使完那招‘白虹贯日’，剑尖向上，难道不会顺势拖下来吗？剑招中虽没这姿式，难道你不会别出心裁，随手配合么？” </p><p>​    只听风清扬续道：“岳不群那小子，当真狗屁不通。你本是块大好的材料，却给他教得变成了蠢牛木马。”令狐冲听得他辱及恩师，心下气恼，当即昂然道：“太师叔，我不要你教了，我出去逼田伯光立誓不可泄漏太师叔之事就是。” </p><p>​    风清扬叹了口气，说道：“这些魔教长老，也确都是了不起的聪明才智之士，竟将五岳剑派中的高招破得如此乾净彻底。只不过他们不知道，世上最厉害的招数，不在武功之中，而是阴谋诡计、机关陷阱。倘若落入了别人巧妙安排的陷阱，凭你多高明的武功招数，那也全然用不着了……”说着抬起了头，眼光茫然，显是想起了无数旧事。 </p><p>他从师练剑十馀年，每一次练习，总是全心全意的打醒精神，不敢有丝毫怠忽。岳不群课徒极严，众弟子练拳使剑，举手提足间只要稍离了尺寸法度，他便立加纠正，每一个招式总要练得十全十美，没半点错误，方能得到他点头认可。令狐冲是开山门的大弟子，又生来要强好胜，为了博得师父、师娘赞许，练习招式时加倍的严于自律。不料风清扬教剑全然相反，要他越随便越好，这正投其所好，使剑时心中畅美难言，只觉比之痛饮数十年的美酒还要滋味无穷。 </p><p>风清扬微笑道：“你用这法子取得了一日一夜，竟不费半点力气，只不过有点儿卑鄙无耻。”令狐冲笑道：“对付卑鄙无耻之徒，说不得，只好用点卑鄙无耻的手段。”风清扬正色道：“要是对付正人君子呢？”令狐冲一怔，道：“正人君子？”一时答不出话来。<br>    风清扬双目炯炯，瞪视着令狐冲，森然问道：“要是对付正人君子，那便怎样？”<br>    令狐冲道：“就算他真是正人君子，倘若想要杀我，我也不能甘心就戮，到了不得已的时候，卑鄙无耻的手段，也只好用上这么一点半点了。”风清扬大喜，朗声道：“好，好！你说这话，便不是假冒为善的伪君子。大丈夫行事，爱怎样便怎样，行云流水，任意所之，什么武林规矩，门派教条，全都是放他妈的狗臭屁！” </p><p>​    田伯光冷冷的道：“你只须这么一剑刺将过来，杀人灭口，岂不乾脆？”令狐冲退后两步，还剑入鞘，说道：“当日田兄武艺远胜于我之时，倘若一刀将我杀了，焉有今日之事？在下请田兄不向旁人泄露我风太师叔的行踪，乃是相求，不敢有丝毫胁迫之意。”田伯光道：“好，我答允了。”令狐冲深深一揖，道：“多谢田兄。” </p><p>风清扬道：“你倒也不可妄自菲薄。独孤大侠是绝顶聪明之人，学他的剑法，要旨在一个‘悟’字，决不在死记硬记。等到通晓了这九剑的剑意，则无所施而不可，便是将全部变化尽数忘记，也不相干，临敌之际，更是忘记得越乾净彻底，越不受原来剑法的拘束。你资质什好，正是学练这套剑法的材料。何况当今之世，真有什么了不起的英雄人物，嘿嘿，只怕也未必。以后自己好好用功，我可要去了。” </p><p>风清扬厉声道：“从今以后，我再也不见华山派门中之人，连你也不例外。”见令狐冲神色惶恐，便语气转和，说道：“冲儿，我跟你既有缘，亦复投机。我暮年得有你这样一个佳子弟传我剑法，实是大畅老怀。你如心中有我这样一个太师叔，今后别来见我，以致令我为难。”令狐冲心中酸楚，道：“太师叔，那为什么？”风清扬摇摇头，说道：“你见到我的事，连对你师父也不可说起。”令狐冲含泪道：“是，自当遵从太师叔吩咐。” </p><h3 id="第12章-聚气"><a href="#第12章-聚气" class="headerlink" title="第12章 聚气"></a>第12章 聚气</h3><p>岳不群脸色郑重，缓缓的道：“借冲儿之伤，耗我内力。”<br>    岳夫人跳起身来，说道：“不错！你为了要救冲儿之命，势必以内力替他化去这六道真气，待得大功将成之际，这六个丑八怪突然现身，以逸待劳，便能制咱们的死命。”顿了一顿，又道：“幸好现下只剩五怪了。师哥，适才他们明明已将我擒住，何以听得冲儿一喝，便又放了我？”想到先前的险事，兀自心有馀悸，不由得语音发颤。 </p><p>只见岳灵珊便就在门外，说道：“爹爹，大师哥似乎……似乎不成了。”岳不群惊道：“怎么？”岳灵珊道：“他口中胡言乱语，神智越来越不清了。”岳不群问道：“他胡言乱语些什么？”岳灵珊脸上一红，道：“我也不明白他胡言乱语些什么？” </p><p>岳灵珊从怀内取出一个布包，低声道：“大师哥，这是《紫霞秘笈》，爹爹说道……”令狐冲道：“紫霞秘笈？”岳灵珊道：“正是，爹爹说，你身上中了旁门高手的内力，须得以本派至高无上的内功心法来予以化解。六猴儿，你一个字一个字的读给大师哥听，你自己可不许练，否则给爹爹知道了，哼哼，你自己知道会有什么后果。” </p><p>陆大有大喜，忙道：“我是什么胚子，怎敢偷练本门至高无上的内功心法？小师妹尽管放心好啦。恩师为了救大师哥之命，不惜破例以秘笈相授，大师哥这可有救了。”岳灵珊低声道：“这事你对谁也不许说。这部秘笈，我是从爹爹那里偷出来的。”陆大有惊道：“你偷师父……师父的内功秘笈？他老人家发觉了那怎么办？”岳灵珊道：“什么怎么办？难道还能将我杀了？至多不过骂我几场，打我一顿。倘若由此救了大师哥，爹爹妈妈一定欢喜，什么也不计较了。”陆大有道：“是，是！眼前是救命要紧。” </p><p>令狐冲忽道：“小师妹，你带回去，还……还给师父。” </p><p>令狐冲道：“我……我宁死不违师命。师父说过的，我不能……不能学练这紫霞神功。小……小师妹……”一口气接不上来，又晕了过去。<br>    岳灵珊探他鼻下，虽然呼吸微弱，仍有气息，叹了口气，向陆大有道：“我赶着回去，要是天光时回不到庙里，爹爹妈妈可要急死了。你劝劝大师哥，要他无论如何得听我的话，修习这部紫霞秘笈。别……别辜负了我……”说到这里，脸上一红，道：“我这一夜奔波的辛苦。”<br>    陆大有道：“我一定劝他。小师妹，师父他们住在那里？”岳灵珊道：“我们今晚在白马庙住。”陆大有道：“嗯，白马庙离这儿是三十里的山道，小师妹，这来回六十里的黑夜奔波，大师哥永不会忘记。”岳灵珊眼眶一红，哽咽道：“我只盼他能复元，那就好了。这件事他记不记得，有什么相干？”说着双手捧了《紫霞秘笈》，放在令狐冲床头，向他凝视片刻，奔了出去。 </p><p>陆大有一呆，抬起头来，道：“大师哥，你……你怎么了？什么地方不舒服？”令狐冲怒道：“我听着你读师父的……内功秘笈，周身都不舒服。你要叫我成为一个……不忠不义之徒，是不是？”陆大有愕然道：“不，不，那怎么会不忠不义？”令狐冲道：“这部紫霞秘笈，当日师父曾携到思过崖上，想要传我，但发觉我练功的路子固然不合，资质……资质也不对，这才改变了主意……主意……”说到这里，气喘吁吁，很是辛苦。陆大有道：“这一次却是为了救命，又不是偷练武功，那……那是全然不同的。”令狐冲道：“咱们做弟子的，是自己性命要紧，还是师父的旨意要紧？”陆大有道：“师父师娘要你活着，那是最最要紧的事了，何况……何况，小师妹黑夜奔波，这一番情意，你如何可以辜负了？”<br>    令狐冲胸口一酸，泪水便欲夺眶而出，说道：“正因为是她……是她拿来给我的……我令狐冲堂堂丈夫，岂受人怜？”他这一句话一出口，不由得全身一震，心道：“我令狐冲向来不是拘泥不化之人，为了救命，练一练师门内功又打什么紧？原来我不肯练这紫霞神功，是为了跟小师妹赌气，原来我内心深处，是在怨恨小师妹和林师弟相好，对我冷淡。令狐冲啊令狐冲，你如何这等小气？”但想到岳灵珊一到天明，便和林平之会合，远去嵩山，一路上并肩而行，途中不知将说多少言语，不知将唱多少山歌，胸中酸楚，眼泪终于流了下来。 </p><p>陆大有道：“大师哥，你这可是想左了，小师妹和你自幼一起长大，你们……你们便如是亲兄妹一般。”令狐冲心道：“我便不要和她如亲兄妹一般。”只是这句话难以出口，却听陆大有续道：“我再读下去，你慢慢听着，一时记不住，我便多读几遍。天下武功，以练气为正。浩然正气，原为天授……”令狐冲厉声道：“不许读！” </p><h3 id="第13章-围攻"><a href="#第13章-围攻" class="headerlink" title="第13章 围攻"></a>第13章 围攻</h3><p>​    不戒叫道：“糟糕，糟糕！琳儿，爹爹今日为你女婿治伤，大耗内力，这把长剑竟飞了一半便掉将下来。本来该当飞到你女婿的师父面前两尺之处落下，吓他一大跳，唉！你和尚爹爹这一回丢脸之极，难为情死了。” </p><p>​    仪琳双手掩面，叫道：“爹，别说啦，别说啦！他自是他，我自是我，有……有……有什么干系了？”哇的一声，哭了出来，向山下疾奔而去。 </p><p>​    不戒和尚更加摸不着头脑，呆了一会，道：“奇怪，奇怪！见不到他时，拚命要见。见到他时，却又不要见了。就跟她妈妈一模一样，小尼姑的心事，当真猜想不透。”眼见女儿越奔越远，当即追了下去。 </p><p>他对这个大弟子一向锺爱，见他居然重伤不死，心下早已十分欢喜，刚才他假装跌倒，自刺其腿，明知是诈，只是此人从小便十分狡狯，岳不群知之已稔，也不深究，再加令狐冲对不戒和尚这番言语应对得体，颇洽己意，田伯光这桩公案，暂且便搁下了，伸手说道：“书呢？” </p><p>林平之大声叫道：“一切祸事，都是由我林平之身上而起。我跟你们说，我福建林家，压根儿便没什么辟邪剑谱，信与不信，全由你们了。”说着从地下拾起一根给震落的镔铁怀杖，猛力往自己额头击落。只是他双臂已遭点了穴道，出手无力，嗒的一声，怀杖虽击在头上，只擦损了一些油皮，连鲜血也无。但他此举用意，旁人都十分明白，他意欲牺牲一己性命，表明并没什么剑谱落在华山派手中。 </p><p>他长叹一声，眼光向岳灵珊望去，知道这是临死时最后一眼，只盼能从岳灵珊的神色中得到一些慰藉，果见她一双妙目正凝视着自己，眼光中流露出十分焦虑关切之情。令狐冲心中一喜，火光中却见她一只纤纤素手垂在身边，竟是和一只男子的手相握，一瞥眼间，那男子正是林平之。令狐冲胸口一酸，更无斗志，当下便想抛下长剑，听由宰割。 </p><h3 id="第14章-学琴"><a href="#第14章-学琴" class="headerlink" title="第14章 学琴"></a>第14章 学琴</h3><p>不群冷笑道：“你剑法高明，做戏的本事更加高明。”令狐冲不敢回答，心想：“师父待我恩重如山，今日错怪了我，日后终究会水落石出。此事太也蹊跷，那也难怪他老人家心中生疑。”他虽受委屈，倒无丝毫怨怼之意。<br>    岳夫人温言道：“昨晚若不是凭了冲儿的神妙剑法，华山派全军覆没，固然不用说了，我们娘儿们只怕还难免惨受凌辱。不管传授冲儿剑法那位前辈是谁，咱们所受恩德，总之实在不浅。至于那一十五个恶徒的来历，日后总能打听得出。冲儿怎么跟他们会有交情？他们不是要将冲儿乱刀分尸、冲儿又都刺瞎了他们眼睛么？”<br>    岳不群抬起了头呆呆出神，于岳夫人这番话似一句也没听进耳去。 </p><p>​    岳不群向岳夫人道：“师妹，你说咱们到那里去？”岳夫人道：“嵩山是不必去了。但既然出来了，也不必急急的就回华山。”她害怕桃谷六仙，不敢便即回山。岳不群道：“左右无事，四下走走那也不错，也好让弟子们增长些阅历见闻。”<br>​    岳灵珊大喜，拍手道：“好极，爹爹……”但随即想到梁发师哥刚死，登时便如此欢喜，实是不合，只拍了一下手，便即停住。岳不群微笑道：“提到游山玩水，你最高兴了。爹爹索性顺你的性，珊儿，你说咱们到那里去玩的好？”说着眼瞧林平之。 </p><p>令狐冲知他必是去向师父禀报自己动静，暗自冷笑：“我又没做丝毫亏心事，你们就有十个、一百个对我日夜监视，令狐冲光明磊落，又有何惧？”胸中愤激，牵动了内息，只感气血翻涌，极是难受，伏在枕上大声喘息，隔了好半天，这才渐渐平静。坐起身来，披衣穿鞋，心道：“师父既已不当我弟子看待，便似防贼一般提防，我留在华山派中还有什么意味，不如一走了之。将来师父明白我也罢，不明白也罢，一切由他去罢。” </p><p>​    又想：“刘正风师叔和曲长老，一是正派高手，一是魔教长老，两人正邪殊途，势如水火，但论到音韵，却心意相通，结成知交，合创了这曲神妙绝伦的《笑傲江湖》。他二人携手同死之时，显是心中绝无遗憾，远胜于我孤另另的在这世上，为师父所疑，为师妹所弃，而一个敬我爱我的师弟，却又为我亲手所杀。”不由得悲从中来，眼泪一滴滴的落在曲谱之上，忍不住哽咽出声。 </p><p>令狐冲虽于音律一窍不通，但天资聪明，一点便透。绿竹翁什是欢喜，当即授以指法，教他试奏一曲极短的《碧霄吟》。令狐冲学得几遍，弹奏出来，虽有数音不准，指法生涩，但心中想着“碧霄”二字，却洋洋然自有青天一碧、万里无云的空阔气象。<br>    一曲既终，那婆婆在隔舍听了，轻叹一声，道：“令狐少君，你学琴如此聪明，多半不久便能学《清心普善咒》了。”绿竹翁道：“姑姑，令狐兄弟今日初学，但弹奏这曲《碧霄吟》，琴中意象已比侄儿为高。琴为心声，想是因他胸襟豁达之故。” </p><p>​    那婆婆轻声道：“‘缘’之一事，不能强求。古人道得好：‘各有因缘莫羡人’。令狐少君，你今日虽然失意，他日未始不能另有佳耦。” </p><p>令狐冲大声道：“弟子也不知能再活得几日，室家之想，那是永远不会有的了。”<br>    那婆婆不再说话，琴音轻轻，奏了起来，却是那曲《清心普善咒》。令狐冲听得片刻，便已昏昏欲睡。那婆婆止了琴音，说道：“现下我起始授你此曲，大概有十日之功，便可学完。此后每日弹奏，往时功力虽不能尽复，多少总会有些好处。” </p><p>令狐冲与那婆婆相处多日，虽然从未见过她一面，但从琴音说话之中，知她对自己颇为关怀，无异亲人。只是她性子淡泊，偶然说了一句关切的话，立即杂以他语，显是不想让他知道心意。这世上对令狐冲最关心的，本来是岳不群夫妇、岳灵珊与陆大有四人，现今陆大有已死，岳灵珊全心全意放在林平之身上，师父师母对他又有了疑忌之意，他觉得真正的亲人，倒只有绿竹翁和那婆婆二人了。这一日中，他几次三番想跟绿竹翁陈说，要在这小巷中留居，既学琴箫，又学竹匠之艺，不再回归华山派，但一想到岳灵珊的倩影，终究割舍不下，心想：“小师妹就算不理睬我，我每日只见她一面，纵然只见到她的背影，听到一句她的说话声音，也是好的。何况她又没不睬我？” </p><p>那婆婆道：“令狐少君，临别之际，我有一言相劝。”<br>    令狐冲道：“是，前辈教诲，令狐冲不敢或忘。”<br>    但那婆婆始终不说话，过了良久良久，才轻声说道：“江湖风波险恶，少君性情仁厚，多多保重。” </p><p>正热闹间，忽然一名敝衣老者走上船头，叫道：“令狐少君！”令狐冲见是绿竹翁，不由得一怔，忙迎上躬身行礼。绿竹翁道：“我姑姑命我将这件薄礼送给令狐少君。”说着双手奉上一个长长的包裹，包袱布是印以白花的蓝色粗布。令狐冲躬身接过，说道：“前辈厚赐，弟子拜领。”说着连连作揖。 </p><p>​    岳不群指着那蓝布包裹，问道：“他给了你些什么？”令狐冲道：“弟子不知。”打开包裹，露出一具短琴，琴身陈旧，显是古物，琴尾刻着两个篆字“燕语”；另有一本册子，封面上写着“清心普善咒”五字。令狐冲胸口一热，“啊”的一声，叫了出来。<br>​    岳不群凝视着他，问道：“怎么？”令狐冲道：“这位前辈不但给了我一张瑶琴，还抄了琴谱给我。”翻开琴谱，但见每一页都写满了簪花小楷，除了以琴字书明曲调之外，还详细列明指法、弦法，以及抚琴的种种关窍，纸张墨色，均是全新，显是那婆婆刚写就的。令狐冲想到这位前辈对自己如此眷顾，心下感动，眼中泪光莹然，差点便掉下泪来。 </p><h3 id="第15章-论杯"><a href="#第15章-论杯" class="headerlink" title="第15章 论杯"></a>第15章 论杯</h3><p>岳不群夫妇对望了一眼，均想：“这平一指果然了不起，他一搭脉搏，察觉冲儿体内有八道不同真气，那倒不奇，奇在他居然说得出来历，知道其中两道来自不戒和尚。”<br>    桃干仙怒道：“为什么我们六人的较弱，不戒贼秃的较强？明明是我们的强，他的弱！”平一指冷笑道：“好不要脸！他一个人的两道真气，压住了你们六个人的，难道还是你们较强？不戒和尚这老混蛋，武功虽强，却毫无见识，他妈的，老混蛋！” </p><p>​    岳不群夫妇又对望一眼，均想：“什么人这么大的面子，居然请得动‘杀人名医’到病人处来出诊？这人跟冲儿又有什么交情？” </p><p>令狐冲双手接过，说道：“多谢。”平一指转过身来，正欲上岸，忽然又回头道：“瓶里还有两粒，索性都给了你罢。”令狐冲不接，说道：“前辈如此珍视，这药丸自有奇效，不如留着救人。晚辈多活十日八日，于人于己，都没什么好处。”<br>    平一指侧头又瞧了令狐冲一会，说道：“生死置之度外，确是大丈夫本色。原来如此，怪不得，怪不得！唉，可惜，可惜！惭愧，惭愧！”一颗大头摇了几摇，一跃上岸，快步而去。 </p><p>令狐冲凄然一笑，说道：“这位祖先生是个豪爽汉子，谅他也不会暗算于我。”内心深处，似乎反盼望酒中有毒，自己饮下即死，尸身躺在岳灵珊眼前，也不知她是否有点儿伤心？当即又喝了两杯。这第六杯酒又酸又咸，更有些臭味，别说当不得“美酒”两字，便连这“酒”字，也加不上去。他吞下肚中之时，不由得眉头微微一皱。 </p><h3 id="第16章-灌药"><a href="#第16章-灌药" class="headerlink" title="第16章 灌药"></a>第16章 灌药</h3><p>​    岳灵珊道：“如此说来，你心里毕竟是有点疑心了。”林平之道：“千万别说这等话，要是给大师哥知道了，岂不伤了同门义气？”岳灵珊冷笑一声，道：“偏你便有这许多做作！疑心便疑心，不疑心便不疑心，换作是我，早就当面去问大师哥了。”她顿了一顿，又道：“你的脾气和爹爹倒也真像，两人心中都对大师哥犯疑，猜想他暗中拿了你家的剑谱……”林平之插口问道：“师父也在犯疑？”岳灵珊嗤的一笑，道：“你自己若不犯疑，何以用上这个‘也’字？我说你和爹爹的性格儿一模一样，就只管肚子里做功夫，嘴上却一句不提。” </p><p>令狐冲又惊又怒，正欲破口大骂，转念一想：“我吃了这姑娘的救命灵药，虽非有意，总之是我坏了大事，害了她性命。何况我本就不想活了，以我之血，救她性命，赎我罪愆，有何不可？”当下凄然一笑，并不说话。<br>    老头子站在他身旁，只待他一出声叫骂，立即点他哑穴，岂知他竟神色泰然，不以为意，倒也大出意料之外。他怎知令狐冲自岳灵珊移情别恋之后，本已心灰意懒，这晚听得那大汉大声斥责岳灵珊和林平之，骂他二人说自己坏话，又亲眼见到岳林二人在岸上树底密约相会，更觉了无生趣，于自己生死早已全不挂怀。 </p><h3 id="第17章-注血"><a href="#第17章-注血" class="headerlink" title="第17章 注血"></a>第17章 注血</h3><p>蓝凤凰拿起酒碗，喝了一大口，笑道：“我们苗人的规矩，倘若请朋友喝酒吃肉，朋友不喝不吃，那朋友就不是朋友啦。”<br>    令狐冲接过酒碗，骨嘟骨嘟的将一碗酒都喝下肚中，连那五条毒虫也一口吞下。他胆子虽大，却也不敢去咀嚼其味了。<br>    蓝凤凰大喜，伸手搂住他头颈，便在他脸颊上亲了两亲，她嘴唇上搽的胭脂在令狐冲脸上印了两个红印，笑道：“这才是好哥哥呢。”令狐冲一笑，一瞥眼间见到师父严厉的眼色，心中一惊，暗道：“糟糕，糟糕！我大胆妄为，在师父师娘跟前这般胡闹，非给师父痛骂一场不可。小师妹可又更加瞧我不起了。” </p><h3 id="第18章-倾心"><a href="#第18章-倾心" class="headerlink" title="第18章 倾心"></a>第18章 倾心</h3><p>平一指不等他回答，接着道：“搭你脉象，这又是情孽牵缠。其实天下女子言语无味，面目可憎，脾气乖张，性情暴躁，最好是远而避之。倘若命运不济，真正是上天入地，没法躲避，才只有极力容忍，虚与委蛇。你怎地如此想不通，反而对她们日夜想念？这可大大的不是了。虽然，虽然那……唉，可不知如何说起？”说着连连摇头。 </p><p>​    黄伯流忙陪笑道：“公子千万不可多心。唉，老黄生就一副茅包脾气，倘若事先问问俺儿媳妇，要不然问问俺孙女儿，也就不会得罪了人家，自家还不知道。唉，俺这粗人十七岁上就娶了媳妇，只怪俺媳妇命短，死得太早，连累俺对女人家的心事摸不上半点边儿。” </p><p>也不知过了多少时候，迷迷糊糊中听到几下柔和的琴声，神智渐复，琴声优雅缓慢，入耳之后，激荡的心情便即平复，正是洛阳城那位婆婆所弹的《清心普善咒》。令狐冲恍如漂流于茫茫大海之中，忽然见到一座小岛，精神一振，便即站起，听琴声是从草棚中传出，便一步一步的走过去，见草棚之门已然掩上。 </p><p>琴声丁东丁东的响了几下，曳然而止。令狐冲只觉这琴音中似乎充满了慰抚之意，听来说不出的舒服，明白世上毕竟还有一人关怀自己，感激之情霎时充塞胸臆。 </p><p>​    那婆婆道：“你吞了下去，到那棵大树下坐着歇歇。”令狐冲道：“是。”将药丸放入口中，吞了下去。那婆婆道：“我是要仗着你的神妙剑法护送脱险，这才用药物延你性命，免得你突然身死，我便少了个卫护之人。可不是对你……对你有什么好心，更不是想要救你性命，你记住了。” </p><p>令狐冲又应了一声，走到树下，倚树而坐，只觉丹田中一股热气暖烘烘的涌将上来，似有无数精力送入全身各处脏腑经脉，寻思：“这颗药丸明明于我身子大有补益，婆婆偏不承认对我有什么好心，只说不过是利用我而已。世上只有利用别人而不肯承认的，她却为什么要说这等反话？”又想：“适才她将药丸掷入我手掌，能使药丸入掌而不弹起，显是使上了极高内功中的一股沉劲。她武功比我强得多，又何必要我卫护？唉，她爱这么说，我便听她这么办就是。” </p><p>那婆婆听他不说话了，问道：“怎么？我这句话伤了你吗？你生气了，是不是？”令狐冲道：“没生气。你说得对，我说话没点正经，行事也没点正经，难怪小师妹不喜欢我，师父、师娘也都不喜欢我。”那婆婆道：“你不用难过，你师父、师娘、小师妹不喜欢你，难道……难道世上便没旁人喜欢你了？”这句话说得什是温柔，充满了慰藉之意。 </p><p>那姑娘听他不出声，说道：“你又生气了，是不是？堂堂男子汉，气量恁地窄小。”令狐冲道：“我不是生气，我是心中害怕，怕给你杀了。”那姑娘笑道：“你以后说话规规矩矩，谁来杀你了？”令狐冲叹了口气，道：“我生来就是个不能规规矩矩的脾气，这叫做无可奈何，看来命中注定，非给你杀了不可。”那姑娘一笑，道：“你本来叫我婆婆，对我恭恭敬敬地，那就很乖很好，以后仍是那样便了。”令狐冲摇头道：“不成！我既知你是个小姑娘，便不能再当你是婆婆了。”那姑娘道：“你……你……”说了两个“你”字，忽然脸上一红，不知心中想到了什么，便住口不说了。 </p><p>令狐冲低下头来，见到她娇羞之态，娇美不可方物，心中一荡，便凑过去在她脸颊上吻了一下。</p><p>令狐冲道：“你为什么生气？我说将来谁做了你的徒弟，可有得苦头吃了。”他本来想说“丈夫”，但一见情势不对，忙改说“徒弟”。盈盈自然知道原意，说道：“你这人既不正经，又不老实，三句话中，倒有两句颠三倒四。我……我不会强要人家怎么样，人家爱听我的话就听，不爱听呢，也由得他。”令狐冲笑道：“我爱听你的话。”这句话中也带有三分调笑之意。盈盈秀眉一蹙，似要发作，但随即满脸晕红，转过了头。 </p><p>三人半晌不语。令狐冲心中疑团愈多，只听得祖千秋叹了口气，道：“只盼令狐公子伤势早愈，圣姑尽早和他成为神仙眷属。他二人一日不成亲，江湖上总是难得安宁。”<br>    令狐冲大吃一惊，偷眼向盈盈瞧去，夜色朦胧中隐隐可见她脸上晕红，目光中却射出了恼怒之意。令狐冲生怕她跃出去伤害了老头子等三人，伸出右手，轻轻握住她左手，但觉她全身都在颤抖，也不知是气恼，还是害羞。 </p><p>祖千秋道：“咱们在五霸冈上聚集，圣姑竟然会生这么大的气。其实男欢女爱，理所当然。像令狐公子那样潇洒仁侠的豪杰，也只有圣姑那样美貌的姑娘才配得上。为什么圣姑如此了不起的人物，却也像世俗女子那般扭扭揑揑？她明明心中喜欢令狐公子，却不许旁人提起，更不许人家见到，这不是……不是有点不近情理吗？” </p><p>令狐冲心道：“原来如此。却不知此言是真是假？”突然觉到掌中盈盈那只小手一摔，要将自己手掌甩脱，忙用力握住，生怕她一怒之下，立时便将祖千秋等三人杀了。 </p><p>​    计无施道：“圣姑虽是黑木崖上了不起的人物，便东方教主，也从来对她没半点违拗，但她毕竟是个年轻姑娘。世上的年轻姑娘初次喜欢了一个男人，纵然心中爱煞，脸皮子总是薄的。咱们这次拍马屁拍在马脚上，虽是一番好意，还是惹得圣姑发恼，只怪大夥儿都是粗鲁汉子，不懂得女孩儿家的心事。来到五霸冈上的姑娘大嫂，本来也有这么几十个，偏偏她们的性子粗粗鲁鲁，跟男子汉可也没多大分别。五霸冈群豪聚会，拍马屁圣姑生气。这一回书传了出去，可笑坏了名门正派中那些狗崽子们。” </p><p>盈盈突然朗声道：“喂，三个胆大妄为的家伙，快滚得远远地，别惹姑娘生气！”<br>    令狐冲听她忽然开口说话，吓了一跳，使力抓住她手。 </p><p>盈盈站起身来，说道：“谁要你们到西域去？我有一件事，你们三个给我办一办。”计无施等三人大喜，齐声应道：“圣姑但请吩咐，小人自当尽心竭力。”盈盈道：“我要杀一个人，一时却找他不到。你们传下话去，那一位江湖上的朋友杀了此人，我重重酬谢。”祖千秋道：“酬谢是决不敢当，圣姑要取此人性命，我兄弟三人便追到天涯海角，也要寻到了他。只不知这贼子是谁，竟敢得罪了圣姑？”盈盈道：“单凭你们三人，耳目不广，须当立即传言出去。”三人齐声道：“是！是！”盈盈道：“你们去罢！”祖千秋道：“是。请问圣姑要杀的，是那一个大胆恶贼。”<br>    盈盈哼了一声，道：“此人复姓令狐，单名一个冲字，乃华山派门下弟子。” </p><p>盈盈顿足道：“都是你不好，教江湖上这许多人都笑话于我。倒似我一辈子……一辈子没人要了，千方百计的要跟你相好。你……你有什么了不起？累得我此后再也没脸见人。”令狐冲又哈哈一笑。盈盈怒道：“你还要笑我？还要笑我？”忽然哇的一声，哭了出来。 </p><p>盈盈眼见他越走越远，追了上来，叫道：“喂，你别走！”令狐冲道：“令狐冲跟姑娘在一起，只有累你，还是独自走了的好。”盈盈道：“你……你……”咬着嘴唇，心头烦乱之极，见他始终不肯停步，又奔近几步，说道：“令狐冲，你定要迫我亲口说了出来，这才快意，是不是？”令狐冲奇道：“什么啊？我可不懂了。”<br>    盈盈又咬了咬嘴唇，说道：“我叫祖千秋他们传言，是要你……要你永远在我身边，不能离开我一步。”说了这句话后，身子发颤，站立不稳。 </p><p>令狐冲大是惊奇，道：“你……你要我陪伴？”<br>    盈盈道：“不错！祖千秋他们把话传出之后，你只有陪在我身边，才能保全性命。没想到你这不顾死活的小子，竟一点不怕，那不是……那不是反而害了你么？” </p><p>令狐冲心下感激，寻思：“原来你当真是对我好，但对着那些汉子，却又死也不认。”转身走到她身前，伸手握住她双手，入掌冰凉，只觉她两只掌心都是冷汗，低声道：“你何苦如此？”盈盈道：“我怕。”令狐冲道：“怕什么？”盈盈道：“怕你这傻小子不听我话，当真要去江湖涉险，只怕过不了明天，便死在那些不值一文钱的臭家伙手下。” </p><p>令狐冲叹道：“那些人都是血性汉子，对你又是极好，你为什么对他们如此轻贱？”盈盈道：“他们在背后笑我，又想杀你，还不是该死的臭汉子？”令狐冲忍不住失笑，道：“是你叫他们杀我的，怎能怪他们了？再说，他们也没在背后笑你。你听计无施、老头子、祖千秋三人谈到你时，语气何等恭谨？那里有丝毫笑话你了？”盈盈道：“他们口里没笑，肚子里在笑。” </p><p>盈盈本来自大任性，但想到令狐冲每一刻都会突然死去，对他便加意温柔，千依百顺的服侍，偶尔忍不住使些小性儿，也是立即懊悔，向他赔话。 </p><p>这一日令狐冲吃了两个桃子，即感困顿，迷迷糊糊的便睡着了。睡梦中听到一阵哭泣之声，他微微睁眼，见盈盈伏在他脚边，不住啜泣。令狐冲一惊，正要问她为何伤心，突然心下明白：“她知我快死了，是以难过。”伸出左手，轻轻抚摸她秀发，强笑道：“别哭，别哭！我还有八十年好活呢，那有这么快便去西天。”<br>    盈盈哭道：“你一天比一天瘦，我……我……我也不想活了……” </p><h3 id="第19章-联手"><a href="#第19章-联手" class="headerlink" title="第19章 联手"></a>第19章 联手</h3><p>​    方证抬起头来，说道：“说什么大恩大德，深仇大恨？恩德是缘，冤仇亦是缘，仇恨不可执着，恩德亦不必执着。尘世之事，皆如过眼云烟，百岁之后，更有什么恩德仇怨？”方生应道：“是，多谢师兄指点。” </p><h3 id="第21章-探狱"><a href="#第21章-探狱" class="headerlink" title="第21章 探狱"></a>第21章 探狱</h3><p>黄锺公道：“风兄弟，你见这地牢阴暗潮湿，对这位任先生大起同情之意，因而对我们四兄弟什是不忿，这是你的侠义心肠，老夫也不来怪你。你可知道，这位任先生要是重入江湖，单是你华山一派，少说也得死去一大半人。任先生，我这话不错罢？” </p><p>那姓任的自不知他这声怒喝的真意，继续笑道：“华山门中，我瞧得起的人当然也有。风老是一个，小朋友你是一个。还有一个你的后辈，叫什么‘华山玉女’宁……宁什么的。啊，是了，叫作宁中则。这小姑娘倒也慷慨豪迈，是个人物，只可惜嫁了岳不群，一朵鲜花插在牛粪上了。”令狐冲听他将自己的师娘叫作“小姑娘”，不禁啼笑皆非，只好不加置答，总算他对师娘颇有好评，说她是个人物。<br>    那人问道：“小朋友，你叫什么名字？”令狐冲道：“晚辈姓风，名叫二中。” </p><p>令狐冲心想：“囚室如此窄小，如何比剑？”当下走到榻前，放下油灯，随手将向问天交给他的纸团和硬物轻轻塞入那人手中。<br>    那人微微一怔，接过纸团，朗声说道：“喂，你们四个家伙，进不进来观战？”黄锺公道：“地势狭隘，容身不下。”那人道：“好！小朋友，带上了门。”令狐冲道：“是！”转身将铁门推上。那人站起身来，身上发出一阵轻微的呛啷之声，似是一根根细小的铁炼自行碰撞作声。他伸出右手，从令狐冲手中接过一柄木剑，叹道：“老夫十馀年不动兵刃，不知当年所学的剑法还记不记得。” </p><p>黄锺公自不知对令狐冲的剑法却也高估了。“独孤九剑”是敌强愈强，敌人如武功不高，“独孤九剑”的精要处也就用不上。此时令狐冲所遇的，乃当今武林中一位惊天动地的人物，武功之强，已到了常人所不可思议的境界，一经他激发，“独孤九剑”中种种奥妙精微之处，方能发挥得淋漓尽致。独孤求败如若复生，又或风清扬亲临，能遇到这样的对手，也当欢喜不尽。使这“独孤九剑”，除了精熟剑诀剑术之外，极大部分依赖使剑者的灵悟，一到自由挥洒、更无规范的境界，使剑者聪明智慧越高，剑法也就越高，每一场比剑均无旧轨可循，便如是大诗人灵感到来，作出了一首好诗一般。 </p><h3 id="第22章-囚居"><a href="#第22章-囚居" class="headerlink" title="第22章 囚居"></a>第22章 囚居</h3><p>​    这一觉睡得什是畅快，醒转来时，顿觉精神饱满。过不多时，那老人又送饭来了。令狐冲对他什为同情，每次他托木盘从方孔中送进来，必去揑揑他手，或在他手背上轻拍数下，表示谢意，这一次仍然如此。他接了木盘，缩臂回转，突然之间，在微弱的灯光之下，只见自己左手手背上凸起了四个字，清清楚楚是“我行被困”四字。 </p><p>如此毫不间歇的散功，多练一刻，身子便舒服一些，心想：“我将桃谷六仙和不戒和尚的真气尽数散去之后，再照师父所传的法子，重练本门内功。虽然一切从头做起，要花上不少功夫，但我这条性命，只怕就此捡回来了。如向大哥终于来救我出去，江湖之上，岂不是另有一番天地？”忽尔又想：“师父既已将我逐出华山派，我又何必再练华山派内功？武林中各家各派的内功什多，我便跟向大哥学，又或是跟盈盈学，却又何妨？”心中一阵凄凉，又一阵兴奋。 </p><p>次日那老人送饭来时，令狐冲就着灯光一看，只见铁圈断口处有一条条细微的钢丝锯纹，显是有人以一条极细的钢丝锯子，将足镣手铐上四个铁圈都锯断了，断口处闪闪发光，并未生锈，铁圈锯断必是在不久以前，何以这些铁圈又合了拢来，套在自己手足上？“那多半有人暗中在设法救我。这地牢如此隐密，外人决计无法入来，救我之人必是梅庄中的人物。想来他不愿这等对我暗算，因此在我昏迷不醒之时，暗中用钢丝锯子将脚镣手铐锯开了。此人自不肯和梅庄中馀人公然为敌，只有觑到机会，再来放我出去。” </p><h3 id="第24章-伏击"><a href="#第24章-伏击" class="headerlink" title="第24章 伏击"></a>第24章 伏击</h3><p>定静师太一抬头，见到天边月亮，心中默祷：“菩萨保佑，让我恒山派诸弟子此次得能全身而退。弟子定静若能复归恒山，从此青灯礼佛，再也不动刀剑了。”<br>    她昔年叱咤江湖，着实干下了不少轰轰烈烈的事迹，但昨晚仙霞岭上这一战，局面之凶险，此刻思之犹有馀悸，所担心的是率领着这许多弟子，若她孤身一人，情境便再可怖十倍，也不放在心上，又再默祷：“大慈大悲、救苦救难观世音菩萨，如我恒山诸人此番非有损折不可，只让弟子定静一人身当此灾，诸般杀业报应，只由弟子一人承当。” </p><p>郑萼道：“那好极了！将军武艺高强，见识过人，若不是你带领我们去找，只怕难以找到。”令狐冲笑道：“‘武艺高强、见识过人’，这八个字倒说得不错。本将军将来挂帅平番，升官发财，定要送一百两白花花的银子，给你们三个小妞儿买新衣服穿。” </p><p>令狐冲道：“师太放心，你休养得几天，就会痊可。”定静师太道：“你……你答允了吗？”令狐冲见她双眼凝望着自己，满脸是企盼之色，唯恐自己不肯答允，便道：“师太如此吩咐，自当照办。”定静师太微微一笑，道：“阿弥陀佛，这副重担，我……我本来……本来是不配挑的。少侠……你到底是谁？”<br>  令狐冲见她眼神涣散，呼吸极微，已命在顷刻，不忍再瞒，凑嘴到她耳边，悄声道：“定静师伯，晚辈便是华山派门下弃徒令狐冲。”<br>  定静师太“啊”的一声，道：“你……你……多谢少侠……”颤巍巍的伸手抓住了他手，目光中尽是感激之意，忽然一口气转不过来，就此气绝。<br>  令狐冲叫道：“师太，师太。”探她鼻息，呼吸已停，不禁凄然。恒山派群弟子放声大哭，荒原之上，一片哀声。几枝火把掉在地下，逐次熄灭，四周登时黑沉沉地。 </p><p>仪清道：“将军，我们想眼前的第一件大事，是火化师父的遗体。此后如何行止，还请示下。”令狐冲摇头道：“和尚尼姑们的事情，本将军一窍不通，要我吩咐示下，当真瞎缠三官经了。本将军升官发财，最是要紧，这就去也！”迈开大步，疾向北行。众弟子大叫：“将军，将军！”令狐冲那去理会？他转过山坡后，便躲在一株树上，直等了两个多时辰，才见恒山一众女弟子悲悲切切的上路。他远远跟在后面，暗中保护。 </p><h3 id="第25章-蒙冤"><a href="#第25章-蒙冤" class="headerlink" title="第25章 蒙冤"></a>第25章 蒙冤</h3><p>突然之间，一个极熟悉的声音钻进耳中：“小林子，你到底陪不陪我去喝酒？”<br>    令狐冲登时胸口热血上涌，脑中一阵晕眩。他千里迢迢的来到福建，为的就是想听到这声音，想见到这声音主人的脸庞。可是此刻当真听见了，却不敢转过头去。霎时之间，竟似泥塑木雕般呆住了，泪水涌到眼眶之中，望出来模糊一片。 </p><p>​    令狐冲慢慢转过身来，只见岳灵珊苗条的背影在左，林平之高高的背影在右，二人并肩而行。岳灵珊穿件湖绿衫子，翠绿裙子。林平之穿的是件淡黄色长袍。两人衣履鲜洁，单看背影，便是一双才貌相当的璧人。令狐冲胸口便如有什么东西塞住了，几乎气也透不过来。他和岳灵珊一别数月，虽思念不绝，但今日一见，才知对她相爱之深。他手按剑柄，恨不得抽出剑来，就此横颈自刎。突然之间，眼前一黑，只觉天旋地转，一交便坐倒在街上。 </p><p>又想：“原来盈盈是任教主的女儿，怪不得老头子、祖千秋他们对她如此尊崇。她随口一句话，便将许多江湖豪士充军到东海荒岛，七八年不得回归中原。唉，我原该想到才是。武林之中，除了魔教的大头脑，又有谁能有这等权势？但她和我在一起之时，扭扭揑揑，娇羞腼腆，比之小师妹尚且胜了三分，又怎想得到她竟是魔教中的大人物？然而那时任教主尚给东方不败囚在西湖底下，他的女儿又怎会有偌大权势？”<br>    正自思涌如潮，起伏不定，忽听得脚步声细碎，一人闪进房来，正是他日思夜想、念兹在兹的小师妹。令狐冲叫道：“小师妹！你……”下面的话便接不下去了。岳灵珊道：“大师哥，快……快离开这儿，嵩山派的人找你晦气来啦。”语气什是焦急。<br>    令狐冲只一见到她，天大的事也都置之脑后，什么嵩山派不嵩山派，压根儿便没放在心上，双眼怔怔的瞧她，一时甜、酸、苦、辣，诸般滋味尽皆涌向心头。 </p><p>​    岳不群脸色铁青，怒道：“你……你干什么？”岳夫人急叫：“冲儿，快走！快走！”令狐冲摇头道：“我不走，师父要杀我，便杀好了。我是罪有应得。”岳夫人顿足道：“有我在这里，他杀不了你的，快走，走得远远的，永远别再回来。”<br>​    岳不群道：“哼，他一走了之，外面厅上嵩山派那三人，咱们又如何对付？” </p><p>劳德诺闪身而出，喝道：“你嘴里不乾不净的说些什么？我五岳剑派本来同气连枝，一派有事，四派共救。可是你们和令狐冲这魔教妖人勾结在一起，行事鬼鬼祟祟，我师父自要考虑周详。你们先得把令狐冲这妖人杀了，表明清白。否则我华山派可不能跟你恒山派同流合污。”<br>    仪和大怒，踏上一步，手按剑柄，朗声问道：“你说什么‘同流合污’？”劳德诺道：“你们跟魔教勾勾搭搭，那便是同流合污了。”仪和怒道：“这位令狐大侠见义勇为，急人之难，那才是真正的大英雄、大丈夫，那像你们这种人，自居豪杰，其实却是见死不救、临难苟免的伪君子！” </p><p>​    岳不群脸色铁青，接过一看，果然便是本派历祖相传的内功秘笈，幸喜书页完整，未遭损坏，恨恨的道：“都是你不好，拿了去给人，才会给劳德诺偷去。”<br>​    仪和口舌上不肯饶人，大声道：“这才叫同流合污呢！” </p><h3 id="第26章-闻讯"><a href="#第26章-闻讯" class="headerlink" title="第26章 闻讯"></a>第26章 闻讯</h3><p>定闲师太缓缓的道：“贵派意欲将五岳剑派合而为一，并成一个五岳派。贫尼以恒山派传世数百年，不敢由贫尼手中而绝，拒却了贵派的倡议。此事本来尽可从长计议，何以各位竟冒充魔教，痛下毒手，要将我恒山派尽数诛灭。如此行事，那不是太霸道了些吗？” </p><p>​    定逸师太不耐烦去听仪文述说往事，双目瞪着令狐冲，突然说道：“你……你很好啊。你师父为什么将你逐出门墙？说你和魔教勾结？”令狐冲道：“弟子交游不慎，确是结识了几个魔教中的人物。”定逸师太哼了一声，道：“像嵩山派这等狼子野心，却比魔教更加不如了。哼，正教中人，就一定比魔教好些吗？” </p><p>定闲师太一直在闭目养神，这时缓缓睁开眼来，说道：“敝派数遭大难，均蒙令狐少侠援手，这番大恩大德……”令狐冲忙道：“弟子稍效微劳，师伯之言，弟子可万不敢当。”定闲师太摇了摇头，道：“少侠何必过谦？岳师兄不能分身，派他大弟子前来效力，那也是一样。仪和，可不能胡言乱语，对尊长无礼。”仪和躬身道：“是，弟子不敢了。不过……不过令狐师兄已给逐出华山派，岳师伯早已不要他了。他也不是岳师伯派来的。”定闲师太微微一笑，道：“你就是不服气，定要辩个明白。” </p><p>只听得脚步声细碎，两人缓缓走近，却是仪琳和郑萼，走到离令狐冲二三丈外，叫了声：“令狐师兄。”便停住了脚步。令狐冲迎将上去，说道：“你们也给惊醒了？”仪琳道：“令狐师兄，掌门师伯吩咐我们来跟你说……”推了推郑萼，道：“你跟他说。”郑萼道：“掌门师伯要你说的。”仪琳道：“你说也是一样。”<br>    郑萼说道：“令狐师兄，掌门师伯说道，大恩不言谢，今后你不论有什么事，恒山派都供你驱策。你如要去少林寺救那位任大小姐，大家自当尽力效命。”<br>    令狐冲大奇，心想：“我又没说要去相救盈盈，怎地定闲师太却恁地说？啊哟，是了！群雄在五霸冈上聚会，设法为我治病，都是瞧在盈盈的份上。此事闹得沸沸扬扬，定闲师太焉有不知？”想及此事，不由得脸上一红。 </p><p>郑萼又道：“掌门师伯说道，此事最好不要硬来。她老人家和我师父两位，此刻已过江去了，要赶赴少林寺，去向方丈大师求情放人，请令狐师兄带同我们，缓缓前去。”<br>    令狐冲听了这番话，登时呆了，半晌说不出话来，举目向长江中眺望，果见一叶小舟，挂起了一张小小白帆，正自向北航去，心中又感激，又觉惭愧，心想：“两位师太是佛门中有道大德，又是武林高人。她们肯亲身去向少林派求情，原是再好不过，比之我这浪迹江湖、素行不端的一介无名小卒，面子是大上百倍了。多半方证方丈能瞧着二位师太的金面，肯放了盈盈。”想到此处，心下登时一宽。 </p><p>令狐冲转过头来，避开她眼光，只见仪琳坐在船舱一角，脸色苍白，神情什为冷漠，不禁心中一动：“她心中在想什么？为什么她不和我说话？”怔怔的瞧着她，忽然想到那日在衡山城外，自己受伤之后，她抱了自己在旷野中奔跑时的脸色。那时她又关切，又激动，浑不是眼前这般百事不理的模样。为什么？为什么？ </p><p>令狐冲心中只盼改行陆道，及早得知盈盈的讯息，但斜眼一睨，见仪琳长长的睫毛下闪动着泪水，一副楚楚可怜的模样，说道：“掌门师太叫咱们缓缓行去，那么还是仍旧坐船罢。谅来那白蛟帮也不敢对咱们怎地。”秦绢笑道：“你放心得下吗？”令狐冲脸上微微一红，尚未作答，仪和喝道：“秦师妹，小孩儿家，少说几句行不行？”秦绢笑道：“行！有什么不行？阿弥陀佛，我可不大放心。” </p><p>端起酒碗，又一饮而尽，小店之中无下酒物，随手抓起几粒咸水花生，抛入口中，忽听背后有人叹了口气，说道：“唉！天下男子，十九薄幸。”<br>    令狐冲转过面来，向说话之人瞧去，摇晃的烛光之下，但见小酒店中除自己之外，便只店角落里一张板桌旁有人伏案而卧。板桌上放了酒壶、酒杯，那人衣衫褴褛，身形猥葸，不像是如此吐属文雅之人。当下令狐冲也不理会，又喝了一碗酒，只听得背后那声音又道：“人家为了你，给幽禁在不见天日之处。自己却整天在脂粉堆中厮混，小姑娘也好，光头尼姑也好，老太婆也好，照单全收。唉，可叹啊可叹！” </p><p>令狐冲知他说的是自己，却不回头，寻思：“这人是谁？他说‘人家为了你，给幽禁在不见天日之处’，说的是盈盈吗？为什么盈盈是为了我而给人幽禁？” </p><p>只听那人又道：“不相干之辈，倒是多管闲事，说要去拚了性命，将人救出来。偏生你要做头子，我也要做头子，人还没救，自己夥里已打得昏天黑地。唉，这江湖上的事，老子可真没眼瞧的了。”<br>    令狐冲拿着酒碗，走过去坐在那人对面，说道：“在下多事不明，要请老兄指教。” </p><p>那人仍伏在桌上，并不抬头，说道：“唉，有多少风流，便有多少罪孽。恒山派的姑娘、尼姑们，这番可当真糟糕之极了。” </p><p>令狐冲更是心惊，站起身来，深深一揖，说道：“令狐冲拜见前辈，还望赐予指点。”突然见到那人茹脚旁放着一把胡琴，琴身深黄，久经年月，心念一动，已知此人是谁，当即俯身便拜，说道：“晚辈令狐冲，有幸拜见衡山莫师伯。”</p><p>那人抬起头来，双目如电，冷冷的在令狐冲脸上一扫，正是衡山派掌门“潇湘夜雨”莫大先生。他哼了一声，道：“师伯之称，可不敢当。令狐大侠，这些日来可快活哪！”<br>    令狐冲躬身道：“莫师伯明鉴，弟子奉定闲师伯之命，随同恒山派诸位师姊师妹回归恒山。弟子虽然无知，却决不敢对恒山师姊妹们有丝毫失礼。”莫大先生叹了口气，道：“请坐！唉，你怎不知江湖上人言纷纷，众口铄金？”令狐冲苦笑道：“晚辈行事狂妄，不知检点，连本门也不能容，江湖上的闲言闲语，却也顾不得这许多了。” </p><p>莫大先生冷笑道：“你自己甘负浪子之名，旁人自也不来理你。可是恒山派数百年的清誉，竟败坏在你手里，你也毫不动心吗？江湖上传说纷纭，说你一个大男人，混在恒山派一群姑娘和尼姑中间。别说几十位黄花闺女的名声给你损了，什至连……连那几位苦守戒律的老师太，也给人作为笑柄，这……这可太不成话了。”<br>    令狐冲退开两步，手按剑柄，说道：“不知是谁造谣，说这些无耻荒唐的言语，请莫师伯示知。”莫大先生道：“你想去杀了他们吗？江湖上说这些话的，没有一万，也有八千，你杀得乾净么？哼，人家都羡慕你艳福齐天，那又有什么不好了？” </p><p>令狐冲颓然坐下，心道：“我做事总是不顾前，不顾后，但求自己问心无愧，却没想到累了恒山派众位上下的清誉。这……这便如何是好？” </p><p>莫大先生叹了口气，温言道：“这五日里，每天晚上，我都曾到你船上窥探……”令狐冲“啊”的一声，心想：“莫师伯接连五晚来船窥探，我竟半点不知，可算是十分无能。”莫大先生续道：“我见你每晚总是在后梢和衣而卧，别说对恒山众弟子并没分毫无礼的行为，连闲话也不说一句。令狐世兄，你不但决不是无行浪子，实是一位守礼君子。对着满船妙龄尼姑、如花少女，你竟绝不动心，不仅是一晚不动心，而且是数十晚始终如一。似你这般男子汉、大丈夫，当真是古今罕有，我莫大好生佩服。”大拇指一翘，右手握拳，在桌上重重一击，说道：“来来来，我莫大敬你一杯。”说着便提起酒壶斟酒。 </p><p>令狐冲道：“莫师伯之言，倒教小侄好生惶恐。小侄品行不端，以致不容于师门，但恒山派同道的师姊师妹，却如何可以得罪？”莫大先生呵呵笑道：“光明磊落，这才是男儿汉的本色。我莫大如年轻二十岁，教我晚晚陪着这许多姑娘，要像你这般守身如玉，那就办不到。难得啊难得！来，乾了！”两人举碗一饮而尽，相对大笑。 </p><p>令狐冲见莫大先生形貌落拓，衣饰寒酸，那里像是一位威震江湖的一派掌门？偶尔眼光一扫，锋锐如刀，但这霸悍之色一露即隐，又成为一个久困风尘的潦倒汉子，心想：“恒山掌门定闲师太慈祥平和，泰山掌门天门道长威严厚重，嵩山掌门左冷禅阴鸷险刻，我恩师是位彬彬君子，这位莫师伯外表猥葸平庸，似是个市井小人，实则武功惊人，可骇可怖。五岳剑派的五位掌门人，其实个个是十分深沉多智之人。我令狐冲草包一个，可跟他们差得远了。” </p><p>令狐冲心想，那日在衡山城外，莫大先生施展神妙剑法杀了费彬，他当日明明见到自己在旁，此刻却又如此说，自是不愿留下了形迹，便道：“嵩山派门下行事令人莫测高深，这费彬嘛，说不定是在嵩山那一处山洞中隐居了起来，正在勤练剑法，也未可知。”<br>    莫大先生眼中闪出一丝狡狯的光芒，微微一笑，拍案叫道：“原来如此，若不是老弟提醒，我可想破了脑袋，也想不通其中缘由。”喝了一口酒，问道：“令狐老弟，你到底何以跟恒山派的人混在一起？魔教的任大小姐对你情深一往，你可千万不能辜负她啊。” </p><p>令狐冲脸上一红，说道：“莫师伯明鉴，小侄情场失意，于这男女之事，可早已瞧得淡了。”想起了小师妹岳灵珊，胸口一酸，眼眶不由得红了，突然哈哈一笑，朗声说道：“小侄本想看破红尘，出家为僧，就怕出家人的戒律太严，五大戒之一便是不准喝酒，这才没去做和尚。哈哈，哈哈！”虽是大笑，笑声中毕竟大有凄凉之意。过了一会，便叙述如何遇到定静、定闲、定逸三位师太的经过，说到自己如何出手援救，每次都只轻描淡写的随口带过。 </p><p>莫大先生静静听完，瞪着酒壶呆呆出神，过了半晌，才道：“左冷禅意欲吞并四派，联成一个大派，企图和少林、武当两大宗派鼎足而三，分庭抗礼。他这密谋由来已久，虽然深藏不露，我却早已瞧出了些端倪。操他奶奶的，他不许我刘师弟金盆洗手，暗助华山剑宗去和岳先生争夺掌门之位，归根结底，都是为此。只是没想到他居然如此胆大妄为，竟敢对恒山派明目张胆的下手。” </p><p>令狐冲道：“他倒也不是明目张胆，原本是假冒魔教，要逼得恒山派无可奈何之下，不得不答允并派之议。”<br>    莫大先生点头道：“不错。他下一步棋子，当是去对付泰山派天门道长了。哼，魔教虽毒，却也未必毒得过左冷禅。令狐兄弟，你现下已不在华山派门下，闲云野鹤，无拘无束，也不必管他什么正教魔教。我劝你和尚倒也不必做，也不用为此伤心，尽管去将那位任大小姐救了出来，娶她做老婆便是。别人不来喝你的喜酒，我莫大偏来喝你三碗。他奶奶的，怕他个鸟卵蛋？”他有时出言什是文雅，有时却又夹几句粗俗俚语，说他是一派掌门，也真有些不像。 </p><p>令狐冲心想：“他只道我情场失意乃是为了盈盈，但小师妹之事，也不便跟他提起。”便问：“莫师伯，到底少林派为什么要拘留任小姐？”<br>    莫大先生张大了口，双眼直视，脸上充满了惊奇之状，道：“少林派为什么要拘留任小姐？你当真不知，还是明知故问？江湖上众人皆知，你……你……还问什么？” </p><p>令狐冲道：“过去数月之中，小侄为人囚禁，江湖上之事一无所闻。那任小姐曾杀过少林派四名弟子，原也是从小侄身上而起，只不知后来怎地失手，竟为少林派所擒？”<br>    莫大先生道：“如此说来，你是真的不明白其中原委了。你身中奇异内伤，无药可治，听说旁门左道中有数千人聚集五霸冈，为了讨好这位任大小姐而来治你的伤，结果却人人束手无策，是也不是？”令狐冲道：“正是。”莫大先生道：“这件事轰传江湖，都说令狐冲这小子不知几生修来的福气，居然得到黑木崖圣姑任大小姐的垂青，就算这场病医不好，也是不枉的了。”令狐冲道：“莫师伯取笑了。”心想：“老头子、黄伯流他们虽是一番好意，毕竟行事太过鲁莽，这等张扬其事，难怪盈盈生气。” </p><p>莫大先生问道：“你后来怎地却好了？是修习了少林派《易筋经》神功，是不是？”<br>    令狐冲道：“不是。少林寺方丈方证大师慈悲为怀，不念旧恶，答允传授少林派无上内功。只是小侄不愿改投少林派，而这门少林神功又不能传授派外之人，只好辜负了方丈大师的一番美意。”莫大先生道：“少林派是武林中的泰山北斗。你其时已给逐出华山门墙，正好改投少林。那是千载难逢的机缘，却为何连自己性命也不顾了？”令狐冲道：“小侄自幼蒙恩师、师娘收留，养育之恩，粉身难报，只盼日后恩师能许小侄改过自新，重列门墙，决不愿贪生怕死，另投别派。” </p><p>莫大先生点头道：“这也有理。如此说来，你的内伤得愈，那是由于另一桩机缘了。”令狐冲道：“正是。其实小侄的内伤也没完全治好。”<br>    莫大先生凝视着他，说道：“少林派和你向来并无渊源，佛门中人虽说慈悲为怀，却也不能随便传人以本门的无上神功。方证大师答应以《易筋经》相授，你当真不知是什么缘故吗？”令狐冲道：“小侄确是不知，还望莫师伯示知。” </p><p>莫大先生道：“好！江湖上都说，那日黑木崖任大小姐亲身背负了你，来到少林寺中，求见方证大师，说道只须方丈救了你的性命，她便任由少林派处置，要杀要剐，绝不皱眉。” </p><p>令狐冲“啊”的一声，跳了起来，将桌上一大碗酒都带翻了，全身登时出了一阵冷汗，手足发抖，颤声道：“这……这……这……”脑海中一片混乱，想起当时自己身子一日弱似一日，一晚睡梦之中，听到盈盈哭泣什哀，说道：“你一天比一天瘦，我……我……”说得诚挚无比，自己心中感激，狂吐鲜血，就此人事不知。待得清醒，已是在少林寺的一间斗室之中，方生大师已费了无数心力为己施救。自己一直不知如何会到少林寺中，又不知盈盈到了何处，原来竟是她舍命相救，不由得热泪盈眶，跟着两道眼泪扑簌簌的直流下来。 </p><p>莫大先生叹道：“这位任大小姐虽出身魔教，但待你的至诚至情，却令人好生相敬。少林派中，辛国梁、易国梓、黄国柏、觉月禅师四名大弟子命丧她手。她去到少林，自无生还之望，但为了救你，她……她是全不顾己了。方证大师不愿就此杀她，却也不能放她，因此将她囚禁在少林寺后的山洞之中。任大小姐属下那许多三山五岳之辈，自然都要去救她出来。听说这几个月来，少林寺没一天安宁，擒到的人，少说也有一百来人了。” </p><p>莫大先生这么一笑，令狐冲登时满脸通红，情知他这番话不错，但群豪服了自己，只不过是瞧在盈盈的面上，而盈盈日后知道，定要大发脾气，突然间心念一动：“盈盈对我情意深重，可是她脸皮子薄，最怕旁人笑话于她，说她对我落花有意，而我却流水无情。我要报答她这番厚意，务须教江湖上好汉众口纷传，说道令狐冲对任大小姐一往情深，为了她性命也不要了。我须孤身去闯少林，能救得出她来，那是最好；倘若救不出，也要闹得众所周知。”说道：“恒山派定闲、定逸两位师伯上少林寺去，便是向少林方丈求情，请他放了这位任小姐出来，以免酿成一场大动干戈的流血浩劫。” </p><p>莫大先生点头道：“怪不得，怪不得！我一直奇怪，定闲师太如此老成持重之人，怎会放心由你陪伴她门下这大群姑娘、尼姑，自己却另行他往，原来是为你作说客去了。” </p><p>令狐冲道：“莫师伯，小侄既知此事，着急得了不得，恨不得插翅飞去少林寺，瞧瞧两位师太求情的结果如何。只恒山派这些师姊妹都是女流之辈，倘若途中遇上了什么意外，可又难处。”<br>    莫大先生道：“你尽管去好了！”令狐冲喜道：“我先去不妨？”莫大先生不答，拿起倚在板茹旁的胡琴，咿咿呀呀的拉了起来。<br>    令狐冲知他既这么说，便是答允照料恒山派一众弟子了，这位莫师伯武功识见，俱皆非凡，不论他明保还是暗护，恒山派自可无虞，当即躬身行礼，说道：“深感大德。”<br>    莫大先生笑道：“五岳剑派，同气连枝。我帮恒山派的忙，要你来谢什么？那位任大小姐得知，只怕要喝醋了。”<br>    令狐冲道：“小侄告辞。恒山派众位师姊妹，相烦莫师伯代为知照。”说着直冲出店。一凝步，向江中望去，只见坐船的窗中透出灯光，倒映在汉水之中，一条黄光，缓缓闪动。身后小酒店中，莫大先生的琴声渐趋低沉，静夜听来，什是凄清。</p><h3 id="第27章-围寺"><a href="#第27章-围寺" class="headerlink" title="第27章 围寺"></a>第27章 围寺</h3><p>令狐冲脸上一红，想起那日盈盈要老头子等传言江湖，务须将自己杀了，她是既盼自己再不离开她身边，又要群豪知道，她任大小姐决非痴恋令狐冲，反而恨他入骨。此后多经变故，早将当时这话忘了，此刻听老头子这么说，才想起她这号令尚未通传取消。 </p><p>当时老头子等传言出去，群豪已然不信，待得她为救令狐冲之命，甘心赴少林寺就死，这事由少林寺俗家弟子泄漏了出来，登时轰动江湖。人人固赞她情深义重，却也不免好笑，觉这位大小姐太也要强好胜，明明爱煞了人家却又不认，拚命掩饰，不免欲盖弥彰。这事不但魔教属下那些左道旁门的好汉们知之什详，连正派中人也多有所闻，日常闲谈往往引为笑柄。此刻群豪突见令狐冲出现，惊喜交集之际，却也有些不知所措。 </p><p>老头子道：“令狐公子，圣姑有令，叫我们将你杀了。但你武功什高，适才我这一刀砍你不中，承你手下留情，没取我性命，足感盛情。众位朋友，大家亲眼目睹，咱们决不是不肯杀令狐公子，实在是杀他不了。我老头子不行，当然你们也都不行的了。是不是？”众人哈哈大笑，都道：“正是！” </p><p>令狐冲慨然道：“是谁当盟主，那是小事一件，只须救得圣姑出来，在下便粉身碎骨，也所甘愿。”这几句话倒不是随口胡诌，他感激盈盈为己舍身，若要他为盈盈而死，那是一往无前，决不用想上一想。不过如在平日，这念头在自己心头思量也就是了，不用向人宣之于口，此刻却要拚命显得多情多义，好叫旁人不去笑话盈盈。<br>    群豪一听，更加心下大慰，觉得圣姑看中此人，眼光确实不错。<br>    那白发老者笑道：“原来令狐公子果然是位有情有义的英雄，若如江湖上所讹传，说道令狐公子置身事外，全不理会，可教众人心凉了。”<br>    令狐冲道：“这几个月来，在下失手身陷牢笼，江湖上的事情一概不知。既会不到圣姑，又全不知她讯息，日夜思念，想得头发也白了。来来来，在下敬众位朋友一杯，衷心感谢各位为圣姑出力。”说着站起身来，举杯一饮而尽。群豪也都乾了。 </p><p>令狐冲道：“众位朋友，咱们这次去迎接圣姑，并相救失陷在少林寺中的许多朋友。少林寺乃武林中的泰山北斗，少林七十二绝技数百年来驰名天下，任何门派都不能与之抗衡。但咱们人多势众，除了这里已有千馀位英雄之外，尚有不少好汉前来。咱们的武功就算暂且不及少林寺僧俗弟子，十个打一个，总也打赢了。”<br>    众人轰叫：“对，对！难道少林寺的和尚真有三头六臂不成？”<br>令狐冲又道：“可是少林寺的大师们虽留住了圣姑，却也没难为于她。寺中大师们都是有道高僧，慈悲为怀，令人好生相敬。咱们纵然将少林寺毁了，只怕江湖上的好汉要说我们倚多为胜，不是英雄所为。因此依在下之见，咱们须得先礼后兵，如能说得少林寺让了一步，对圣姑和其他朋友们不再留难，免了一场争斗，那便再好不过。” </p><p>那老者点头道：“年纪轻轻，身负绝艺而不骄，也真难得。令狐公子，你曾得华山风清扬前辈的亲传吗？”令狐冲心头一惊：“他目光好生厉害，竟知道我所学的来历。我虽不能吐露风太师叔的行迹，但他既直言相询，可不能撒谎不认。”说道：“晚辈有幸，曾学得风太师叔剑术的一些皮毛。”这句话模棱两可，并不直认曾得风清扬亲手传剑。 </p><p>那老者微笑道：“皮毛，皮毛！嘿嘿，风前辈剑术的皮毛，便已如此了得么？”从挑柴汉手中接过长剑，握在左手，说道：“我便领教一些风老前辈剑术的皮毛。” </p><p>想到此处，登时胸口热血上涌，说道：“晚辈若不能将任小姐救出少林寺，枉自为人。此事不论成败若何，晚辈若还留得命在，必当上武当山真武观来，向冲虚道长和前辈叩谢。”<br>    那老者叹了口气，说道：“你不以性命为重，不以师门为重，不以声名前程为重，一意孤行，便为了这魔教妖女。将来她若对你负心，反脸害你，你也不怕后悔吗？”<br>    令狐冲道：“晚辈这条性命，是任小姐救的，将这条命还报了她，又有何足惜？” </p><p>突然之间，一阵朔风从门中直卷进来，吹得神座前的帷子扬了起来，风势猛烈，香炉中的香灰飞得满殿都是。令狐冲步到殿口，只见天上密云如铅，北风什紧，心想：“这早晚便要下大雪了。”心中刚转过这个念头，半空已有一片片雪花飘下，又忖：“天寒地冻，不知盈盈身上可有寒衣？少林派人多势众，部署又如此周密。咱们这些人都是一勇之夫，要想救盈盈出来，只怕是千难万难了。”负手背后，在殿前长廊上走来走去，一片片细碎的雪花飘在头上、脸上、衣上、手上，迅即融化。 </p><p>计无施道：“我自然知道公子义薄云天，决不肯舍众独行。但人人在此就义，将来由谁来为大夥儿报此大仇？圣姑困于苦狱，又有谁去救她重出生天？”<br>    令狐冲嘿嘿一笑，说道：“原来计兄要我独自下山逃命，此事再也休提。大夥儿死就死了，又怎能理会得这许多？世人有谁不死？咱们一起死了，圣姑困在狱中，将来也就死了。正教门派今日虽然得胜，过得数十年，他们还不是一个个都死了？胜负之分，也不过早死迟死之别而已。” </p><h3 id="第28章-三战"><a href="#第28章-三战" class="headerlink" title="第28章 三战"></a>第28章 三战</h3><p>​    岳不群淡然道：“晚生贱名，原不足以辱任先生清听。”任我行道：“岳先生，我向你打听一个人，不知可知他下落。听说此人从前是你华山派门下。”岳不群道：“任先生要问的是谁？”任我行道：“此人武功既高，人品又世所罕有。有些睁眼瞎子妒忌于他，出力将他排挤，我姓任的却跟他一见如故，觉得他是个少年英雄，一心一意要将我这宝贝女儿许配给他……” </p><p>令狐冲听方证大师亲口说及当日盈盈背负自己上山求救的情景，心下好生感激，此事虽早已听人说过，但从方证大师口中说出，而盈盈又直承其事，比之闻诸旁人之口，又自不同，不由得眼眶湿润。 </p><p>任我行道：“不过在我所佩服的人中，大和尚的排名还不是第一。我所佩服的当世第一位武林人物，是篡了我日月神教教主之位的东方不败。”<br>    众人都“啊”的一声，显然大出意料之外。令狐冲幸而将这“啊”字忍住了，心想他为东方不败所算，遭囚多年，定然恨之入骨，那知竟然对之不胜佩服。<br>    任我行道：“老夫武功既高，心思又机敏之极，只道普天下已无抗手，不料竟会着了东方不败的道儿，险些葬身湖底，永世不得翻身。东方不败如此厉害的人物，老夫对他怎不佩服？”方证道：“那也说得是。” </p><p>​    任我行道：“第三位我所佩服的，乃当今华山派的绝顶高手。”令狐冲又大出意料之外，他适才言语之中，对岳不群不留半分情面，那知他内心竟会对之颇为佩服。<br>​    岳夫人道：“你不用说这等反语，讥刺于人。”<br>​    任我行笑道：“哈哈，岳夫人，你还道我说的是尊夫么？他……他可差得远了。我所倾倒佩服的，乃是剑术通神的风清扬风老先生。风老先生剑术比我高明得多，非老夫所及，我是衷心佩服，决无虚假。” </p><p>方证问道：“岳先生，难道风老先生还在人世么？”<br>    岳不群道：“风师叔于数十年前便已……便已归隐，与本门始终不通消息。他老人家倘若尚在人世，那可真是本门的大幸。” </p><p>任我行冷笑道：“风老先生是剑宗，你是气宗。华山派剑气二宗势不两立。他老人家仍在人世，于你何幸之有？”岳不群给他这几句抢白，默然不语。 </p><p>任我行笑道：“你放心。风老先生是世外高人，你还道他希罕你这华山派掌门，会来抢你的宝座么？”岳不群道：“在下才德庸驽，若得风师叔耳提面命，真是天大的喜事。任先生，你可能指点一条明路，让在下去拜见风师叔。华山门下尽感大德。”说得什是恳切。<br>    任我行道：“第一，我不知风老先生在那里。第二，就算知道，也决不跟你说。明枪易躲，暗箭难防。真小人容易对付，伪君子可叫人头痛得很。”岳不群不再说话。 </p><p>任我行道：“不用客气。”转头向左冷禅道：“左大掌门，你倒不必脸上含笑，肚里生气，你虽不属我佩服之列，但在我不佩服的三个半高人之中，阁下却居其首。”左冷禅笑道：“在下受宠若惊。”任我行道：“你武功了得，心计也深，很合老夫的脾胃。你想合并五岳剑派，要与少林、武当鼎足而三，才高志大，也算了不起。可是你鬼鬼祟祟，安排下种种阴谋诡计，不是英雄豪杰的行径，可教人十分的不佩服。” </p><p>​    左冷禅道：“在下所不佩服的当世三个半高人之中，阁下却只算得半个。”任我行道：“拾人牙慧，全无创见，因此你就不令人佩服了。你所学嵩山派武功虽精，却全是前人所传。依你的才具，只怕这些年中，也不见得有什么新招创出来。” </p><p>他眼光慢慢转过去，只见盈盈倚在柱上，娇怯怯地一副弱不禁风模样，秀眉微蹙，若有深忧，突然间怜念大盛，心想：“我怎忍让她在此再给囚禁十年？她怎经得起这般折磨？”想到她为了相救自己，甘愿舍生，自己一生之中，师友厚待者虽也不少，可没一个人竟能如此甘愿把性命来交托给了自己。胸口热血上涌，只觉别说盈盈不过是魔教教主的女儿，纵然她万恶不赦、天下人皆欲杀之而甘心，自己宁可性命不在，也决计要维护她平安周全。 </p><p>一想到和盈盈对面相晤，不由得胸口一热，连耳根子也热烘烘地，自忖：“自今而后，我真的要和盈盈结为夫妻吗？她待我情深义重，可是我……可是我……”这些日子来，虽时时想到盈盈，但每次念及，总是想到要报她相待之恩，要助她脱却牢狱之灾，要在江湖上大肆宣扬，是自己对她倾心，并非她对己有意，免得江湖豪士讥嘲于她，令她尴尬羞惭。每当盈盈的倩影在脑海中出现之时，心中却并不感到喜悦不胜之情、温馨无限之意，和他想到小师妹岳灵珊时温柔缠绵的心意大不相同，对于盈盈，内心深处竟似乎有些惧怕。 </p><p>过了良久，冲虚道人长吁一口气，说道：“这一场不用比了，你们四位下山去罢。”<br>    此言一出，众人尽皆骇然。令狐冲大喜，激动之馀，又欲跪倒，冲虚忙伸手拦住。解风道：“道长，你这话是什么意思？”冲虚道：“我想不出破解他的剑法之道，这场比试，贫道认输。”解风道：“两位可还没动手啊。”冲虚道：“数日之前，在武当山脚下，贫道曾和他拆过三百馀招，那次是我输了。今日再比，贫道仍然要输。”方证等都问：“有这等事？”冲虚道：“令狐小兄弟深得风清扬风前辈剑法真传，贫道不是他对手。”说着微微一笑，退在一旁。 </p><p>​    过了片刻，任我行见令狐冲不住后退，更加焦急，又向盈盈道：“到对面去。”盈盈仍然不动，连“嗯”的那一声也不答应。她心中在想：“我待你如何，你早已知道。你如以我为重，决意救我下山，你自会取胜。你如以师父为重，我便拉住你衣袖哀哀求告，也是无用。我何必站到你的面前来提醒你？”深觉两情相悦，贵乎自然，倘要自己有所示意之后，令狐冲再为自己打算，那可无味之极了。 </p><p>​    他心下大喜，脸上自也笑逐颜开。岳不群又是一招“浪子回头”，一招“苍松迎客”，两招连绵而至。剑招渐急，若不可耐。令狐冲猛地省悟：“师父叫我浪子回头，当然不是口说无凭，是要我立刻弃剑认输，这才将我重行收归门下。我得重返华山，再和小师妹成婚，人生又复何求？但盈盈、任教主、向大哥却又如何？这场比试一输，他们三人便得留在少室山上，说不定尚有杀身之祸。我贪图一己欢乐，却负人一至于斯，那还算是人么？”言念及此，不由得背上出了一阵冷汗，眼中瞧出来也模模糊糊，只见岳不群长剑横过，在他自己口边掠过，跟着剑锋便推将过来，正是一招“弄玉吹箫”。 </p><p>令狐冲心中又是一动：“盈盈甘心为我而死，我竟可舍之不顾，天下负心薄幸之人，还有更比得上我令狐冲吗？无论如何，我可不能负了盈盈对我的恩义。”突然脑中一晕，只听得铮的一声响，一柄长剑落在地下。 </p><h3 id="第29章-积雪"><a href="#第29章-积雪" class="headerlink" title="第29章 积雪"></a>第29章 积雪</h3><p>盈盈道：“他几次三番的痛下杀手，想要杀你。你如此忍让，实已报了师恩。像你这样的人，到那里都不会死，就算岳氏夫妇不养你，你在江湖上做小叫化，也决计死不了。他把你逐出华山派，师徒间的情义早已断了，还想他作什？”说到这里，慢慢放低了声音，道：“冲哥，你为了我而得罪师父、师娘，我……我心里……”说着低下了头，晕红双颊。<br>    令狐冲见她露出了小儿女的腼腆神态，洞外熊熊火光照在她脸上，直是明艳不可方物，不由得心中一荡，伸出手去握住了她左手，叹了口气，不知说什么才好。 </p><p>盈盈柔声道：“你为什么叹气？你后悔识得我吗？”令狐冲道：“没有，没有！我怎会后悔？你为了我，宁肯把性命送在少林寺里，我以后粉身碎骨，也报不了你的大恩。”盈盈凝视他双目，道：“你为什么说这等话？你直到现下，心中还是在将我当作外人。” </p><p>令狐冲内心一阵惭愧，在他心中，确然总对她有一层隔膜，说道：“是我说错了，自今而后，我要死心塌地的对你好。”这句话一出口，不禁想到：“小师妹呢？小师妹呢？难道我从此忘了小师妹？” </p><p>盈盈眼光中闪出喜悦的光芒，道：“冲哥，你这是真心话呢，还是哄我？”<br>    令狐冲当此之时，再也不自计及对岳灵珊铭心刻骨的相思，全心全意的道：“我如是哄你，教我天打雷劈，不得好死！”<br>    盈盈的左手慢慢翻转，也将令狐冲的手握住了，只觉一生之中，实以这一刻光阴最是难得，全身都暖烘烘地，一颗心却又如在云端飘浮，但愿天长地久，永恒如此。过了良久，缓缓说道：“咱们武林中人，只怕是注定要不得好死的了。你日后倘若对我负心，我也不盼望你天打雷劈，我……我……我宁可亲手一剑刺死了你。” </p><p>令狐冲笑道：“你不许我对你轻薄，今后我仍一直叫你婆婆好啦。”盈盈笑道：“好啊，乖孙子。”令狐冲道：“婆婆，我心中有……”盈盈道：“不许叫婆婆啦，待过得六十年，再叫不迟。”令狐冲道：“若从现下叫起，能一直叫你六十年，这一生可也不枉了。” </p><p>盈盈心神荡漾，寻思：“当真得能和他厮守六十年，便天上神仙，也是不如。”<br>    令狐冲见到她的侧面，鼻子微耸，长长睫毛低垂，容颜娇嫩，脸色柔和，心想：“这样美丽的姑娘，为什么江湖上成千成万桀傲不驯的豪客，竟会对她又敬又畏，又甘心为她赴汤蹈火？”想要询问，却觉在这时候说这等话未免大煞风景，欲言又止。 </p><p>盈盈低声道：“只要你不怕我煮的焦饭，我便煮一辈子饭给你吃。”令狐冲笑道：“只要是你煮的，每日我便吃三大碗焦饭，却又何妨？”盈盈轻轻的道：“你爱说笑，尽管说个够好了。其实，你说话逗我欢喜，我也开心得很呢。” </p><p>盈盈续道：“这‘三尸脑神丹’服下之后，每年须服一次解药，否则毒性发作，死得惨不堪言。东方不败对那些江湖豪士十分严厉，小有不如他意，便扣住解药不发，每次总是我去求情，讨得解药给了他们。”令狐冲道：“那你可是他们的救命恩人了。”<br>    盈盈道：“也不是什么恩人。他们来向我磕头求告，我可硬不了心肠，置之不理。原来这也是东方不败掩人耳目之策，他是要使人人知道，他对我十分爱护尊重。这样一来，自然再也无人怀疑他的教主之位是篡夺来的。”<br>    令狐冲点头道：“此人也当真工于心计。”盈盈道：“不过老是要我向东方不败求情，实在太烦。再者，教里的情形也跟以前大不相同了。人人见了东方不败都要满口谀词，肉麻无比。前年春天，我叫师侄绿竹翁陪伴，出来游山玩水，见到洛阳城绿竹巷闹中有静，住下来挺好，便隐居了一段时日，既免再管教中的闲事，也不必向东方不败说那些无耻言语。想不到竟撞到了你。”她向令狐冲瞧了一眼，想起绿竹巷中初遇的情景，轻轻叹息一声，心中充满了柔情。过了好一会，说道：“来到少林寺的这数千豪客，当然并非都曾服过我求来的解药。但只要有一人受过我的恩惠，他的亲人好友、门下弟子、所属帮众等等，自然也都承我的情了。再说，他们到少室山来，也未必真的是为了我，多半还是应令狐大侠的召唤，不敢不来。”说到这里，抿嘴一笑。 </p><p>令狐冲叹道：“你跟着我没什么好处，这油嘴滑舌的本事，倒也长进了三分。” </p><p>盈盈噗哧一声，笑了出来。她一生下地，日月神教中人人便当她公主一般，谁也不敢违拗她半点，待得年纪愈长，更加颐指气使，要怎么便怎么，从没一人敢和她说一句笑话。此刻和令狐冲如此笑谑，当真是生平从无此乐。 </p><p>过了一会，盈盈将头转向山壁，说道：“你率领众人到少林寺来接我，我自然欢喜。那些人贫嘴贫舌，背后都说我……说我真心对你好，而你却是个风流浪子，到处留情，压根儿没将我放在心上……”说到这里，声音渐渐低了下来，幽幽的道：“你这般大大的胡闹一场，总算是给足了我面子，我……我就算死了，也不枉担了这虚名。” </p><p>令狐冲道：“是啊，他们可不该瞒着你。”盈盈道：“方丈说起来却又是一片道理。他说留我在少室山，是盼望以佛法化去我的什么暴戾之气，当真胡说八道之至。”令狐冲道：“是啊，你又有什么暴戾之气了？”盈盈道：“你不用说好话讨我欢喜。我暴戾之气当然是有的，不但有，而且相当不少。不过你放心，我不会对你发作。”令狐冲道：“承你另眼相看，那可多谢了。” </p><p>只听岳不群道：“大丈夫言出如山，我既答允了他，自无反悔之理。”岳夫人道：“他对那魔教妖女十分迷恋，你岂有不知？”岳不群道：“不，他对那妖女感激则有之，迷恋却未必。平日他对珊儿那般情景，和对那妖女大不相同，难道你瞧不出来？”岳夫人道：“我自然也瞧出了。你说他对珊儿仍未忘情？”岳不群道：“岂但并未忘情，简直是……简直是相思入骨。他一明白了我那几招剑招的用意之后，你不见他那一股喜从天降、心花怒放的神气？”岳夫人冷冷的道：“正因为如此，因此你是以珊儿为饵，要引他上钩？要引得他为了珊儿之故，故意输了给你？”<br>    令狐冲虽积雪盈耳，仍听得出师娘这几句话中，充满着愤怒和讥刺之意。这等语气，他从来没听到曾出之于师娘之口。岳不群夫妇向来视他如子，平素说话，在他面前亦无避忌。岳夫人性子较急，在家务细事上，偶尔和丈夫顶撞几句，原属常有，但遇上门户弟子之事，她向来尊重丈夫的掌门身分，绝不违拗其意。此刻如此说法，足见她心中已不满之极。 </p><p>盈盈道：“爹爹，他手臂怎么了？”任我行笑道：“你别心急！乖女婿给爹爹驱除寒毒，泰山老儿自当设法治好他手臂。”说着呵呵大笑，瞪视令狐冲，瞧得他什感尴尬。 </p><p>盈盈低声道：“爹爹，你休说这等言语。冲哥自幼和华山岳小姐青梅竹马，一同长大，适才冲哥对岳小姐那样的神情，你难道还不明白么？”任我行笑道：“岳不群这伪君子是什么东西？他的女儿又怎能和我的女儿相比？再说，这岳姑娘早已另外有了心上人，这等水性的女子，冲儿今后也不会再将她放在心上。小孩子时候的事怎作得准？”盈盈道：“冲哥为了我大闹少林，天下知闻，又为了我而不愿重归华山，单此两件事，女儿已心满意足，其馀的话不用提了。” </p><p>任我行知女儿十分要强好胜，令狐冲既未提出求婚，此刻就不便多说，反正那也只是迟早间之事，当下又哈哈一笑，说道：“很好，很好，终身大事，慢慢再谈。冲儿，打通左臂经脉的秘诀，我先传你。”将他招往一旁，将如何运气、如何通脉的法门说了，待听他复述一遍，记忆无误，又道：“你助我驱除寒毒，我教你通畅经脉，咱俩仍两不亏欠。要让左臂经脉复元，须得七日时光，可不能躁进。”令狐冲应道：“是。” </p><p>任我行招招手，叫向问天和盈盈过来，说道：“冲儿，那日在孤山梅庄，我邀你入我日月神教，当时你一口拒却。今日情势已大不相同，老夫旧事重提，这一次，你再不会推三阻四了罢？”令狐冲踌躇未答，任我行又道：“你习了我的吸星大法之后，他日后患无穷，体内异种真气发作之时，当真是求生不能，求死不得。老夫说过的话，决无反悔，你若不入本教，纵然盈盈嫁你，我也不能传你化解之道。就算我女儿怪我一世，我也是这一句话。我们眼前大事，是去向东方不败算帐，你是不是随我们同去？”<br>    令狐冲道：“教主莫怪，晚辈决计不入日月神教。”这两句话朗朗说来，斩钉截铁，绝无转圜馀地。 </p><p>任我行等三人一听，登时变色。向问天道：“那却是为何？你瞧不起日月神教吗？”<br>    令狐冲指着雪地上十馀具尸首，说道：“日月神教中尽是这些人，晚辈虽然不肖，却也羞与为伍。再说，晚辈已答允了定闲师太，要去当恒山派的掌门。”<br>    任我行、向问天、盈盈三人脸上都露出怪异之极的神色。令狐冲不愿入教，并不如何出奇，而他最后这一句话当真奇峰突起，三人简直不相信自己的耳朵。 </p><p>任我行伸出食指，指着令狐冲的脸，突然哈哈大笑，直震得周遭树上的积雪簌簌而落。他笑了好一阵，才道：“你……你……你要去做尼姑？去做众尼姑的掌门人？”<br>    令狐冲正色道：“不是做尼姑，是去做恒山派掌门人。定闲师太临死之时，亲口求我，晚辈若不答允，老师太死不瞑目。定闲师太是为我而死，晚辈明知此事势必骇人听闻，当时却没法推却。” </p><h3 id="第30章-掌门"><a href="#第30章-掌门" class="headerlink" title="第30章 掌门"></a>第30章 掌门</h3><p>​    令狐冲叹道：“定闲师太当时确是命我肩负这个重任，但想我是个年轻男子，声名又极差，人人都知我是无行浪子，如何能做恒山派掌门？只不过眼见当时情势，我若不答允，定闲师太死不瞑目。唉，这可为难得紧了。” </p><p>仪和道：“我们……我们大夥儿都盼望你……盼望你来执掌恒山门户。”郑萼道：“掌门师叔，你领着我们出死入生，不止一次救了众弟子性命。恒山派众弟子人人都知你是位正人君子。虽然你是男子，但本门门规之中，也没不许男子做掌门那一条。”一个中年尼姑仪文道：“大夥儿听到师父和师叔圆寂的讯息，自是不胜悲伤，但得悉由掌门师叔你来接掌门户，恒山一派不致就此覆灭，都大感宽慰。”仪和道：“我师父和两位师叔都给人害死，恒山派‘定’字辈三位师长，数月之间先后圆寂，我们可连凶手是谁也不知道。掌门师叔，你来做掌门人当真最好不过，你算‘定’字辈，不妨改名令狐定冲。若不是你，也不能给我们三位师长报仇。”<br>    令狐冲点头道：“为三位师太报仇雪恨的重任，我自当肩负。” </p><p>郑萼道：“我们得知两位师尊的噩耗后，兼程赶往少林寺，途中又遇到了莫大师伯。他说你已不在寺中，要我们赶快寻访你掌门师叔。”秦绢道：“莫大师伯说道，越早寻着你越好，要是迟了一步，你给人劝得入了魔教，正邪水火不容，恒山派可就没了掌门人啦。”郑萼向她白了一眼，道：“秦师妹便口没遮拦。掌门师叔怎会去入魔教？”秦绢道：“是，不过莫大师伯可真的这么说。” </p><p>令狐冲心想：“莫大师伯推算得极准，我没参与日月神教，相差也只一线之间。当日任教主若不是以内功秘诀相诱，而是诚诚恳恳的邀我入教，我情面难却，又瞧在盈盈和向大哥份上，说不定会答允料理了恒山派大事之后便即加盟。”说道：“因此上你们便定下一千两银子赏格，到处捉拿令狐冲了？” </p><p>​    秦绢破涕为笑，说道：“捉拿令狐冲？我们怎敢啊？”郑萼道：“当时大家听了莫大师伯的吩咐，便分成七人一队，寻访掌门师叔，要请你早上恒山，处理派中大事。今日见到桃谷六仙，他们出口要一千两银子。只要寻到掌门师叔，别说一千两，就是要一万两，我们也会设法去化了来给他们。”<br>​    令狐冲微笑道：“我做你们掌门，别的好处没有，向贪官污吏、土豪劣绅化缘要银子，这副本事大家定有长进。” </p><p>令狐冲不愿拂逆众意，道：“既是如此，便定在二月十六罢。”当下派遣弟子，分赴少林寺迎回两位师太的骨灰，向各门派分送通知。他向下山的诸弟子一再叮嘱，千万不可张扬其事，又道：“你们向各派掌门人禀明，定闲师太圆寂，大仇未报，恒山派众弟子在居丧期内，不行什么掌门人就任的大典，请勿遣人上山观礼道贺。” </p><p>山坳后转出一个身材魁梧的和尚，正是仪琳的父亲不戒和尚，他身后又有个和尚。两人行得什快，片刻间已走近身来。不戒和尚大声道：“令狐公子，你受了重伤居然不死，还做了我女儿的掌门人，那好得很啊。”令狐冲笑道：“这是托大师的福。”<br>    仪琳走上前去，拉住父亲的手，什是亲热，笑道：“爹，你知道今日是令狐师兄接任恒山派掌门的好日子，因此来道喜吗？”<br>    不戒笑道：“道喜也不用了，我是来投入恒山派。大家是自己人，又道什么喜？”<br>    令狐冲微微一惊，问道：“大师要投入恒山派？”<br>    不戒道：“是啊。我女儿是恒山派，我是她老子，自然也是恒山派。他奶奶的，我听到人家笑话你，说你一个大男人，却来做一群尼姑和女娘的掌门人。他奶奶的，他们可不知你多情多义，别有居心……”他眉花眼笑，显得十分欢喜，向女儿瞧了一眼，又道：“老子一拳就打落他满口牙齿，喝道：‘你这小子懂个屁！恒山派怎么全是尼姑和女娘们？老子就是恒山派的，老子虽剃了光头，你瞧老子是尼姑吗？老子解开裤子给你瞧瞧！’我伸手便解裤子，这小子吓得掉头就跑，哈哈，哈哈！” </p><p>田伯光笑道：“对不起，这可得罪了。当时情势危急，我若不这么说，太师父决计不会放我。果然他一听之下，便即转怒为喜，说道：‘臭小子，你自己想想，你一生做过多少坏事？要不是你非礼我女儿，老子早就将你脑袋揑扁了。’”<br>    令狐冲奇道：“你对她女儿无礼，他反而高兴？”田伯光道：“那也不是高兴，他赞我有眼光。”令狐冲不禁莞尔。 </p><p>田伯光续道：“我到华山来邀你大驾，却给你打得一败涂地，只道这番再也性命难保，不料太师父放心不下，亲自带同小师太上华山找你，又给了我解药，我听你的劝，从此不再做采花奸淫的勾当。不过田伯光天生好色，女人是少不了的，反正身边金银有的是，要找荡妇淫娃、娼妓歌女，丝毫不是难事。半个月前，太师父又找到了我，说你做了恒山派掌门，却给人家背后讥笑，江湖上的名声不大好听，他老人家爱屋及乌，爱女及婿……”<br>    令狐冲皱眉道：“田兄，这等无聊的话，以后可再也不能出口。” </p><p>田伯光摇头道：“太师父是另有道理的。他说：‘你这人太也好色，入了恒山派，师伯师叔们都是美貌尼姑，那可大大不妥。须得斩草除根，方为上策。’他出手将我点倒，拉下我的裤子，提起刀来，就这么喀的一下，将我那话儿斩去了半截。” </p><p>令狐冲一惊，“啊”的一声，摇了摇头，虽觉此事什惨，但想田伯光一生所害的良家妇女太多，那也是应得之报。<br>    田伯光也摇了摇头，说道：“当时我便晕了过去。待得醒转，太师父已给我敷上了金创药，包好伤口，命我养了几日伤。跟着便逼我剃度，做了和尚，给我取个法名，叫做‘不可不戒’。他说：‘我已斩了你那话儿，你已干不得采花坏事，本来也不用做和尚。我叫你做和尚，取个“不可不戒”的法名，以便众所周知，那是为了恒山派的名声。本来嘛，做和尚的人，跟尼姑们混在一起，大大不妥，但打明招牌“不可不戒”，就不要紧了。’” </p><p>令狐冲微笑道：“你太师父倒挺细心，想得周到。”田伯光道：“太师父说：为了宝贝女儿，只好用尽心思，要救她一命。太师父要我向你说明此事，又要我请你别责怪我师父。”令狐冲奇道：“我为什么要责怪你师父？全没这回子事。”<br>    田伯光道：“太师父说：每次见到我师父，她总更加瘦了一些，脸色也越来越坏，问起她时，她总是流泪，一句话不说。太师父说：定是你欺负了她。”令狐冲惊道：“没有啊！我从来没重言重语说过你师父一句。再说，她什么都好，我怎会责骂她？”<br>    田伯光道：“就是你从来没骂过她一句，因此我师父要哭了。”令狐冲道：“这个我可不明白了。”田伯光道：“太师父为了这件事，又狠狠打了我一顿。” </p><p>令狐冲搔了搔头，心想这不戒大师之胡缠瞎搅，与桃谷六仙实有异曲同工之妙。<br>    田伯光道：“太师父说：他当年和太师母做了夫妻后，时时吵嘴，越骂得凶，越是恩爱。你不骂我师父，就是不想娶她为妻。” </p><p>田伯光道：“太师父说：这件事他也知道，他说那很好办，想个法子将任大小姐杀了，不让你知道，那就成了。我忙说不可，倘若害死了任大小姐，令狐公子一定自杀。太师父道：‘这也说得是。令狐冲这小子死了，我女儿要守活寡，岂不倒霉？这样罢，你去跟令狐冲这小子说，我女儿嫁给他做二房，也无不可。’我说：‘太师父，你老人家的堂堂千金，岂可如此委屈？’他叹道：‘你不知道，我这个姑娘如嫁不成令狐冲，早晚便死，定然活不久长。’他说到这里，突然流下泪来。唉，这是父女天性，真情流露，可不是假的。”<br>    两人面面相对，都感尴尬。田伯光道：“令狐公子，太师父对我的吩咐我都对你说了。我知道这其中颇有难处，尤其你是恒山派掌门，更加犯忌。不过我劝你对我师父多说几句好话，让她高高兴兴，将来再瞧着办罢。” </p><p>令狐冲自上恒山之后，对着一群尼姑、姑娘，说话行事，无不极尽拘束，此刻陡然间遇上这许多老友，自不胜之喜。<br>    黄伯流道：“我们是不速之客，恒山派未必备有我们这批粗胚的饮食。酒食饭菜这就挑上山来了。”令狐冲喜道：“那再好也没有了。”心想：“这情景倒似当年五霸冈上的群豪大会。”说话之间，又有数百人上山。计无施笑道：“令狐公子，咱们自己人不用客气。你那些斯斯文文的女弟子，也招呼不来我们这些浑人。大家自便最好。” </p><p>到得午间，数百名汉子挑了鸡鸭牛羊、酒菜饭面来到峰上。令狐冲心想：“见性峰上供奉白衣观音，自己一做掌门人，便即大鱼大肉，杀猪宰羊，未免对不住恒山派历代祖宗。”当下命这些汉子在山腰间埋灶造饭。一阵阵酒肉香气飘将上来，群尼无不暗暗皱眉。 </p><p>只见一名女弟子快步过来，禀道：“武当派冲虚道长亲来道贺。”<br>    令狐冲吃了一惊，忙迎到峰前。只见冲虚道人带着八名弟子走上峰来。令狐冲躬身行礼，说道：“有劳道长大驾，令狐冲感激不尽。”冲虚道人笑道：“老弟荣任恒山掌门，贫道闻知，不胜之喜。少林寺方证、方生两位大师也要前来道贺，不知他们两位到了没有？”令狐冲更是惊讶。<br>    便在此时，山道上走上来一群僧人，当先二人大袖飘飘，正是方证方丈和方生大师。方证叫道：“冲虚道兄，你脚程好快，可比我们先到了。” </p><p>令狐冲道：“丁前辈想必忘了。那日在浙南龙泉铸剑谷中，嵩山派的朋友们假扮日月教人士，围攻定闲、定逸两位师太，死伤了多位恒山师姊妹。定闲师太早已声明，恒山派从此不奉左盟主号令，这番言语，想来姓赵、姓张、姓司马那三位仁兄，都已禀明左掌门了。令狐冲接掌恒山门户，自当遵奉定闲师太遗命，不再加盟五岳剑派。” </p><p>忽听得山道上传来一个女子清脆的叫声：“日月神教任大小姐到！”<br>    令狐冲惊喜交集，情不自禁的冲口而出：“盈盈来了！”急步奔到崖边，只见两名大汉抬着一乘青呢小轿，快步上峰。小轿之后跟着四名青衣女婢。 </p><p>令狐冲走上几步，微笑道：“盈盈，你也来啦！”<br>    盈盈微笑道：“今天是你大喜的日子，我怎能不来？”眼光四下一扫，走上几步，向方证与冲虚二人敛衽为礼，说道：“方丈大师，掌门道长，小女子有礼。” </p><p>方证和冲虚一齐还礼，心下都想：“你和令狐冲再好，今日却也不该前来，这可叫令狐冲更加为难了。”<br>    丁勉大声道：“这个姑娘，是魔教中的要紧人物。令狐冲，你说是也不是？”令狐冲道：“是又怎样？”丁勉道：“恒山派五大戒律，规定不得结交奸邪。你若不与这些奸邪人物一刀两断，便做不得恒山派掌门。”令狐冲道：“做不得便做不得，那又有什么打紧？”<br>    盈盈向他瞧了一眼，目光中深情无限，心想：“你为了我，什么都不在乎了。”问道：“请问令狐掌门，这位朋友是什么来头？凭什么来过问恒山派之事？” </p><p>盈盈大声道：“众位听了，咱们今日到来，都是来投恒山派的。只要令狐掌门肯收留，咱们便都是恒山弟子了。恒山弟子，怎能算是妖邪？”<br>    令狐冲恍然大悟：“原来盈盈早料到我身为众女弟子的掌门，十分尴尬，倘若派中有许多男弟子，那便无人耻笑了。因此特地叫这一大群人来投入恒山派。”当即朗声问道：“仪和师姊，本派可有不许收男弟子这条门规么？” </p><h3 id="第31章-密议"><a href="#第31章-密议" class="headerlink" title="第31章 密议"></a>第31章 密议</h3><p>令狐冲道：“无怪乎有这许多人想做皇帝。他只消开一句口，数万兵卒便将阻路的山岭给他凿了开来。”冲虚道：“权势这一关，古来多少英雄豪杰，却都难以凿开。别说做皇帝了，今日武林中所以风波迭起，纷争不已，还不是为了那‘权势’二字。”<br>    令狐冲心下一凛：“他说到正题了。”便道：“晚辈不明，请二位前辈指点。” </p><p>​    方证道：“令狐掌门，今日嵩山派的丁老师率众前来，为的是什么？”令狐冲道：“他传达左盟主的号令，不许晚辈接任恒山派掌门。”方证道：“左盟主为什么不许你做恒山派掌门？”令狐冲道：“左盟主要将五岳剑派并而为一，晚辈曾一再阻挠他的大计，杀了不少嵩山派之人，左盟主对晚辈自是痛恨之极。”方证问道：“你为什么要阻挠他的大计？” </p><p>令狐冲一呆，一时难以回答，顺口重复了一句：“我为什么要阻挠他的大计？”<br>    方证问道：“你以为五岳剑派合而为一，这件事不妥么？”<br>    令狐冲道：“晚辈当时也没想过此事妥或不妥。只是嵩山派为了胁迫恒山派答允，假扮日月教教众，劫掳恒山弟子，围攻定静师太，所使的手段太过卑鄙。晚辈刚巧遇上此事，心觉不平，是以出手相助。后来嵩山派火烧铸剑谷，要烧死定闲、定逸两位师太，那是更加可恶了。晚辈心想，五岳剑派合并之举倘是美事、好事，嵩山派何不正大光明的与各派掌门商议，却要干这鬼鬼祟祟的勾当？” </p><p>冲虚点头道：“令狐掌门所见不差。左冷禅野心极大，要做武林中的第一人。自知难以服众，只好暗使阴谋。”方证叹道：“左盟主文才武略，确是武林中的杰出人物，五岳剑派之中，原本没第二人比得上。不过他抱负太大，急欲压倒武当、少林两派，未免有些不择手段。” </p><p>令狐冲道：“原来左冷禅是要天下武林之士，个个遵他号令。”<br>    冲虚说道：“正是！那时候只怕他想做皇帝了，做了皇帝之后，又想长生不老，万寿无疆！这叫做‘人心不足蛇吞象’，自古以来，皆是如此。英雄豪杰之士，绝少有人能逃得过这‘权位’的关口。”<br>    令狐冲默然，一阵北风疾刮过来，不由得机伶伶的打了个寒噤，说道：“人生数十年，但贵适意，却又何苦如此？左冷禅要挑了魔教，要消灭崆峒、昆仑，要吞并少林、武当，不知将杀多少人，流多少血？” </p><p>冲虚道：“浮滑无行，为害不大，好酒贪杯更于人无损，野心勃勃，可害得人多了。老弟如做了五岳派掌门，第一，不会欺压五岳剑派的前辈耆宿与门人弟子；第二，不会大动干戈，想去灭了魔教，不会来吞并我们少林、武当；第三，大概吞并峨嵋、昆仑诸派的兴致，老弟也不会太高。”方证微笑道：“冲虚道兄和老衲如此打算，虽说是为江湖同道造福，一半也是自私自利。”冲虚道：“打开天窗说亮话，老和尚、老道士来到恒山，一来是为老弟捧场，二来是为正邪双方万千同道请命。”方证合什道：“阿弥陀佛！左冷禅倘若当上了五岳派掌门人，这杀劫一起，可不知伊于胡底了。” </p><p>令狐冲和盈盈交往，初时是闻其声而不见其人，随后是见其威慑群豪而不知其所由，感其深情而不知其所踪。当日她手杀少林弟子，力斗方生大师，令狐冲也只是见其影而不见其形，直至此刻，才初次正面见到她与人相斗。但见她身形轻灵，倏来倏往，剑招攻人，出手诡奇，长短剑或虚或实，极尽飘忽，虽然一个实实在在的人便在眼前，令狐冲心中，仍觉得飘飘缈缈，如烟如雾。 </p><p>其时暮色苍茫，晚风吹动她柔发，从后脑向双颊边飘起。令狐冲见到她雪白的后颈，心中一荡，寻思：“她对我一往情深，天下皆知，连东方不败也想到要擒拿了我，向她要胁，再以此要胁她爹爹。适才悬空寺天桥之上，她明知毒水中人即死，却挡在我身前，唯恐我受伤。有妻如此，令狐冲复有何求？”伸出双臂，便往她腰中抱去。 </p><h3 id="第32章-绣花"><a href="#第32章-绣花" class="headerlink" title="第32章 绣花"></a>第32章 绣花</h3><p>东方不败尖声道：“果然是任教主！你终于来了！莲弟，你……你……怎么了？是给他打伤了吗？”扑到杨莲亭身旁，把他抱起，轻轻放在床上。东方不败脸上一副爱怜横溢的神情，连问：“疼得厉害吗？”又道：“只断了腿骨，不要紧的，你放心好啦，我立刻给你接好。”慢慢给他除了鞋袜，拉过薰得喷香的绣被，盖在他身上，便似一个贤淑的妻子服侍丈夫一般。<br>    众人不由得相顾骇然，人人想笑，只这情状太过诡异，却又笑不出来。锦帷珠帘、富丽灿烂的绣房之中，竟充满了阴森森的妖氛鬼气。<br>    东方不败从身边摸出一块绿绸手帕，缓缓为杨莲亭拭去额头的汗水和泥污。杨莲亭怒道：“大敌当前，你跟我这般婆婆妈妈干什么？你能打发得了敌人，再来跟我亲热不迟。”东方不败微笑道：“是，是！你别生气，腿上痛得厉害，是不是？真叫人心疼。” </p><p>如此怪事，任我行、令狐冲等皆是从所未见，从所未闻。男风娈童固所在多有，但东方不败以堂堂教主之尊，何以竟会甘扮女子，自居妾妇？此人定然疯了。杨莲亭对他说话，声色俱厉，他却显得十分的“温柔娴淑”，人人既感奇怪，又有些恶心。 </p><p>童百熊忍不住踏步上前，叫道：“东方兄弟，你……你到底在干什么？”东方不败抬起头来，阴沉着脸，问道：“伤害我莲弟的，也有你在内吗？”童百熊道：“你为什么受杨莲亭这厮摆弄？他叫一个混蛋冒充了你，任意发号施令，胡作非为，你可知道么？”<br>    东方不败道：“我自然知道。莲弟是为我好，对我体贴。他知我无心处理教务，代我操劳，有什么不好？”童百熊指着杨莲亭道：“这人要杀我，你也知道么？”东方不败缓缓摇头，道：“我不知道。莲弟既要杀你，定是你不好。你为什么不让他杀了？” </p><p>童百熊一怔，仰起头来，哈哈大笑，笑声中尽是悲愤之意，笑了一会，才道：“他要杀我，你便让他杀我，是不是？”<br>    东方不败道：“莲弟喜欢干什么，我便得给他办到。当世就只他一人真正待我好，我也只待他一个好。童大哥，咱们一向是过命的交情，不过你不应该得罪我的莲弟啊。”<br>    童百熊满脸胀得通红，大声道：“我还道你是失心疯了，原来你心中明白得很，知道咱们是好朋友，一向是过命的交情。”东方不败道：“正是。你得罪我，那没什么。得罪我莲弟，却是不行。”童百熊大声道：“我已经得罪他了，你待怎地？这奸贼想杀我，可是未必能如愿。” </p><p>东方不败摇头道：“你不是胡涂，是对我义气深重。我十一岁上就识得你了。那时我家境贫寒，全蒙你多年救济。我父母故世后无以为葬，丧事也是你代为料理的。”童百熊左手一摆，道：“过去之事，提来干么？”东方不败叹道：“那可不得不提。童大哥，做兄弟的不是没良心，不顾旧日恩情，只怪你得罪了我莲弟。他要取你性命，我这叫做无法可施。”童百熊大叫：“罢了，罢了！” </p><p>只见童百熊张大了口，忽然身子向前直扑下去，俯伏在地，就此一动也不动了。他摔倒时虽只一瞬之间，但任我行等高手均已看得清楚，他眉心、左右太阳穴、鼻下人中四处大穴上，都有一个细小红点，微微有血渗出，显是给东方不败以手中绣花针所刺。<br>    任我行等大骇之下，不由自主都退了几步。令狐冲左手将盈盈一扯，自己挡在她身前。一时房中一片寂静，谁也没喘一口大气。 </p><p>​    只听东方不败又道：“初时我一心一意只想做日月神教教主，想什么千秋万载，一统江湖，于是处心积虑的谋你的位，翦除你的羽翼。向兄弟，我这番计谋，可瞒不过你。日月神教之中，除了任教主和我东方不败之外，要算你是个人才了。” </p><p>东方不败的目光缓缓转到盈盈脸上，问道：“任大小姐，这几年来我待你怎样？”盈盈道：“你待我很好。”东方不败又叹了口气，幽幽的道：“很好是谈不上，只不过我一直很羡慕你。一个人生而为女子，已比臭男子幸运百倍，何况你这般千娇百媚，青春年少。我若得能和你易地而处，别说是日月神教的教主，就是皇帝老子，我也不做。”<br>    令狐冲笑道：“你若和任大小姐易身而处，要我死心塌地的爱上你这老妖怪，可有点不容易！”<br>    任我行等听他这么说，都是一惊。 </p><p>东方不败双目凝视着他，眉毛渐渐竖起，脸色发青，说道：“你是谁？竟敢如此对我说话，胆子当真不小。”这几句话音尖锐之极，显得愤怒无比。<br>    令狐冲明知危机已迫在眉睫，却也忍不住笑道：“是须眉男儿汉也好，是千娇百媚的姑娘也好，我最讨厌的，是男扮女装的老旦。”东方不败尖声怒道：“我问你，你是谁？”令狐冲道：“我叫令狐冲。”<br>    东方不败怒色登敛，微微一笑，说道：“啊！你便是令狐冲。我早想见你一见，听说任大小姐爱煞了你，为了你连头都割得下来，可不知是如何一位英俊的郎君。哼，我看也平平无奇，比起我那莲弟来，可差得远了。” </p><p>东方不败苦笑道：“任教主，终于是你胜了，是我败了。”任我行哈哈大笑，道：“你这大号，可得改一改罢？”东方不败摇头道：“那也不用改。东方不败既然落败，也不会再活在世上。”他本来说话声音极尖，此刻却变得低沉起来，又道：“倘若单打独斗，我不会败给你。”<br>    任我行微一犹豫，说道：“不错，你武功比我高，我很佩服。”东方不败道：“令狐冲，你剑法极高，但如单打独斗，也打不过我。”令狐冲道：“正是。其实我们便四人联手，也打你不过，只不过你顾着那姓杨的，这才分心受伤。阁下武功极高，不愧为‘天下第一’，在下十分钦佩。” </p><p>东方不败微微一笑，道：“你二位能这么说，足见男子汉大丈夫气概。唉，冤孽，冤孽，我练那《葵花宝典》，照着宝典上的秘方，炼丹服药，自……唉，渐渐的胡子没有了，说话声音变了，性子也变了。我从此不爱女子，把七个小妾都杀了，却……却把全副心意放在杨莲亭这须眉男子身上。倘若我生为女儿身，那就好了。任教主，我……我就要死了，我求你一件事，请……请你瞧在我这些年来善待你大小姐的份上……” </p><p>任我行伸手到东方不败衣衫袋中，摸出一本薄薄的旧册页，随手一翻，其中密密麻麻的写满了字，正是那本《葵花宝典》。他握在手中扬了扬，心道：“这《葵花宝典》要诀注明：‘欲练神功，引刀自宫。炼丹服药，内外齐通。’老夫可不会没了脑子，去干这等傻事，哈哈，哈哈……”随即又想：“可是宝典上所载的武功实在厉害，任何学武之人，一见之后决不能不动心。那时候幸好我已学得‘吸星大法’，否则跟着去练这宝典上的害人功夫，却也难说。” </p><p>任我行伸手到东方不败胯下一摸，果然他的两枚睾丸已然割去，心想：“这部《葵花宝典》要是教太监去练，那就再好不过。”将《葵花宝典》放在双掌中力搓，内力到处，一本原已十分陈旧的册页登时化作碎片。他双手挥扬，许多碎片随风吹到了窗外。 </p><p>盈盈虽不明《葵花宝典》的精义，但见东方不败练了这门功夫后，变成这等不男不女的模样，也猜得到其中包含不少奸邪法门，见父亲将书毁去，吁了一口气道：“这种害人东西，毁了最好！”令狐冲笑道：“你怕我去练么？”盈盈满脸通红，啐了一口，道：“说话就没半点正经。”<br>    盈盈取出金创药，为父亲及上官云敷了眼上针伤。各人脸上给刺出的针孔，一时也难计数。盈盈对镜一照，见左颊上划了一道血痕，虽然极细，伤愈之后，只怕仍要留下些微痕迹，不由得郁郁不乐。<br>    令狐冲道：“你占尽了天下的好处，未免为鬼神所妒，脸上小小破一点相，那便后福无穷。”盈盈道：“我占尽了什么天下的好处？”令狐冲道：“你聪明美貌，武功高强，父亲是神教教主，自己又为天下豪杰所敬服。兼之身为女子，千娇百媚，青春年少，东方不败就羡慕得不得了。”盈盈给他逗得噗哧一笑，登时将脸上受伤之事搁在一旁。 </p><p>向问天在旁陪笑道：“教主，令狐兄弟是位少年英雄，性子执拗得很，待属下慢慢开导于他……”正说到这里，殿外有十馀人朗声说道：“玄武堂属下长老、堂主、副堂主，五枝香香主、副香主参见文成武德、仁义英明圣教主。教主中兴圣教，泽被苍生，千秋万载，一统江湖。”<br>    任我行喝道：“进殿！”只见十馀条汉子走进殿来，一排跪下。<br>    任我行以前当日月神教教主，与教下部属兄弟相称，相见时只抱拳拱手而已，突见众人跪下，当即站起，将手一摆，道：“不必……”心下忽想：“无威不足以服众。当年我教主之位为奸人篡夺，便因待人太过仁善。这跪拜之礼既是东方不败定下了，我也不必取消。”当下将“多礼”二字缩住了不说，跟着坐下。 </p><p>不多时，又有一批人入殿参见，向他跪拜时，任我行便不再站起，只点了点头。<br>    令狐冲这时已退到殿口，与教主的座位相距已遥，灯光又暗，远远望去，任我行的容貌已颇为蒙眬，忽想：“坐在这位子上的，是任我行还是东方不败，却有什么分别？” </p><p>令狐冲听这些人话声颤抖，显得十分害怕，暗道：“任教主还是和东方不败一样，以恐惧之心威慑教众。众人面子上恭顺，心底却愤怒不服，这个‘忠’字，从何说起？” </p><p>盈盈道：“冲哥，你在想什么？”令狐冲道：“你能和我一起去吗？”盈盈脸上一红，道：“我们……我们……”令狐冲道：“什么？”盈盈低头道：“我们又没成婚，我……我怎能跟着你去？”令狐冲道：“以前你不也和我一起在江湖行走？”盈盈道：“那是迫不得已，何况，也因此惹起了不少闲言闲语。刚才爹爹说我……说我只向着你，不要爹爹了，倘若我跟了你去，爹爹一定大大不高兴。爹爹受了这十几年牢狱之灾，性子很有些不同了，我想多陪陪他。只要你我此心不渝，今后咱们相聚的日子可长着呢。”说到最后这两句话，声音细微，几不可闻。 </p><p>恰好一团白云飘来，将竹篓和二人都裹在云中。令狐冲望出来时但觉蒙蒙眬眬，盈盈虽偎依在他身旁，可是和她相距却又似极远，好像她身在云端，伸手不可触摸。 </p><p>盈盈道：“我本该跟你一起去，只不过我是魔教妖女，倘若和你同上嵩山，有碍你的大计。”她顿了一顿，黯然道：“待得你当上了五岳派掌门，名震天下，咱二人正邪不同，那……那……那可更加难了。”<br>    令狐冲握住她手，柔声道：“到这时候，难道你还信不过我么？”盈盈凄然一笑，道：“信得过！”隔了一会，幽幽的道：“只是我觉得，一个人武功越练越高，在武林中名气越来越大，往往性子会变。他自己并不知道，可是种种事情，总是和从前不同了。东方叔叔是这样，我担心爹爹说不定也会这样。”令狐冲微笑道：“你爹爹不会去练《葵花宝典》上的武功，那宝典早已给他撕得粉碎，便是想练，也不成了。” </p><p>盈盈道：“我不是说武功，是说一个人的性子。东方叔叔就算不练《葵花宝典》，他当上了日月神教的教主，大权在手，生杀予夺，自然而然的会狂妄自大起来。”<br>    令狐冲道：“盈盈，你不妨担心别人，却决不必为我担心。我生就一副浪子性格，永不会装模作样。就算我再狂妄自大，在你面前，永远永远就像今天这样。” </p><p>盈盈叹了口气，道：“那就好了。”随即笑问：“像今天这样，是怎么样？”令狐冲正色道：“千秋万载，万载千秋，令狐冲是婆婆跟前的一个乖孙子。”盈盈嫣然一笑，道：“这样，我才真正占尽了天下的好处。什么千娇百媚，青春年少，全不打紧。千秋万载，万载千秋，我任盈盈也永远是令狐大侠身边的一个乖女孩。” </p><p>令狐冲拉近她身子，轻轻搂了搂她，说道：“我这就向你告辞。嵩山的大事一了，我便来寻你，自此而后，咱二人也不分开了。”盈盈眼中一亮，闪出异样的神采，低声道：“但愿你事事顺遂，早日前来。我……我在这里日日夜夜望着。”令狐冲道：“是了！”伸嘴在她脸颊上轻轻一吻。盈盈满脸飞红，娇羞无限。<br>    令狐冲哈哈大笑，牵过马来，上马出了日月教。</p><h3 id="第33章-并派"><a href="#第33章-并派" class="headerlink" title="第33章 并派"></a>第33章 并派</h3><p>​    他闲步一会，心想六兄弟的架该打完了，不妨便去跟他们一起喝酒，忽听得身后脚步声轻响，有个女子声音叫道：“掌门师兄！”令狐冲转过身来，见是仪琳。她走上前来，轻声道：“我问你一句话，成不成？”令狐冲微笑道：“当然成啊，什么事？”仪琳道：“到底你喜欢任大小姐多些，还是喜欢你那个姓岳的小师妹多些？” </p><p>令狐冲一怔，微感尴尬，道：“你怎么忽然问起这件事来？”仪琳道：“是仪和、仪清师姊她们叫我问的。”令狐冲更感奇怪，微笑道：“她们怎地想到要问这些话？”仪琳低下了头，道：“令狐师兄，你小师妹的事，我从来没跟旁人说过。那日仪和师姊剑伤岳小姐，双方生了嫌隙。仪真、仪灵两位师姊奉你之命送去伤药，华山派非但不收，还把两位师姊轰了出来。大家怕惹你生气，也没敢跟你说。后来于嫂和仪文师姊又上华山去，报知你接任恒山掌门，却让华山派给扣了起来。” </p><p>令狐冲微微一惊，道：“你怎知道？”仪琳忸怩道：“是那田……不可不戒说的。”令狐冲道：“田伯光？”仪琳道：“正是。你去了黑木崖之后，师姊们叫他上华山去探听讯息。”令狐冲点头道：“田伯光轻功了得，打探消息，不易为人发觉。他见到了报讯的两位师姊？”仪琳道：“是。不过华山派看守得很严，他若不伤人，没法相救，好在两位师姊也没吃苦。我写给他的条子上说，千万不可得罪了华山派，更加不得动手伤人，以免惹你生气。”令狐冲微笑道：“你写了条子对他说，倒像是师父的派头！”仪琳脸上一红，道：“我在见性峰，他在通元谷，有事通知他，只好写了条子，叫佛婆送去给他。”令狐冲笑道：“是了，我是说笑话。田伯光又说些什么？”<br>    仪琳道：“他说见到一场喜事，你从前的师父招女婿……”突然之间，只见令狐冲脸色大变，她心下惊恐，便停了口。<br>    令狐冲喉头哽住，呼吸艰难，喘着气道：“你说好啦，不……不要紧。”听到自己语音乾涩，几乎不像是自己说的话。<br>    仪琳柔声道：“令狐师兄，你别难过。仪和、仪清师姊她们都说，任大小姐虽是魔教中人，但容貌既美，武功又高，对你又一心一意，那一点都比岳小姐强上十倍。” </p><p>令狐冲见她渐渐走远，唤道：“师妹！”仪琳停步回头。令狐冲问道：“和我师妹成亲的，是……是……”<br>    仪琳点头道：“是！便是那个姓林的。”她快步走到令狐冲面前，拉住他右手衣袖，说道：“令狐师兄，那姓林的没半分及得上你。岳小姐是个胡涂人，才嫁给他，师姊们怕你生气，一直没敢跟你说。可是桃谷六仙说，我爹爹和田伯光便在左近。田伯光见到了你，多半会跟你说。就算田伯光不说，再过几天，便上嵩山了，定会遇上岳小姐和她丈夫。那时你见到她改了装，穿着新媳妇打扮，说不定……说不定……有碍大事。大家都说，倘若任大小姐在你身边，那就好了。众师姊叫我来劝劝你，别把那个又胡涂又没良心的岳姑娘放在心上。” </p><p>​    这一番奔驰，直奔出二十馀里，到了一处荒无人迹的所在，只觉悲从中来，不可抑制，扑在地下，放声大哭。哭了好一会，心中才稍感舒畅，寻思：“我这时回去，双目红肿，若教仪和她们见了，不免笑话于我，不如晚上再回去罢。”但转念又想：“我久出不归，她们定然担心。大丈夫要哭便哭，要笑便笑。令狐冲苦恋岳灵珊，天下知闻。她弃我有若敝屣，我若不伤心，反倒是矫情做作了。” </p><p>令狐冲道：“是。少林方证大师和武当冲虚道长到了没有？”左冷禅淡淡的道：“他二位住得虽近，但自持身分，是不会来的。”说着向令狐冲瞪了一眼，目光中深有恨意。令狐冲一怔，便即省悟：“我接任掌门，这两位武林前辈亲临道贺。左冷禅却以为他们今日不会来，因此不但恨上了方证大师和冲虚道长，对我可恨得更加厉害了。”<br>    便在此时，忽见山道上两名黄衣弟子疾奔而上，全力快跑，显是身有急事。峰顶上诸人不约而同的都向这二人瞧去。不多时两人奔到左冷禅身前，禀道：“恭喜师父，少林寺方丈方证大师、武当派掌门冲虚道长，率领两派门人弟子，正上山来。”<br>    左冷禅道：“他二位老人家也来了？那可客气得很啊。这可须得下去迎接了。”他语气似乎没将这件事放在心上。但令狐冲见他衣袖微微颤动，心中喜悦之情毕竟难以遮掩。 </p><p>岳夫人又悲又喜，说道：“你小师妹和你林师弟，上个月在华山已成……成了亲。”她口气颇有些担忧，生怕令狐冲所以如此急切的要重回华山，只是为了岳灵珊，一听到她嫁人的讯息，就算不发作吵闹，也非大失所望不可。<br>    令狐冲心中一阵酸楚，微微侧头，向岳灵珊瞧去，只见她已改作了少妇打扮，衣饰颇为华丽，但容颜一如往昔，并无新嫁娘那种容光焕发的神情。 </p><p>她目光和令狐冲一触，突然间满脸通红，低下头去。<br>    令狐冲胸口便如给大铁锤重重打了一下，霎时间眼前金星乱冒，身子摇晃，站立不定，耳边隐隐听得有人说道：“令狐掌门，你是远客，反先到了。少林寺和峻极禅院近在咫尺，老衲却来得迟了。”令狐冲觉得有人扶住了自己左臂，定了定神，见方证大师笑容可掬的站在身前，忙道：“是，是！”拜了下去。 </p><p>他跟随众人，来到封禅台下，寻思：“听师父口气，是肯原宥我的过失，准我重回华山门下。为什么师父从前十分严厉，今日却脸色什好？是了，多半他打听之下，得知我在恒山行为端正，绝无秽乱恒山门户，心中欢喜。小师妹嫁了林师弟，他二位老人家对我觉得有些过意不去，又知我没偷盗紫霞秘笈、吞没辟邪剑谱，以前冤枉错了我，再加上师娘一再劝说，师父这才回心转意。今日左冷禅力图吞并四派，师父身为华山掌门，自要竭力抗拒。他待我好些，我就可以和他联手，力保华山一派。这一节我自当尽力，不负他老人家期望，同时也保全了恒山派。” </p><p>​    左冷禅道：“想我五岳剑派向来同气连枝，百馀年来携手结盟，早便如同一家，兄弟忝为五派盟主，亦已多历年所。只是近年来武林中出了不少大事，兄弟与五岳剑派的前辈师兄们商量，均觉若非联成一派，统一号令，则来日大难，只怕不易抵挡。”<br>​    忽听得台下有人冷冷的道：“不知左盟主跟那一派的前辈师兄们商量过了？怎地我莫某人不知其事？”说话的正是衡山派掌门人莫大先生。他此言一出，显见衡山派是不赞成合并的。 </p><p>建除道人大声道：“你若能对祖师爷的铁剑立下重誓，决不让祖师爷当年辛苦缔造的泰山派在江湖中除名，那么大家拥你为本派掌门，原也不妨。但若你一当掌门，立即将本派出卖给嵩山派，那可是本派的千古罪人，你就死了，也没面目去见祖师爷。”<br>    玉音子道：“你后生小子，凭什么跟我们‘玉’字辈的前人说话？五派合并，嵩山派还不是一样的除名？五岳派这‘五岳’二字，就包括泰山在内，又有什么不好了？” </p><pre><code class="hljs">令狐冲寻思：“师父曾说，华山气剑二宗之争，是本派门户之羞，实不足为外人道，为什么他此刻却当着天下英雄公然谈论？”又听得岳不群语声尖锐，声传数里，每说一句话，远处均有回音，心想：“师父修习‘紫霞神功’，又到了更高的境界，说话声音，内力的运用，都跟从前不同了。” </code></pre><p>只听桃根仙又道：“如令狐冲不给定闲师太报仇，便做不得恒山派掌门，是不是？如他不是恒山派掌门，便拿不得恒山派的主意，是不是？如他拿不得恒山派的主意，那么恒山派是否加入五岳派，便不能由令狐冲来说话了，是不是？”他问一句，桃谷五仙又齐声答一句：“是！”<br>    桃干仙道：“一派不能没有掌门，令狐冲既然做不得恒山派掌门，便须另推高明，是不是？恒山派中有那六位英雄武功高强，见识不凡，当年定闲师太固然早有定评，连五岳剑派左盟主刚才也说：‘六位武功高强，见识不凡，我都是久仰的’，是不是？”<br>    桃干仙这么问，他五兄弟便都答一声：“是！”问的人声音越来越响，答的人也越答越起劲。与会的群雄一来确实觉得好笑，二来见到有人与嵩山派捣蛋，多少有些幸灾乐祸的心情，颇有人跟着起哄，数十人随着桃谷五仙齐声叫道：“是！” </p><p>当岳不群赞成五派合并之后，令狐冲心中便即大感混乱，这时听桃谷六仙胡说八道的捣乱，内心深处颇觉欢喜，似乎这六兄弟正在设法为自己解围脱困，但再听一会，突然奇怪：“桃谷六仙说话素来缠夹，前言不对后语，可是来到嵩山之后，每一句竟都含有深意。刚才这些言语似乎强辞夺理，可是事先早有伏笔，教人难以辩驳，跟他们平素乱扯一顿的情形大不相同。难道暗中另有高人在指点吗？” </p><p>只听得桃花仙道：“恒山派中这六位武功卓绝、识见不凡的大英雄是谁，各位不是蠢人，想来也必知道，是不是？”百馀人笑着齐声应道：“是！”桃花仙道：“天下是非自有公论，公道自在人心。请问再这六位大英雄是谁？”二百馀人在大笑声中说道：“自然是你们桃谷六仙了。”<br>    桃根仙道：“照啊，如此说来，恒山派掌门的位子，我们六兄弟只好当仁不让，勉为其难，德高望重，众望所归，水到渠成，水落石出，高山滚鼓，门户大门……” </p><p>他乱用成语，越说越不知所云，群雄无不捧腹大笑。<br>    嵩山派中不少人大声框喝：“你六个家伙在这里捣什么乱？快跟我滚下山去。”<br>    桃枝仙道：“奇哉怪也！你们嵩山派千方百计的要搞五派合并，我恒山派的六位大英雄诚意来到嵩山，你们居然要赶我们下去。我们六位大英雄一走，恒山派其馀的小英雄、女英雄们，自然跟着也都下了嵩山，你们这五派合并，便稀哩呼噜，搞不成了。好！恒山派的朋友们，咱们都下山去，让他们搞四派合并。左冷禅爱做四岳派掌门，便由他做去。咱们恒山派可不凑这个热闹。” </p><h3 id="第34章-比剑"><a href="#第34章-比剑" class="headerlink" title="第34章 比剑"></a>第34章 比剑</h3><p>令狐冲与桃谷六仙相处日久，深知他们为人，寻思：“今日桃谷六仙所说的话，句句击中左冷禅的要害。他六兄弟的脑筋怎能如此清楚？多半暗中另行有人指点。”慢慢走近桃谷六仙身旁，想察看到底是那位高人隐身其侧，但见桃谷六仙聚在一起，身边并无旁人，五兄弟正手忙脚乱的为桃花仙肩头止血。令狐冲转过头来，向西首瞧去，耳中忽然传来细若蚊鸣的声音：“冲哥，你是在找我吗？” </p><p>令狐冲心道：“林师弟向来拘谨，不多说话，不料士别三日，便当刮目相看，竟在天下英雄之前，出言讥讽这两个贼道。”适才玉磬子、玉音子二道与玉玑子狼狈为奸，逼死泰山派掌门人天门道人，向左冷禅谄媚讨好，令狐冲心中对二道极是不满，听得林平之如此辱骂，颇为痛快。 </p><h3 id="第35章-夺帅"><a href="#第35章-夺帅" class="headerlink" title="第35章 夺帅"></a>第35章 夺帅</h3><p>左冷禅这时听得岳不群父女俩口出大言，心想：“你不知如何学到了五岳剑派一些失传的绝招，便狂妄自大起来。你若在和我动手之际，突然之间使将出来，倒可吓人一跳，可是偏偏行错了一着棋，叫你女儿先使，我既已有备，复有何用？”又想：“此人极工心计，须得当着群豪之前打得他从此抬不起头来，否则此人留在我五岳派中，必有后患。”说道：“岳兄，天下英雄都请你上台，一显身手，怎地不给人家面子？” </p><p>岳不群道：“左兄既如此说，在下恭敬不如从命。”当下一步一步的拾级上台。 </p><p>令狐冲给长剑插入肩胛，自背直透至前胸，受伤自是极重。盈盈看得分明，心急之下，顾不得掩饰自己身分，抢过去拔起长剑，将他抱起。恒山派众女弟子纷纷围了上来。仪和取出“白云熊胆丸”，手忙脚乱的倒出五六颗丸药，喂入令狐冲口里。盈盈早已伸指点了他前胸后背伤口四周的穴道，止住鲜血迸流。仪清和郑萼分别以“天香断续胶”搽在他伤口上。掌门人受伤，群弟子那里会有丝毫吝惜？敷药唯恐不多，将千金难买的灵药，当作石灰烂泥一般，厚厚的涂上他伤口。 </p><p>令狐冲受伤虽重，神智仍然清醒，见盈盈和恒山弟子情急关切，登感歉仄：“为了哄小师妹一笑，却累得盈盈和恒山众师姊妹如此担惊受怕。”当下强露笑容，说道：“不知怎地，一个不小心，竟让……竟让这剑给伤了。不……不要紧的，不用……”<br>    盈盈道：“别作声。”她虽尽量放粗了喉咙，毕竟女音难掩。恒山弟子听得这个虬髯汉子话声娇嫩，均感诧异。 </p><p>令狐冲听到念经声中所充满的虔诚和热切之情，便知是仪琳又在为自己向观世音祈祷，求恳这位救苦救难的菩萨解除自己的苦楚。许多日子以前，在衡山城郊，仪琳曾为他诵念这篇经文。这时他并未转头去看，但当时仪琳那含情脉脉的眼光，温雅秀美的容貌，此刻又清清楚楚的出现在眼前。他心中涌起一片柔情：“不但是盈盈，还有这仪琳小师妹，都将我看得比自己性命还重。我纵然粉身碎骨，也难报答深恩。” </p><p>眼见左冷禅胜势已定，嵩山派群弟子大声呐喊助威。左冷禅一剑快似一剑，见对方剑法散乱，十招之内便可将他手中兵刃击飞，不禁暗喜，手上更连连催劲。果然他一剑横削，岳不群举剑挡格，手上劲力颇为微弱，左冷禅回剑疾撩，岳不群把揑不住，长剑直飞上天。嵩山派弟子欢声雷动。<br>    蓦地里岳不群空手猱身而上，双手擒拿点拍，攻势凌厉之极。他身形飘忽，有如鬼魅，转了几转，移步向西，出手之奇之快，直是匪夷所思。左冷禅大骇，叫道：“这……这……这……”奋剑招架。岳不群的长剑落了下来，插在台上，谁都没加理会。<br>    盈盈低声道：“东方不败！”令狐冲心中念头相同，此时师父所使的，正是当日东方不败手持绣花针和他四人相斗的功夫。他惊奇之下，竟忘了伤处剧痛，站起身来。旁边一只纤纤小手伸了过来，托在他腋下，他全然不觉；一双妙目怔怔的瞧着他，他也茫无所知。 </p><p>这时嵩山绝顶之上，数千对眼睛，只有一双眼睛才不瞧左岳二人相斗。自始至终，仪琳的眼光未有片刻离开过令狐冲身子。 </p><p>过了片刻，见左冷禅始终只是自行舞剑，并不向岳不群进攻，情形似乎有些不对。<br>    他的剑招只是守御，绝非向岳不群攻击半招，如此使剑，倒似是独自练功一般，又怎是应付劲敌的打法？突然之间，左冷禅一剑刺出，停在半空，不再收回，微微侧头，似在倾听什么奇怪的声音。只见他双眼中流下两道极细的血线，横过面颊，直挂到下颏。<br>    人丛中有人说道：“他眼睛瞎了！”<br>    这一声说得并不什响，左冷禅却大怒起来，叫道：“我没瞎，我没瞎！那一个狗贼说我瞎了？岳不群你这奸贼，有种的，就过来和你爷爷再战三百回合。”他越叫越响，声音中充满了愤怒、痛楚和绝望，便似是一头猛兽受了致命重伤，临死时全力嗥叫。 </p><p>令狐冲见师父得胜，心下并不喜悦，反突然感到说不出的害怕。岳不群性子温和，待他向来亲切，他自小对师父挚爱实胜于敬畏。后来师父将他逐出门墙，他也深知自己行事乖张任性，浮滑胡闹，确属罪有应得，只盼能得师父师娘宽恕，从未生过半分怨怼之意。但这时见到师父大袖飘飘的站在封禅台边，神态儒雅潇洒，不知如何，心中竟生起了强烈的憎恨。或许由于岳不群所使的武功，令他想到了东方不败的怪模怪样，也或许他觉得师父胜得殊不光明正大，他呆了片刻，伤口一阵剧痛，便即颓然坐倒。 </p><p>盈盈和仪琳同时伸手扶住，齐问：“怎样？”令狐冲摇了摇头，勉强露出微笑，道：“没……没什么。” </p><p>令狐冲目送着师父的背影在山峰边消失，各派人众也都走下峰去，忽听得背后一个女子声音恨恨的道：“伪君子！”<br>    令狐冲身子一晃，伤处剧烈疼痛，这“伪君子”三字，便如是一个大铁椎般，在他当胸重重一击，霎时之间，他几乎气也喘不过来。</p><h3 id="第36章-复仇"><a href="#第36章-复仇" class="headerlink" title="第36章 复仇"></a>第36章 复仇</h3><p>对付盈盈，他可立刻聪明起来，这时既无话可说，最好便什么话都不说，但更好的法子，是将她心思引开，不去想刚才的事，当下慢慢躺倒，忽然轻轻哼了一声，显得触到背上的伤痛。盈盈果然十分关心，过来低声问道：“碰痛了吗？”令狐冲道：“还好。”伸过手去，握住了她手。盈盈想要甩脱，但令狐冲抓得很紧。她生怕使力之下，扭痛了他伤口，只得任由他握着。令狐冲失血极多，疲困殊什，过了一会，迷迷糊糊的也就睡着了。 </p><p>次晨醒转，已红日满山。众人怕惊醒了他，都没敢说话。令狐冲觉得手中已空，不知什么时候，盈盈已将手抽回了，但她一双关切的目光却凝视着他脸。令狐冲向她微微一笑，坐起身来，说道：“咱们回恒山去罢！” </p><p>恒山派一行散在店铺与人家的屋檐下。盈盈独自坐在一辆骡车之中，与令狐冲的骡车离得远远地。虽然她与令狐冲的恋情早已天下知闻，但她腼腆之情竟不稍减。恒山女弟子为令狐冲敷伤换药，她正眼也不去瞧。郑萼、秦绢等知她心意，不断将令狐冲伤势情形说给她听，盈盈只微微点头，不置一辞。 </p><p>​    盈盈低声道：“你静静的养伤，别胡思乱想，我去睡了。”令狐冲道：“是。”掀开车帷，只见月光如水，映在盈盈脸上，突然之间，心下只觉十分对她不起。盈盈慢慢转过身去，忽道：“你那林师弟，穿的衣衫好花！”说了这句话，走向自己骡车。 </p><p>令狐冲微觉奇怪：“她说林师弟穿的衣衫好花，那是什么意思？林师弟刚做新郎，穿的是新婚时的衣饰，也没什么希奇。这女孩子，不注意人家的剑法，却去留神人家的衣衫，真有趣。”他一闭眼，脑海中出现的只是林平之那一剑刺出时的闪光，到底林平之穿的是什么花式的衣衫，可半点也想不起来。 </p><p>令狐冲惊呼一声，叫道：“不要脸，不要脸！”忽听盈盈说道：“那日咱们对付东方不败，也就是这个打法。”不知在什么时候，她已到了身边。令狐冲心想不错，那日黑木崖之战，己方四人已然败定，幸亏盈盈转而进攻杨莲亭，分散了东方不败的心神，才致他死命。此刻余沧海所使的正便是这计策，他们如何击毙东方不败，余沧海自然不知，只是情急智生，想出来的法子竟不谋而合。料想林平之见到爱妻遇险，定然分心，自当回身去救，不料他全力和余沧海相斗，竟全不理会妻子身处奇险。 </p><p>盈盈突然纵身而出，奔到江边，腰间一探，手中已多了两柄短剑，朗声道：“你们瞧清楚了，我是日月神教任教主之女任盈盈便是，可不是恒山派的。你们六个大男人，合手欺侮一个女流之辈，教人看不过去。任姑娘路见不平，这桩事得管上一管。”<br>    令狐冲见盈盈出手，不禁大喜，吁了一口长气，只觉伤口剧痛，坐倒车中。 </p><p>林平之更不再向青城派众人多瞧一眼，纵马驰到岳灵珊和盈盈的身边，向妻子道：“上马！”岳灵珊向他怒目而视，过了一会，咬牙说道：“你自己去好了。”林平之问道：“你呢？”岳灵珊道：“你管我干么？”林平之向恒山派群弟子瞧了一眼，冷笑一声，双腿一夹，纵马绝尘而去。 </p><p>盈盈料想不到林平之对他新婚妻子竟会如此绝情，不禁愕然，说道：“林夫人，你到我车中歇歇。”岳灵珊泪水盈眶，竭力忍住不让眼泪流下，呜咽道：“我……我不去。你……你为什么要救我？”盈盈道：“不是我救你，是你大师哥要救你。”岳灵珊心中一酸，再也忍耐不住，眼泪涌出，说道：“你……请你借我一匹马。”盈盈道：“好。”转身去牵了一匹马过来。岳灵珊道：“多谢，你……你……”跃上马背，勒马转向东行，和林平之所去方向相反，似是回向嵩山。 </p><p>令狐冲一见到岳灵珊，胸口一热，心中大喜，却见岳灵珊双手反缚背后，坐骑的缰绳也牵在木高峰手中，显是为他擒住了，忍不住便要发作，转念又想：“她丈夫便在这里，何必要我外人强行出头？倘若她丈夫不理，那时再设法相救不迟。” </p><p>林平之哈哈大笑，叫道：“我报了仇啦，我报了仇啦！” </p><p>令狐冲道：“小师妹，你拿些伤药去，给林师弟敷上。扶他到我们的车中休息。”岳灵珊道：“多……多谢。”林平之大声道：“不要！要他卖什么好！姓林的是死是活，跟他有什相干？”令狐冲一怔，心想：“我几时得罪你了？为什么你这么恨我？”岳灵珊柔声道：“恒山派的治伤灵药，天下有名，难得……”林平之怒道：“难得什么？”岳灵珊叹了口气，又将一盆清水轻轻从他头顶淋下。这一次林平之却只哼了一声，咬紧牙关，没再呼叫，说道：“他对你这般关心，你又一直说他好，为什么不跟了他去？你还理我干么？” </p><p>恒山群弟子听了他这句话，尽皆相顾失色。仪和大声道：“你……你……竟敢说这等不要脸的话？”仪清忙拉了拉她袖子，劝道：“师姊，他伤得这个样子，心情不好，何必跟他一般见识？”仪和怒道：“呸！我就是气不过……”<br>    这时岳灵珊拿了一块手帕，正在轻按林平之面颊上的伤口。林平之突然右手用力一推。岳灵珊全没防备，立时摔了出去，砰的一声，撞在草棚外的一堵土墙上。<br>    令狐冲大怒，喝道：“你……”但随即想起，他二人乃是夫妻，夫妻间口角争执，什至打架，旁人也不便干预，何况听林平之的言语，显是对自己颇有疑忌，话中大含醋意，自己一直苦恋小师妹，林平之当然知道，他重伤之际，自己更不能介入其间，当即强行忍住，但已气得全身发抖。 </p><p>林平之冷笑道：“我说话不要脸？到底是谁不要脸了？”手指草棚之外，说道：“这姓余的矮子、姓木的驼子，他们想得我林家的辟邪剑法，便出手硬夺，害死我父亲母亲，虽然凶狠毒辣，还不失为江湖上恶汉光明磊落的行径，那像……”回身指向岳灵珊，续道：“那像你的父亲伪君子岳不群，却以卑鄙奸猾的手段，来谋取我家的剑谱。” </p><p>岳灵珊正扶着土墙，慢慢站起，听他这么说，身子一颤，复又坐倒，颤声道：“那……那有此事？”<br>    林平之冷笑道：“无耻贱人！你父女俩串谋好了，引我上钩。华山派掌门的岳大小姐，下嫁我这穷途末路、无家可归的小子，那为了什么？还不是为了我林家的辟邪剑谱。剑谱既已骗到了手，还要我姓林的干什么？”<br>    岳灵珊“啊”的一声，哭了出来，哭道：“你……冤枉好人，我若有此意，教我……教我天诛地灭。”<br>    林平之道：“你们暗中设下奸计，我初时蒙在鼓里，毫不明白。此刻我双眼盲了，反更加看得清清楚楚。你父女俩若非有此存心，为什么……为什么……” </p><p>岳灵珊慢慢走到他身畔，说道：“你别胡思乱想，我对你的心，跟从前没半点分别。”林平之哼了一声。岳灵珊道：“咱们回去华山好好养伤。你眼睛好得了也罢，好不了也罢。我岳灵珊如有三心两意，教我……教我死得比这余沧海还惨。”林平之冷笑道：“也不知你心中又在打什么鬼主意，来对我这等花言巧语。” </p><p>岳灵珊不再理他，向盈盈道：“姊姊，我想跟你借一辆大车。”盈盈道：“自然可以。请两位恒山派的师姊送你们一程，好不好？”岳灵珊不住呜咽，道：“不……不用了，多……多谢。”盈盈拉过一辆车来，将骡子的缰绳和鞭子交在她手里。 </p><p>当日众人只行出十馀里，便在一所破祠堂中歇宿。令狐冲睡到半夜，好几次均为噩梦所缠，昏昏沉沉中忽听得一缕微声钻入耳中，有人在叫：“冲哥，冲哥！”令狐冲嗯了一声，醒了过来，只听得盈盈的声音道：“你到外面来，我有话说。”<br>    令狐冲忙即坐起，走到祠堂外，只见盈盈坐在石级上，双手支颐，望着白云中半现的明月。令狐冲走到她身边，和她并肩而坐。夜深人静，四下里半点声息也无。 </p><p>过了好一会，盈盈道：“你在挂念小师妹？”令狐冲道：“是。许多情由，令人好生难以明白。”盈盈道：“你担心她受丈夫欺侮？”令狐冲叹了口气，道：“他夫妻俩的事，旁人又怎管得了？”盈盈道：“你怕青城弟子赶去向他们生事？”令狐冲道：“青城弟子痛于师仇，又见到他夫妻已然受伤，赶去意图加害，也是情理之常。”盈盈道：“你怎不设法前去相救？”令狐冲又叹了口气，道：“听林师弟的语气，对我颇有疑忌之心。我虽好意援手，只怕更伤了他夫妻间的和气。” </p><p>盈盈道：“这是其一。你心中另有顾虑，生怕令我不快，是不是？”令狐冲点了点头，伸出手去握住她左手，只觉她手掌什凉，柔声道：“盈盈，在这世上，我只有你一人，倘若你我之间也生了嫌隙，做人还有什么意味？” </p><p>盈盈缓缓将头倚过去，靠在他肩上，说道：“你心中既这样想，你我之间又怎会生什么嫌隙？事不宜迟，咱们就追赶前去，别要为了避什么嫌疑，致贻终生之恨。”令狐冲矍然而惊：“致贻终身之恨，致贻终生之恨！”似乎眼见数十名青城弟子正围在林平之、岳灵珊所乘大车之旁，数十柄长剑正在向车中乱刺狠戳，不由得身子一颤。 </p><p>当令狐冲向仪和、仪清吩咐之时，盈盈站在一旁，转过了头，不敢向仪和、仪清瞧上一眼，心想自己和令狐冲孤男寡女，同车夜行，只怕为她二人所笑，直到骡车行出数里，这才吁了口气，颊上红潮渐退。 </p><p>令狐冲提起几件衣服，月光下看得分明，竟然便是老农夫和老农妇的衣服，尤其那件农妇的衫子十分宽大，镶着白底青花的花边，式样古老，并非年轻农家姑娘或媳妇的衣衫。这些衣物中还有男人的帽子，女装的包头，又有一根旱烟筒。<br>    盈盈笑道：“你是令狐半仙，猜到这乡下人家有个婆婆，只可惜没孩儿……”说到这里，便红着脸住了口。令狐冲微笑道：“原来他们是兄妹二人，这两兄妹当真要好，一个不娶，一个不嫁，活到七八十岁，还是住在一起。”盈盈笑着啐了一口，道：“你明知不是的。”令狐冲道：“不是兄妹么？那可奇了。” </p><pre><code class="hljs">盈盈忍不住好笑，当下在骡车之后，将老农妇的衫裙罩在衣衫之上，又将包头包在自己头顶，双手在道旁抓些泥尘，抹在自己脸上，这才帮着令狐冲换上老农的衣衫。令狐冲和她脸颊相距不过数寸，但觉她吹气如兰，不由得心中一荡，便想伸手搂住她亲上一亲，只是想到她为人端严，半点亵渎不得，要是冒犯了她，惹她生气，有何后果可难以料想，当即收摄心神，一动也不敢动。 </code></pre><p>他眼神突然显得轻狂异样、随又庄重克制之态，盈盈都瞧得分明，微笑道：“乖孙子，婆婆这才疼你。”伸出手掌，将满掌泥尘往他脸上抹去。令狐冲闭住眼，只感她掌心温软柔滑，在自己脸上轻轻的抹来抹去，说不出的舒服，只盼她永远的这么抚摸不休。过了一会，盈盈道：“好啦，黑夜之中，你小师妹一定认不出，只小心别开口。”令狐冲道：“我头颈中也得抹些尘土才是。” </p><p>盈盈笑道：“谁瞧你头颈了？”随即会意，令狐冲是要自己伸手去抚摸他头颈，弯起中指，在他额头轻轻打个爆栗，回身坐在车夫位上，一声唿哨，赶骡便行，突然间忍不住好笑，越笑越大声，竟弯住了腰，难以坐直。 </p><p>盈盈笑道：“那老婆婆是在说他们没成亲时的事……”说到这里，挺腰一提缰绳，骡子又快跑起来。令狐冲道：“没成亲时怎样啦？他们一定规矩得很，半夜三更就是一起坐在大车之中，也一定不敢抱一抱，亲一亲。”盈盈呸了一声，不再说了。令狐冲道：“好妹子，亲妹子，他们说些什么，你说给我听。”盈盈微笑不答。 </p><p>黑夜之中，但听得骡子的四只蹄子打在官道之上，清脆悦耳。令狐冲向外望去，月色如水，泻在一条既宽且直的官道上，轻烟薄雾，笼罩在道旁树梢，骡车缓缓驶入雾中，远处景物便看不分明，盈盈的背脊也裹在一层薄雾之中。其时正当入春，野花香气忽浓忽淡，微风拂面，说不出的欢畅。令狐冲久未饮酒，此刻情怀，却正如微醺薄醉一般。 </p><p>她不再催赶骡子，大车行得渐渐慢了，行了一程，转了个弯，来到一座大湖之畔。湖旁都是垂柳，圆圆的月影倒映湖中，湖面水波微动，银光闪闪。<br>    盈盈轻声问道：“冲哥，你睡着了吗？”令狐冲道：“我睡着了，我正在做梦。”盈盈道：“你在做什么梦？”令狐冲道：“我梦见带了一大块牛肉，摸到黑木崖上，去喂你家的狗。”盈盈笑道：“你为人不正经，做的梦也不正经。” </p><p>两人并肩坐在车中，望着湖水。令狐冲伸过右手，按在盈盈左手的手背上。盈盈的手微微一颤，却不缩回。令狐冲心想：“若得永远如此，不再见到武林中的腥风血雨，便叫我做神仙，也没这般快活。”<br>    盈盈道：“你在想什么？”令狐冲将适才心中所想说了出来。盈盈反转左手，握住了他右手，说道：“冲哥，我真快活。”令狐冲道：“我也一样。”盈盈道：“你率领群豪攻打少林寺，我虽感激，可也没此刻欢喜。倘若我是你的好朋友，陷身少林寺中，你为了江湖上的义气，也会奋不顾身前来救我。可是这时候你只想到我，没想到你小师妹……” </p><p>岳灵珊道：“爹爹本是派二师哥去福州的。是我想下山来玩儿，定要跟着二师哥去。”林平之道：“你爹爹管治门人弟子如此严厉，倘若他认为不妥，便任你跪着哀求三日三夜，也决不会准许。只因他信不过二师哥，这才派你在旁监视。”<br>    岳灵珊默然，似乎觉得林平之的猜测也非全然没道理，隔了一会，说道：“你信也好，不信也好，总之我到福州之前，从未听见过‘辟邪剑谱’四字。爹爹只说，大师哥打了青城弟子，双方生了嫌隙，现下青城派人众大举东行，只怕于我派不利，因此派二师哥和我去暗中查察。”<br>    林平之叹了口气，似乎心肠软了下来，说道：“好罢，我便再信你一次。可是我已变成这样子，你跟着我又有什么意思？你我仅有夫妻之名，并无夫妻之实。你还是处女之身，这就回头……回头到令狐冲那里去罢！” </p><p>只听岳灵珊幽幽的道：“我只和你成亲三日，便知你心中恨我极深，虽和我同房，却不肯和我同床。你既这般恨我，又何必……何必……娶我？”林平之叹了口气，说道：“我没恨你。”岳灵珊道：“你不恨我？那为什么日间假情假意，对我亲热之极，一等晚上回到房中，连话也不跟我说一句？爸爸妈妈几次三番查问你待我怎样，我总是说你很好，很好，很好……哇……”说到这里，突然纵声大哭。<br>    林平之一跃上车，双手握住她肩膀，厉声道：“你说你爹妈几次三番的查问，要知道我待你怎样，此话当真？”岳灵珊呜咽道：“自然是真的，我骗你干么？”林平之问道：“明明我待你不好，从来没跟你同床。那你又为什么说很好？”岳灵珊泣道：“我既嫁了你，便是你林家的人了。只盼你不久便回心转意。我对你一片真心，我……我怎可编排自己夫君的不是？” </p><p>林平之半晌不语，只咬牙切齿，过了好一会，才慢慢的道：“哼，我只道你爹爹顾念着你，对我还算手下留情，岂知全仗你从中遮掩。你若不是这么说，姓林的早就死在华山之巅了。” </p><p>岳灵珊道：“可是，你一直没跟我说已学会了这套剑法。”林平之道：“我怎么敢说？令狐冲在福州抢到了那件袈裟，毕竟还是拿不去，只不过录着剑谱的这件袈裟，却落入了你爹爹手中……”岳灵珊尖声叫道：“不，不会的！爹爹说，剑谱给大师哥拿了去。我曾求大师哥还给你，他说什么也不肯。”林平之哼的一声冷笑。岳灵珊又道：“大师哥剑法厉害，连爹爹也敌他不过，难道他所使的不是辟邪剑法？不是从你家的辟邪剑谱学的？”<br>    林平之又一声冷笑，说道：“令狐冲虽然奸猾，比起你爹爹来，可又差得远了。再说，他的剑法乱七八糟，怎能跟我家的辟邪剑法相比？在封禅台侧比武，他连你也比不过，在你剑底受了重伤，哼哼，又怎能跟我家的辟邪剑法相比？”岳灵珊低声道：“他是故意让我的。”林平之冷笑道：“他对你的情义可深着哪！” </p><p>这句话盈盈倘若早一日听见，虽早知令狐冲比剑时故意容让，仍会恼怒之极，可是今宵二人良夜同车，湖畔清谈，已然心意相照，她心中反而感到一阵甜蜜：“他从前确是对你很好，可是现下却待我更加好得多了。这可怪不得他，不是他对你变心，实在是你欺侮得他太也狠了。” </p><p>​    岳灵珊叹了口气，说道：“那日在向阳巷中，这件袈裟给嵩山派的坏人夺了去。大师哥杀了这二人，将袈裟夺回，未必是想据为己有。大师哥气量大得很，从小就不贪图旁人的物事。爹爹说他取了你的剑谱，我一直有点怀疑，只是爹爹既这么说，又见大师哥剑法突然大进，连爹爹也及不上，这才不由得不信。”<br>​    盈盈心道：“你能说这几句话，不枉了冲郎爱你一场。” </p><p>林平之冷笑道：“他这么好，你为什么又不跟他去？”岳灵珊道：“平弟，你到此刻，还是不明白我的心。大师哥和我从小一块儿长大，在我心中，他便是我的亲哥哥一般。我对他敬重亲爱，只当他是兄长，从来没当他是情郎。自从你来到华山之后，我跟你说不出的投缘，只觉一刻不见，心中便抛不开，放不下，我对你的心意，永永远远也不会变。”<br>    林平之道：“你和你爹爹原有些不同，你……你更像你妈妈。”语气转为柔和，显然对岳灵珊的一片真情，心中也颇感动。 </p><p>林平之道：“你这么说，只因为你既不明白你爹爹为人，也不明白这辟邪剑谱到底是什么东西。”岳灵珊道：“我虽对你死心塌地，可是对你的心，我实在也不明白。”林平之道：“是了，你不明白！你当然不明白！你又何必要明白？”说到这里，语气又暴躁起来。<br>    岳灵珊不敢再跟他多说，道：“嗯，咱们走罢！”林平之道：“上那里去？”岳灵珊道：“你爱去那里，我也去那里。天涯海角，总是和你在一起。”林平之道：“你这话当真？将来不论如何，可都不要后悔。”岳灵珊道：“我决心和你好，决意嫁你，早就打定了一辈子的主意，那里还会后悔？你的眼睛受伤，又不是一定治不好，就算真的难以复原，我也永远陪着你，服侍你，直到我俩一起死了。”<br>    这番话情意真挚，盈盈在高粱丛中听着，不禁心中感动。 </p><p>猛听得林平之一声大叫，声音凄厉，跟着喝道：“滚开！别过来！”盈盈大吃一惊，心道：“干什么了？为什么这姓林的这么凶？”跟着便听得岳灵珊哭了出来。林平之喝道：“走开，走开！快走得远远的，我宁可给你父亲杀了，不要你跟着我。”岳灵珊哭道：“你这样轻贱于我……到底……到底我做错了什么……”林平之道：“我……我……”顿了一顿，又道：“你……你……”但又住口不说。<br>    岳灵珊道：“你心中有什么话，尽管说个明白。倘若真是我错了，即或是你怪我爹爹，不肯原谅，你明白说一句，也不用你动手，我立即横剑自刎。”唰的一声响，拔剑出鞘。 </p><p>盈盈心道：“她这可要给林平之逼死了，非救她不可！”快步走回，离大车什近，以便抢救。<br>    林平之又道：“我……我……”过了一会，长叹一声，说道：“这不是你的错，是我自己不好。”岳灵珊抽抽噎噎的哭个不停，又羞又急，又什气苦。林平之道：“好，我跟你说了便是。”岳灵珊泣道：“你打我也好，杀我也好，就别这样教人家不明不白。”林平之道：“你既对我并非假意，我也就明白跟你说了，好教你从此死了这心。”<br>    岳灵珊道：“为什么？” </p><p>盈盈听到这里，心想：“爹爹曾道，这辟邪剑谱其实和我教的葵花宝典同出一源，基本原理并无二致，无怪岳不群和这林平之的剑法，竟和东方不败如此近似。”又想：“爹爹说道，葵花宝典上的功夫习之有损无益。他知学武之人一见到内容精深的武学秘籍，纵然明知习之有害，却也会陷溺其中，难以自拔。他根本自始就不翻看宝典，那自是最明智的上上之策。”脑中忽然闪过一个念头：“那他为什么传给了东方不败？”<br>    想到这一节，自然而然的就会推断：“原来当时爹爹已瞧出东方不败包藏祸心，传他宝典是有意害他。向叔叔却还道爹爹颟顸懵懂，给东方不败蒙在鼓里，空自着急。其实以爹爹如此精明厉害之人，怎会长期的如此胡涂？只不过人算不如天算，东方不败竟先下手为强，将爹爹捉了起来，囚入西湖湖底。总算他心地还不是坏得到家，倘若那时竟将爹爹一刀杀了，或者吩咐不给饮食，爹爹那里还有报仇雪恨的机会？其实我们能杀了东方不败，也是侥幸之极，若无冲郎在旁援手，爹爹、向叔叔、上官云和我四人，一上来就会给东方不败杀了。又若无杨莲亭在旁乱他心神，东方不败仍是不败。” </p><p>想到这里，不由得觉得东方不败有些可怜，又想：“他囚禁了我爹爹之后，待我着实不薄，礼数周到。我在日月教中便和公主娘娘无异。今日我亲生爹爹身为教主，我反无昔时的权柄风光。唉，我今日已有了冲郎，还要那些劳什子的权柄风光干什么？” </p><p>回思往事，想到父亲的心计深沉，不由得暗暗心惊：“直到今天，爹爹还是没答允将融功的法门传授冲郎。冲郎体内积贮了别人的异种真气，不加融合，祸胎越结越巨，迟早必生大患。爹爹说道，只须他入了我教，不但立即传他此术，还宣示教众，立他为教主的继承之人，可是冲郎偏不肯低头屈从，当真为难得很。”一时喜，一时忧，悄立于高粱丛中，虽说是思潮杂沓，但想来想去，总仍归结在令狐冲身上。 </p><p>这时林平之和岳灵珊也默默无言。过了好一会，听得林平之说道：“远图公一见剑谱之后，当然立即就练。”岳灵珊道：“这套剑法就算真有祸患，也决不会立即发作，总是在练了十年八年之后，才有不良后果。远图公娶妻生子，自是在祸患发作之前的事了。”林平之道：“不……是……的。”这三个字拖得很长，可是语意中并无丝毫犹疑，顿了一顿，道：“我初时也如你这般想，只过得几天便知不然。我爷爷决不能是远图公的亲生儿子，多半是远图公领养的。远图公娶妻生子，只是为了掩人耳目。” </p><p>岳灵珊“啊”的一声，颤声道：“掩人耳目？那……那为了什么？”<br>    林平之哼了一声不答，过了一会，说道：“我见到剑谱之时，和你好事已近。我几次三番想要等到和你成亲之后，真正做了夫妻，这才起始练剑。可是剑谱中所载的招式法门，非任何习武之人所能抗拒。我终于……我终于……自宫习剑……” </p><p>岳灵珊失声道：“你……你自……自宫练剑？”林平之阴森森的道：“正是。这辟邪剑谱的第一道法诀，便是：‘武林称雄，挥剑自宫。’”岳灵珊道：“那……那为什么？”林平之道：“练这辟邪剑法，自练内功入手，再要加炼内丹，服食燥药。若不自宫，练功服药之后，便即欲火如焚，不免走火入魔，僵瘫而死。”岳灵珊道：“原来如此。”语音如蚊，几不可闻。 </p><p>​    只听得岳灵珊轻轻啜泣，说道：“当年远图公假装娶妻生子，是为了掩人耳目，你……你也是……”林平之道：“不错，我自宫之后，仍和你成亲，也是掩人耳目，不过只是要掩你爹爹一人的耳目。” </p><p>岳灵珊呜呜咽咽的只是低泣。林平之道：“我一切都跟你说了，你痛恨我入骨，这就走罢。”岳灵珊哽咽道：“我不恨你，你是为情势所逼，无可奈何。我只恨……只恨当年写下那辟邪剑谱之人，为什么……为什么要这样害人。”林平之嘿嘿一笑，说道：“这位前辈英雄是个太监。” </p><p>林平之道：“我纵然双眼从此不能见物，但父母大仇得报，一生也决不后悔。当日令狐冲传我爹爹遗言，说向阳巷老宅中祖宗的遗物，千万不可翻看，这是曾祖传下来的遗训。现下我是细看过了，虽然没遵照祖训，却报了父母之仇。若非如此，旁人都道我林家的辟邪剑法浪得虚名，福威镖局历代总镖头都是欺世盗名之徒。”<br>    岳灵珊道：“当时爹爹和你都疑心大师哥，说他取了你林家的辟邪剑谱，说他揑造公公的遗言……”林平之道：“就算是我错怪了他，却又怎地？当时连你自己也不是一样的疑心？”岳灵珊轻轻叹息一声，说道：“你和大师哥相识未久，如此疑心，也是人情之常。可是爹爹和我，却不该疑他。世上真正信得过他的，只妈妈一人。”<br>    盈盈心道：“谁说只你妈妈一人？还有我呢！” </p><p>林平之冷笑道：“你娘也真喜欢令狐冲。为了这小子，你父母不知口角了多少次。”岳灵珊讶道：“我爹爹妈妈为了大师哥口角？我爹妈是从来不口角的。”林平之冷笑道：“从来不口角？那只是装给外人看看而已。连这种事，岳不群也戴起伪君子的假面具。我亲耳听得清清楚楚，难道会假？” </p><p>只听林平之续道：“你妈说道：‘他跟魔教中人结交，自是没冤枉他。我说你冤枉他偷了平儿的辟邪剑谱。’你爹道：‘难道剑谱不是他偷的？他剑术突飞猛进，比你比我还要高明，你又不是没见过？’你妈道：‘那定是他另有际遇。我断定他决计没拿辟邪剑谱。冲儿任性胡闹，不听你我的教训，那是有的。但他自小光明磊落，决不做偷偷摸摸的事。自从珊儿跟平儿要好，将他撇下之后，他这等傲性之人，便是平儿双手将剑谱奉送给他，他也决计不收。’” </p><p>盈盈听到这里，心中说不出的欢喜，真盼立时便能搂住了岳夫人，好好感谢她一番，心想不枉你将冲郎从小抚养长大，华山全派，只有你一人，才真正明白他的为人；又想单凭她这几句话，他日若有机缘，便须好好报答她才是。 </p><p>林平之续道：“你爹哼了一声，道：‘你这么说，咱们将令狐冲这小子逐出门墙，你倒似好生后悔。’你妈道：‘他犯了门规，你执行祖训，清理门户，无人可以非议。但你说他结交左道，罪名已经够了，何必再冤枉他偷盗剑谱？其实你比我还明白得多。你明知他没拿平儿的辟邪剑谱。’你爹叫了起来：‘我怎知道？我怎知道？’” </p><p>林平之的声音也是既高且锐，仿效岳不群尖声怒叫，静夜之中，有如厉枭夜啼，盈盈不由得毛骨悚然。<br>    隔了一会，才听他续道：“你妈妈缓缓的道：‘你自然知道，只因为这部剑谱，是你取了去的。’你爹怒声吼叫：‘你……你说……是我……’但只说了几个字，突然住口。你妈声音十分平静，说道：‘那日冲儿受伤昏迷，我为他止血治伤之时，见到他身上有件袈裟，写满了字，似乎是剑法之类。第二次给他换药，那件袈裟已经不见了，其时冲儿仍昏迷未醒。这段时候之中，除了你我二人，并无别人进房。这件袈裟可不是我拿的。’” </p><p>岳灵珊哽咽道：“我爹爹……我爹爹……”林平之道：“你爹几次插口说话，但均只含糊不清的说了一两个字，便没再说下去。你妈妈语声渐转柔和，说道：‘师哥，我华山一派的剑术，自有独到的造诣，紫霞神功的气功更加不凡，以此与人争雄，自亦足以树名声于江湖，原不必再去另学别派剑术。只是近来左冷禅野心大炽，图并四派。华山一派在你手中，说什么也不能沦亡于他手中。咱们联络泰山、恒山、衡山三派，到时以四派斗他一派，我看还是占了六成赢面。就算真的不胜，大夥儿轰轰烈烈的剧斗一场，将性命送在嵩山，也就是了，到了九泉之下，也不致愧对华山派的列祖列宗。他如将咱们四派杀得乾乾净净，这样一来，五岳剑派只剩下他嵩山一派，他要并五派为一，却也并不成了。’”<br>    盈盈听到这里，心下暗赞：“岳夫人确是女中须眉，比她丈夫可有骨气得多了。” </p><p>只听岳灵珊道：“我妈这几句话，可挺有道理呀。”林平之冷笑道：“可是其时你爹爹已拿了我的剑谱，早已开始修习，那里还肯听师娘的劝？”他突然称一句“师娘”，足见在他心中，对岳夫人仍不失敬意，继续道：“你爹爹那时说道：‘你这话当真是妇人之见。逞这等匹夫之勇，徒然送了性命，华山派还是给左冷禅吞了，死了之后，未必就有脸面去见华山派列祖列宗。左冷禅杀光了咱们之后，他找些虾兵蟹将来，分在泰衡华恒四岳，虚立四派的名衔，还不容易？’你妈半晌不语，叹道：‘你苦心焦虑以求保全本派，有些事我也不能怪你。只是……只是那辟邪剑法练之有损无益，否则的话，为什么林家子孙都不学这剑法，以致给人家逼得走投无路？我劝你还是悬崖勒马，及早别学了罢？’你爹爹大声道：‘你怎知我在学辟邪剑法？你……你……在偷看我吗？’你妈道：‘我又何必偷看这才知道？’你爹大声道：‘你说，你说！’他说得声嘶力竭，话音虽响，却显得颇为气馁。” </p><p>​    “你妈道：‘你说话的声音，就已全然变了，人人都听得出来，难道你自己反而不觉得？’你爹还在强辩：‘我向来便是如此。’你妈道：‘每天早晨，你被窝里总是落下了许多胡须……’你爹尖叫一声：‘你瞧见了？’语音什是惊怖。你妈叹道：‘我早瞧见了，一直不说。你黏的假须，能瞒过旁人，却怎瞒得过和你做了几十年夫妻的枕边之人？’你爹见事已败露，无可再辩，隔了良久，问道：‘旁人还有谁知道了？’你妈道：‘没有。’你爹问：‘珊儿呢？’你妈道：‘她不会知道的。’你爹道：‘平之自然也不知了？’你妈道：‘不知。’你爹道：‘好，我听你的劝，这件袈裟，明儿咱们就设法交还给平之，再慢慢想法为令狐冲洗刷清白。这路剑法，我今后也不练了。’你妈十分欢喜，说道：‘那当真再好也没有了。不过这剑谱于人有损，岂可让平儿见到？还是毁去了的为是。’” </p><h3 id="第37章-伤逝"><a href="#第37章-伤逝" class="headerlink" title="第37章 伤逝"></a>第37章 伤逝</h3><p>劳德诺在车中曾听到他夫妻对话，知林平之所言非虚，便道：“如此什好，咱们便同回嵩山如何？”林平之道：“很好。”劳德诺道：“须当弃车乘马，改行小道，否则途中撞上了岳不群，咱们可还不是他对手。”他侧头问岳灵珊道：“小师妹，你今后帮父亲呢？还是帮丈夫？”<br>    岳灵珊收起哭声，说道：“我是两不相帮！我……我是个苦命人，明日去落发出家，爹爹也罢，丈夫也罢，从此不再见面了。” </p><pre><code class="hljs">岳灵珊道：“大师哥，你陪在我身边，那很好。平弟……平弟，他去了吗？”令狐冲咬牙切齿，哭道：“你放心，我一定杀了他给你报仇。”岳灵珊道：“不，不！他眼睛看不见，你要杀他，他不能抵挡。我……我要去妈妈那里。”令狐冲道：“好，我送你去见师娘。”盈盈听她话声越来越微，命在顷刻，不由得也流下泪来。 </code></pre><p>岳灵珊道：“大师哥，你一直待我很好，我……我对你不起。我……我就要死了。”令狐冲垂泪道：“你不会死的，咱们能想法子治好你。”岳灵珊道：“我……我这里痛……痛得很。大师哥，我求你一件事，你……千万要答允我。”令狐冲握住她左手，道：“你说，你说，我一定答允。”岳灵珊叹了口气，道：“你……你……不肯答允的……而且……也太委屈了你……”声音越来越低，呼吸也越微弱。令狐冲道：“我一定答允的，你说好了。”岳灵珊道：“你说什么？”<br>    令狐冲道：“我一定答允的，你要我办什么事，我一定给你办到。”岳灵珊道：“大师哥，我的丈夫……平弟……他……瞎了眼睛……很是可怜……你知道么？”令狐冲道：“是，我知道。”岳灵珊道：“他在这世上，孤苦伶仃，大家都欺侮……欺侮他。大师哥……我死了之后，请你尽力照顾他，别……别让人欺侮他……” </p><p>令狐冲笑了几声，心中一酸，又掉下泪来。盈盈扶着他坐起，指着山外一个新坟，低声道：“岳姑娘便葬在那里。”令狐冲含泪道：“多……多谢你了。”盈盈缓缓摇了摇头，道：“不用多谢。各人有各人的缘法，也各有各的业报。”令狐冲心下暗感歉仄，说道：“盈盈，我对小师妹始终不能忘情，盼你不要见怪。”<br>    盈盈道：“我自然不怪你。如果你真是个浮滑男子，负心薄幸，我也不会这样看重你了。”低声道：“我开始……开始对你倾心，便因在洛阳绿竹巷中，隔着竹帘，你跟我说怎样恋慕你的小师妹。岳姑娘原是个好姑娘，她……她便是跟你无缘。如果你不是从小和她一块儿长大，多半她一见到你，便会喜欢你的。” </p><p>令狐冲沉思半晌，摇了摇头，道：“不会的。小师妹崇仰我师父，她喜欢的男子要像她爹爹那样端庄严肃，沉默寡言。我只是她的游伴，她从来……从来不尊重我。”盈盈道：“或许你说得对。正好林平之就像你师父一样，一本正经，却满肚子都是机心。”令狐冲叹了口气，道：“小师妹临死之前，还不信林平之是真的要杀她，还是对他全心相爱，那……那也很好。她并不是伤心而死。我想过去看看她的坟。” </p><p>适才一切情形，岳夫人都清清楚楚的瞧在眼里，她深知令狐冲的为人，对岳灵珊自来敬爱有加，当她犹似天上神仙一般，决不敢有丝毫得罪，连一句重话也不会对她说，若说为她舍命，倒毫不希奇，至于什么逼奸不遂、将之杀害，简直荒谬绝伦。何况眼见他和盈盈如此情义深重，岂能更有异动？他出剑制住丈夫，忍手不杀，而丈夫却对他忽施毒手，如此卑鄙行径，纵是旁门左道之士亦不屑为，堂堂五岳派掌门竟出此手段，当真令人齿冷，刹那间万念俱灰，淡淡问道：“冲儿，珊儿真是给林平之害死的？” </p><p>令狐冲心中一酸，泪水滚滚而下，哽咽道：“弟子……我……我……”岳夫人道：“他不当你是弟子，我却仍当你是弟子。只要你喜欢，我仍是你师娘。”令狐冲心中感激，拜伏在地，叫道：“师娘！师娘！”岳夫人抚摸他头发，眼泪也流了下来，缓缓的道：“那么这位任大小姐所说不错，林平之也学了辟邪剑法，去投靠左冷禅，因此害死了珊儿？”令狐冲道：“正是。” </p><p>岳夫人道：“将来杀林平之为珊儿报仇，这件事，自然是你去办了。”令狐冲垂泪道：“小师妹……小师妹……临终之时，求孩儿照料林平之。孩儿不忍伤她之心，已答允了她。这件事……这件事可真为难得紧。”岳夫人长长叹了口气，道：“冤孽！冤孽！”又道：“冲儿，你以后对人，不可心地太好了！” </p><p>令狐冲道：“是！”突觉后颈中有热热的液汁流下，回过头来，只见岳夫人脸色惨白，吃了一惊，叫道：“师娘，师娘！”忙站起身来扶住岳夫人时，只见她胸前插了一柄匕首，对准心脏刺入，已然气绝毙命。令狐冲惊得呆了，张嘴大叫，却一点声音也叫不出来。 </p><p>令狐冲道：“他……他们要拿我师父怎样？”盈盈道：“你还叫他师父？”令狐冲道：“唉，叫惯了。师娘为什么要自尽？她为……为什么要自杀？”盈盈恨恨的道：“自然是为了岳不群这奸人了。嫁了这么卑鄙无耻的丈夫，若不杀他，只好自杀。咱们快杀了岳不群，给你师娘报仇。” </p><p>令狐冲踌躇道：“你说要杀了他？他终究曾经是我师父，养育过我。”盈盈道：“他虽是你师父，曾对你有养育之恩，但他数度想害你，恩仇早已一笔勾销。你师娘对你的恩义，你却未报。你师娘难道不是死在他手中的吗？”令狐冲叹了口气，凄然道：“师娘的大恩，那是终身难报的了。就算岳不群和我之间恩仇已了，我总不能杀他。” </p><p>盈盈明知令狐冲决不容自己杀他，只要令狐冲此后不再顾念旧情，对岳不群也就无所畏惧，说道：“好，今日咱们就饶他一命。鲍长老、莫长老，你们到江湖之上，将咱们如何饶了岳不群之事四处传播。又说岳不群为了练那邪恶剑法，自残肢体，不男不女，好教天下英雄众所知闻。”鲍大楚和莫长老同声答应。<br>    岳不群脸如死灰，双眼中闪动恶毒光芒，但想到终于留下了一条性命，眼神中也混和着几分喜色。 </p><p>盈盈道：“你恨我，难道我就怕了？”长剑几挥，割断了绑缚住他的绳索，走近身去，解开了他背上一处穴道，右手手掌按在他嘴上，左手在他后脑一拍。岳不群口一张，只觉嘴里已多了一枚丸药，同时觉得盈盈右手两指已揑住了自己鼻孔，登时气为之窒。<br>    盈盈为岳不群割断绑缚、解开他身上受封穴道之时，背向令狐冲，遮住了他眼光，以丸药塞入岳不群口中，令狐冲也就没瞧见，只道她看在自己份上放了师父，心下什慰。<br>    岳不群鼻孔阻塞，张嘴吸气，盈盈手上劲力一送，登时将丸药顺着气流送入他腹中。 </p><p>令狐冲吃了一惊，问道：“你给我师……给他服了三尸脑神丹？”<br>    盈盈笑道：“是他自己忙不迭的张口吞食的，多半他肚子饿得狠了，什么东西都吃。岳不群，以后你出力保护冲哥和我的性命，于你大为有益。”<br>    岳不群心下恨极，但想：“倘若这妖女遭逢意外，给人害死，我……我可就惨了。什至她性命还在，受了重伤，端午节之前不能回到黑木崖，我又到那里去找她？又或者她根本就不想给我解药……”想到这里，忍不住全身发抖，虽一身神功，竟难以镇定。 </p><p>令狐冲叹了口气，心想盈盈出身魔教，行事果然带着三分邪气，但此举实是为自己着想，可也怪不得她。 </p><p>盈盈见岳不群木然而立，说道：“岳先生，你也可以去了。尊夫人的遗体，你带去华山安葬吗？”岳不群摇了摇头，道：“相烦二位，便将她葬在小山之旁罢！”说着竟不向二人再看一眼，快步而去，顷刻间已在树丛之后隐没，身法之快，实所罕见。<br>    黄昏时分，令狐冲和盈盈将岳夫人的遗体在岳灵珊墓旁葬了，令狐冲又大哭了一场。 </p><p>​    盈盈心想：“这倒不错，换作了我，不管你待我如何，我总是全心全意的待你好。” </p><h3 id="第38章-迫娶"><a href="#第38章-迫娶" class="headerlink" title="第38章 迫娶"></a>第38章 迫娶</h3><p>令狐冲和盈盈出得山谷，行了半日，来到一处市镇，到一家面店吃面。<br>    令狐冲筷子上挑起长长几根面条，笑吟吟的道：“我跟你还没拜堂成亲……”盈盈羞得满脸通红，嗔道：“谁跟你拜堂成亲了？”令狐冲微笑道：“将来总是要成亲的。你如不愿，我捉住了你拜堂。”盈盈似笑非笑的道：“在山谷中倒是乖乖的，一出来就来说这些不正经的疯话。”令狐冲笑道：“终身大事，最正经不过。盈盈，那日在山谷之中，我忽然想起，日后和你做了夫妻，不知生几个儿子好。”盈盈站起身来，秀眉微蹙，道：“你再说这些话，我不跟你一起去恒山啦。”令狐冲笑道：“好，好，我不说，我不说。因为那山谷中有许多桃树，倒像是个桃谷，要是有六个小鬼在其间鬼混，岂不是变了小桃谷六仙？”<br>    盈盈坐了下来，问道：“那里来六个小鬼？”一语出口，便即省悟，白了令狐冲一眼，低头吃面，心中却什甜蜜。 </p><p>仪和掩上了门，和仪清二人相对摇了摇头，待听得仪琳和郑萼脚步声已远，说道：“我看仪琳师妹总静不下心来。心猿意马，那是咱们修道人的大忌，不知怎生劝劝她才好。”仪清道：“劝是很难劝的，总须自悟。”仪和道：“我知道她为什么不能心静，她心中老是想着……”仪清摇手道：“佛门清净之地，师姊别说这等话。若不是为了急于报师尊大仇，让她慢慢自悟，原亦不妨。”仪和道：“师父常说：世上万事皆须随缘，半分勉强不得；尤其收束心神，更须循序渐进，倘若着意经营，反易堕入魔障。我看仪琳师妹外和内热，乃性情中人，身入空门，于她实不相宜。” </p><p>令狐冲悄立窗外，心下疑思不解：“她们怎么说我师父害死了她们的师叔？又为什么为报师仇，为了有人接掌恒山门户，便须督促仪琳小师妹日夜勤练剑法？”凝思半晌，不明其理，慢慢走开，心想：“日后询问仪和、仪清两位师姊便是。”猛见地下自己的影子缓缓晃动，抬头望月，只见月亮斜挂树梢，心中陡然闪过一个念头，险些叫出声来，心道：“我早该想到了。为什么她们早就明白此事，我却一直没想到？” </p><p>想到此处，额头上冷汗涔涔而下，那时候能以一枚细针、正面交锋而害死恒山派两大高手，武功却又高不了定闲师太多少，一针不能立时致她死命，便只岳不群一人。又想起岳不群处心积虑，要做五岳派掌门，竟能让劳德诺在门下十馀年之久，不揭穿他底细，末了让他盗了一本假剑谱去，由此轻轻易易的刺瞎左冷禅双目。定闲、定逸两位师太极力反对五派合并，岳不群乘机下手将其除去，少了并派的一大阻力，自是在情理之中。定闲师太为什么不肯吐露害她的凶手是谁？自因岳不群是他师父之故。倘若凶手是左冷禅或东方不败，定闲师太又怎会不说？ </p><p>令狐冲又想到当时在山洞中和盈盈的对话。他在少林寺给岳不群重重踢了一脚，他并未受伤，岳不群腿骨反断，盈盈大觉奇怪。她说她父亲想了半天，也想不出其中原因，令狐冲吸了不少外人的内功，固然足以护体，但必须自加运用方能伤人，不像自身所练成的内功，不须运使，自能将对方攻来的力道反弹出去。此刻想来，岳不群自是故意做作，存心做给左冷禅看的，那条腿若非假断，便是他自己以内力震断，好让左冷禅瞧在眼里，以为他武功不过尔尔，不足为患，便可放手进行并派。左冷禅花了无数心血力气，终于令五派合并，到得头来，却是为人作嫁，给岳不群一伸手，轻轻易易的就将成果取了去。 </p><p>这些道理本来也不难明，只是他说什么也不会疑心到师父身上，或许内心深处，早已隐隐想到，但一碰到这念头的边缘，心思立即避开，既不愿去想，也不敢去想，直至此刻听到了仪和、仪清的话，这才无可规避。 </p><p>自己一生敬爱的师父，竟是这样的人物，只觉人生一切都殊无意味，一时打不起精神到恒山别院去查察，便在一处僻静的山坳里躺下睡了。 </p><p>田伯光劝道：“太师父，你也不用难过。咱们失手遭人暗算，定要找了这个人来，将他碎尸万段……”他一言未毕，不戒和尚反手一掌，将他打得直跌出丈许之外，几个踉跄，险些摔倒，半边脸颊登时高高肿起。不戒和尚骂道：“臭贼！咱们给吊在这里，当然是罪有应得，你……你……你好大的胆子，想杀死人家啊！”田伯光不明就里，听太师父如此说，擒住自己之人定是个大有来头的人物，竟连太师父也不敢得罪他半分，只得唯唯称是。 </p><p>不戒和尚呆了一呆，又捶胸哭了起来，突然间反手一掌，又向田伯光打去。田伯光身法极快，身子一侧避开，叫道：“太师父！” </p><p>“我说：‘妈妈听了那女人的话，以为你真的调戏了她。’爹爹说：‘是啊，那不是冤枉吗？可是后来我想想，那也不全是冤枉，因为当时我见到那个女人，心中便想：“这女子生得好俊。”你想，我既然娶了你妈妈做老婆，心中却赞别个女人美貌，不但心中赞，口中也赞，那不是负心薄幸、好色无厌么？’” </p><p>“爹又说：‘反正我到处找你妈不到，到阴世去跟她相会，那正洹不得。可惜我身子太重，上吊了片刻，绳子便断了，第二次再上吊，绳子又断了。我想拿刀抹脖子，那刀子明明在身边的，忽然又找不到了，真是想死也不容易。’我说：‘爹，你弄错啦，菩萨保佑，叫你不可自尽，因此绳子会断，刀子会不见。否则等我找到时，你早已死啦。’爹爹说：‘那也不错，多半菩萨罚我在世上还得多受些苦楚，不让我立时去阴世跟你妈相见。’我说：‘先前我还道是田伯光的布条跟你掉错了，因此你生这么大的气。’爹爹说：‘怎么会掉错？不可不戒以前对你无礼，岂不是“胆大妄为”？我叫他去做媒，要令狐冲这小子来娶你，他推三阻四，总是办不成，那还不是“办事不力”？这八字评语挂在他身上，真再合式也没有了。’我说：‘爹，你再叫田伯光去干这等无聊的事，我可要生气了。令狐师兄先前喜欢的是他小师妹，后来喜欢了魔教的任大小姐。他虽待我很好，但从来就没将我放在心上。’” </p><p>令狐冲听仪琳这么说，心下颇觉歉然。她对自己一片痴心，初时还不觉得，后来却渐渐明白了，但自己确然如她所说，先是喜欢岳家小师妹，后来将一腔情意转到了盈盈身上。这些时候来亡命江湖，少有想到仪琳的时刻。 </p><p>那婆婆道：“你说我办不到吗？”走出门去，只听得隔房开门之声，那婆婆重又回进房来，手中提着一个女子，手足被缚，正便是盈盈。<br>    令狐冲大吃一惊，没料到盈盈竟也已落入这婆娘的手中，见她身上并没受伤的模样，略略宽心，叫道：“盈盈，你也来了。”盈盈微微一笑，说道：“你们的说话，我都听见啦。你说决不对我负心薄幸，我听着很欢喜。”那婆婆喝道：“在我面前，不许说这等不要脸的话。小姑娘，你要和尚呢，还是要太监？”盈盈脸上一红，道：“你的话才真难听。” </p><p>那婆婆道：“我仔细想想，要令狐冲这小子抛弃了你，另娶仪琳，他是决计不肯的。”令狐冲大声喝采：“你开口说话以来，这句话最有道理。”那婆婆道：“那我老人家做做好事，就让一步，便宜了令狐冲这小子，让他娶了你们两个。他做和尚，两个都娶；做太监，一个也娶不成。只不过成亲之后，你可不许欺侮我的乖女儿，你们两头大，不分大小。你年纪大着几岁，就让仪琳叫你姊姊好了。”<br>    令狐冲道：“我……”他只说了个“我”字，哑穴上一麻，已给她点得说不出话来。那婆婆跟着又点了盈盈的哑穴，说道：“我老人家决定了的事，不许你们罗里罗唆打岔。让你这小和尚娶两个如花如玉的老婆，还有什么话好说？哼，不戒这老贼秃，有什么用？见到女儿害相思病，空自乾着急，我老人家一出手就马到成功。”说着飘身出房。 </p><p>令狐冲哈哈大笑，可是没能笑出声来，但见盈盈笑得更加欢喜了，忽见她眼珠转了几转，露出狡狯的神色，左眼眨了一下，又眨一下。令狐冲未明她的用意，只见她左眼又眨了两下，心想：“连眨两下，那是什么意思？啊，是了，她在笑我要娶两个老婆。”当即左眼眨了一下，收起笑容，脸上神色什是严肃，意思说：“只娶你一个，决无二心。”盈盈微微摇头，左眼又眨了两下，意思似是说：“娶两个就两个好了！”<br>    令狐冲又摇了摇头，左眼眨了一眨。他想将头摇得大力些，以示坚决，只是周身穴道给点得太多，难以出力，脸上神气却诚挚之极。盈盈微微点头，眼光又转到剃刀上去，再缓缓摇了摇头。令狐冲双目凝视着她。盈盈的眼光慢慢移动，和他相对。 </p><p>两人相隔丈许，四目交视，忽然间心意相通，实已不必再说一句话，反正于对方的情意全然明白。娶不娶仪琳无关紧要，是和尚是太监无关紧要。两人死也好，活也好，既已有了两心如一的此刻，便已心满意足，眼前这一刻便是天长地久，纵然天崩地裂，这一刻也已拿不去、销不掉了。 </p><p>仪琳叹了口气，轻声道：“你不用哄我。我初识得他时，令狐师兄只爱他小师妹一人，爱得要命，心里便只一个小师妹。后来他小师妹对他不起，嫁了别人，他就只爱任大小姐一人，也是爱得要命，心里便只一个任大小姐。” </p><p>令狐冲和盈盈目光相接，心头均感甜蜜无限。 </p><p>仪琳道：“我要去啦。婆婆，你要是向旁人提到令狐师兄他……他要娶我什么的，我可不能活了。”那婆婆道：“那又为什么？他说非娶你不可，你难道不喜欢么？”仪琳道：“不，不！我时时想着他，时时向菩萨求告，要菩萨保佑他逍遥快活，只盼他无灾无难，得如心中所愿，和任大小姐成亲。婆婆，我只是盼他心中欢喜。我从来没盼望他来娶我。”那婆婆道：“他倘若娶不成你，他就决不会快活，连做人也没味道了。”仪琳道：“都是我不好，只道你听不见，向你说了这许多令狐师兄的话。他是当世的大英雄、大豪杰，我只是个什么也不懂，什么也不会的小尼姑。他说过的，‘一见尼姑，逢赌必输’，见了我都会倒霉，怎会娶我？我皈依佛门，该当心如止水，再也不能想这种事。婆婆，你以后提也别提，我……我以后也决不见你了。” </p><h3 id="第39章-聚歼"><a href="#第39章-聚歼" class="headerlink" title="第39章 聚歼"></a>第39章 聚歼</h3><p>盈盈向令狐冲瞧了一眼，不禁噗哧一声，笑了出来。令狐冲叹道：“令狐冲削发为僧，从此身入空门。女施主，咱们就此别过。”盈盈明知他是说笑，但情之所锺，关心过切，不由得身子一颤，抓住他手臂，道：“冲哥，你别……别跟我说这等笑话，我……我……”适才她飞剑杀游迅，眼睛也不眨一下，这时语声中却大现惧意。令狐冲心下感动，左手在自己光头上打了个爆栗，叹道：“但世上既有这样一位如花似玉的娘子，大和尚只好还俗。” </p><p>令狐冲明白她心事，这等大事要瞒过任我行的耳目，那是谈何容易，但自己既是恒山派掌门，恒山门人被俘，如何不救？她是打定主意向着自己，纵违父命，也在所不惜了。他想事已至此，须当有个了断，伸出左手去抓住了她右手。盈盈微微一挣，但见四下里无一人，便让他握住了手。令狐冲道：“盈盈，你的心事，我很明白。此事势将累你父女失和，我很过意不去。”盈盈微微摇头，说道：“爹爹若顾念着我，便不该对恒山派下手。不过，我猜想他对你倒也不是心存恶意。”<br>    令狐冲登时省悟，说道：“是了，你爹爹擒拿恒山弟子，用意在胁迫我加盟日月神教。”盈盈道：“正是。爹爹心中其实很喜欢你，何况你又是他神功大法的唯一传人。”令狐冲道：“其实我对你爹爹也是既尊敬又投机，何况他又是我婆婆的爹爹，长了三辈。可是我决不愿加盟神教，什么‘千秋万载，一统江湖’，什么‘文成武德，泽被苍生’这些肉麻话，我听了就要作呕。”盈盈道：“我知道，因此从来没劝过你一句。倘若你入了神教，将来做了教主，一天到晚听这种恭维肉麻话，那就……那就不会是现在这样子了。唉，爹爹重上黑木崖，他整个性子很快就变了。” </p><p>令狐冲道：“可是咱们也不能得罪了你爹爹。”伸出右手，将她左手也握住了，说道：“盈盈，救出恒山门人之后，我和你立即拜堂成亲，也不必理会什么父母之命，媒妁之言。我和你退出武林，封剑隐居，从此不问外事，专生儿子。” </p><p>令狐冲心想，原来他们尚不知恒山派弟子被掳之事，向不戒和尚道：“大师，我拜托你办一件事，行不行？”不戒道：“行啊，有什么不行？”令狐冲道：“不过此事十分机密，你这位徒孙可不能参与其事。”不戒道：“那还不容易？我叫他走得远远地，别来碍老子的事就是了。”<br>    令狐冲道：“此去向东南十馀里处，一株高树之上，有人给绑了起来，高高吊起……”不戒“啊”的一声，神色古怪，身子微微发抖。令狐冲道：“那人是我朋友，请你劳驾去救他一救。”不戒道：“那还不容易？你自己却怎地不救？”令狐冲道：“不瞒你说，这是个女子。”他向盈盈努努嘴，道：“我和任大小姐在一起，多有不便。”不戒哈哈大笑，道：“我明白了，你是怕任大小姐喝醋。”盈盈向他二人瞪了一眼。 </p><p>令狐冲一笑，说道：“那女人的醋劲儿才大着呢，当年她丈夫向一位夫人瞧了一眼，赞了一句，说那夫人美貌，那女人就此不告而别，累得她丈夫天涯海角，找了她十几年。”不戒越听眼睛睁得越大，连声道：“这……这……这……”喘息声越来越响。令狐冲道：“听说她丈夫找到这时候，还是没找到。” </p><p>正说到这里，桃谷六仙嘻嘻哈哈的走上楼来。不戒恍若不见，双手紧紧抓住令狐冲的手臂，道：“当……当真？”令狐冲道：“她跟我说，她丈夫倘若找到了她，便跪在面前，她也不肯回心转意。因此你一放下她，她立刻就跑。这女子身法快极，你一眨眼，她就溜得不见了。”不戒道：“我决不眨眼，决不眨眼。”令狐冲道：“我又问她，为什么不肯跟丈夫相会。她说她丈夫是天下第一负心薄幸、好色无厌之徒，就再相见，也是枉然。” </p><p>不戒大叫一声，转身欲奔，令狐冲一把拉住，在他耳边低声道：“我教你个秘诀，她就逃不了啦。”不戒又惊又喜，呆了一呆，突然双膝跪地，咚咚咚磕了三个响头，大声道：“令狐兄弟，不，令狐掌门，令狐爷爷，令狐祖宗，令狐师父，你快教我这秘诀，我拜你为师。” </p><p>两人步出镇外，走了一段路，令狐冲只是微笑，不住瞧她。盈盈嗔道：“瞧什么？没见过么？”令狐冲笑道：“我是在想，那恶婆娘将我吊在梁上，咱们一报还一报，将她吊在树上。她剃光我头发，我叫她丈夫剥光她衣衫，那也是一报还一报。”盈盈嗤的一笑，道：“你小心着，下次再给那恶婆娘见到，你可有得苦头吃了。”令狐冲笑道：“我助她夫妻团圆，她多谢我还来不及呢。”说着又向盈盈瞧了几眼，笑了一笑，神色古怪。盈盈道：“又笑什么了？”令狐冲道：“我在想不戒大师夫妻重逢，不知说什么话。”盈盈道：“那你怎地老是瞧着我？”忽然之间，明白了令狐冲的用意，这浪子在想不戒大师在客店之中，脱光了他妻子衣衫，他心中想的是此事，却眼睁睁的瞧着自己，用心之不堪，可想而知，霎时间红晕满颊，挥手便打。 </p><p>​    三人凝神倾听，唯闻松涛之声，满山静得出奇。蓝凤凰道：“咱们分头找找，一个时辰之后，再在这里相会。”令狐冲道：“好！”他想蓝凤凰使毒本事高明之极，没人能伤害得了她，但还是叮嘱一句：“旁人你也不怕，但若遇到我师父，他出剑奇快，须得小心！”蓝凤凰见他说得恳切，昏黄灯火之下，情致殷殷，关心之意见于颜色，不由得心中感动，道：“大哥，我理会得。”推门而出。 </p><p>令狐冲不见盈盈，心下惶急，又想：“魔教十长老个个武功奇高，却中了暗算，葬身于此。我和盈盈今日不知能否得脱此难？这件事倘若真是我师父安排的，他才智过人，那可凶险得紧。”<br>    眼见众人在地道口推拥撕打，惊怖焦躁之下，忽动杀机：“这些家伙碍手碍脚，须得将他们一个个都杀了，我和盈盈方得从容脱身。”挺起长剑，便欲挥剑杀人，只见一个少年蹲在地下，双手乱抓头发，全身发抖，脸如土色，显是害怕之极，令狐冲顿生怜悯，寻思：“我和他是同遭暗算的难友，该当同舟共济才是，怎可杀他泄愤？”长剑本已提起，当下又斜斜的横在胸前。 </p><p>众瞎子答应了，但听得剑声呼呼，此来彼往。有两柄剑砍到令狐冲身前，令狐冲举剑架开，沙哑着嗓子骂了两声“滚你奶奶的”，居然没人察觉。约莫过了一盏茶时分，除了众瞎子的叫骂声与金刃劈空声外，更没别的声息。令狐冲却急得几乎哭了出来，只想大叫：“盈盈，盈盈，你在那里？” </p><p>盈盈纵身跃下，令狐冲抢将上去，掷下长剑，将她搂在怀里。两人都喜极而泣。令狐冲轻吻她嘴唇，低声道：“刚才可真吓死我了。”盈盈在黑暗中亦不闪避，轻轻的道：“你骂人‘滚你奶奶的’，我却听得出是你声音。”令狐冲忍不住笑了出来，问道：“你真一点也没受伤吗？”盈盈道：“没有。”令狐冲道：“先前我听着琴声，倒不怎么担心。但后来想到我曾刺中了一个女子，而琴声又断断续续，不成腔调，似乎你受了重伤，到后来更一点声息也没有了，那可真不知如何是好。” </p><p>盈盈微笑道：“我早跃到了上面，生怕给人察觉，又不能出声招呼你，只好投掷一枚枚铜钱，击打那留在地下的瑶琴，盼你省悟。”令狐冲吁了口气，说道：“原来如此。我竟始终想不到，该打，该打！”拿起她的手来，轻击自己面颊，笑道：“你嫁了这样一个蠢材，也算是任大小姐倒足了大霉。我一直奇怪，倘若是你拨弄瑶琴，怎么会不弹一句《清心普善咒》，又或是《笑傲江湖之曲》？” </p><p>盈盈让他搂抱着，说道：“我若能在黑暗中用铜钱击打瑶琴，弹出曲调，那变成仙人了。”令狐冲笑道：“你本来就是仙人。”盈盈听他语含调笑，身子一挣，便欲脱开他怀抱，令狐冲紧紧抱住了她不放，问道：“后来怎地不发钱镖弹琴了？”盈盈笑道：“我穷得要命，身边没多少钱，投得几次，就没钱了。”令狐冲叹道：“可惜这山洞中既没钱庄，又没当铺，任大小姐没钱使，竟无处挪借。”盈盈又是一笑，道：“后来我连头上金钗、耳上珠环都发出了。待得那些瞎子动手杀人，他们耳音极灵，我就不敢再投掷什么了。” </p><p>只见盈盈手中握着的竟是一根白骨，一头已给削尖！<br>    盈盈一呆之下，将白骨摔在地下，笑骂：“滚你……”只骂了两个字，觉得出口不雅，抿嘴住口。<br>    令狐冲恍然大悟，说道：“盈盈，咱们两条性命，是神教这位前辈搭救的。” </p><h3 id="第40章-拒盟"><a href="#第40章-拒盟" class="headerlink" title="第40章 拒盟"></a>第40章 拒盟</h3><p>令狐冲道：“这个自然。我是你的心肝宝贝，也只有用我，才能向你换到解药。”盈盈啐了一口，道：“他用你来向我换药，我才不换呢。解药药材采集极难，制炼更加不易，那是无价之宝，岂能轻易给他。”令狐冲道：“古诗有云：易求无价宝，难得有情郎。”盈盈红晕满颊，低声道：“老鼠上天平，自称自赞，也不害羞。”说话之间，两人已走上一条极窄的山道。 </p><p>这山道笔直向上，什是陡峭，两人已不能并肩而行。盈盈道：“你先走。”令狐冲道：“还是你先走，倘若摔下来，我便抱住你。”盈盈道：“不，你先走，还不许你回头瞧我一眼，婆婆说过的话，你非听不可。”说着笑了起来。令狐冲道：“好，我就先走。要是我摔下来，你可得抱住我。”盈盈忙道：“不行，不行！”生怕他假装失足，跟自己闹着玩，当下先上了山道。盈盈见他虽然说笑，却神情郁郁，一笑之后，又现凄然之色，知他对岳不群之死什难释然，一路上顺着他说些笑话，以解愁闷。 </p><p>令狐冲心想：“当时我初上黑木崖，见到教众奉承东方不败那般无耻情状，忍不住肉麻作呕。不料任教主当了教主，竟然变本加厉，教主之上，还要加上一个‘圣’字，变成了圣教主。只怕文武百官见了当今皇上，高呼‘我皇万岁万万岁’，也不会如此卑躬屈膝。我辈学武之人，向以英雄豪杰自居，如此见辱于人，还算是什么顶天立地的好男儿、大丈夫？”<br>    想到此处，不由得气往上冲，突然之间，丹田中一阵剧痛，眼前发黑，几乎晕去。他双手抓住椅柄，咬得下唇出血，知道自从学了“吸星大法”后，虽立誓不用，但刚才在山洞口给岳不群以渔网罩住，生死系于一线，只好将这法门使了出来，吸了岳不群的内力，自己却已大受其害，这时强行克制，才使得口中不发出呻吟之声。<br>    但他满头大汗，全身发颤，脸上肌肉扭曲、痛苦之极的神情，却谁都看得出来。祖千秋等都目不转睛的瞧着他，什是关怀。盈盈走到他身后，低声道：“冲哥，我在这里。”在群豪数千对眼睛注视之下，她只能说这么一声，却也已羞得满脸通红。令狐冲回过头来，向她瞧了一眼，心下稍觉好过了些。 </p><p>其时令狐冲坚不肯允，乃自幼受师门教诲，深信正邪不两立，决计不肯与魔教同流合污。后来见到左冷禅等正教大宗师的所作所为，其奸诈凶险处，比之魔教不遑多让，这正邪之分便看得淡了。有时心想，倘若任教主定要我入教，才肯将盈盈许配于我，那么马马虎虎入教，也就是了。他本性便随遇而安，什么事都不认真，入教也罢，不入教也罢，原也算不上什么大事。 </p><p>任我行沉吟道：“岳不群是给泰山派杀死的？泰山派中那有如此好手？”<br>    恒山派中仪清朗声道：“不！岳不群是我恒山派中一位师妹杀死的。”任我行道：“是谁？”仪清道：“便是刚才下峰去的仪琳师妹。岳不群害死我派掌门师叔和定逸师叔，本派上下无不恨之切骨。今日菩萨保佑，掌门师叔和定逸师叔有灵，借着本派一个武功低微的小师妹之手，诛此元凶巨恶。”<br>    任我行道：“嗯，原来如此！那也算得天惘恢恢，疏而不漏了。”语气之中，显得十分意兴萧索。 </p><p>令狐冲向盈盈道：“盈盈，你是不能随我去的了？”盈盈早已珠泪盈眶，这时再也不能忍耐，泪水从面颊上直流下来，说道：“我若随你而去恒山，乃是不孝；倘若负你，又是不义。孝义难以两全，冲哥，冲哥，自今而后，勿再以我为念。反正你……”令狐冲道：“怎样？”盈盈道：“反正你已命不久长，我也决不会比你多活一天。” </p><p>令狐冲笑道：“你爹爹已亲口将你许配于我。他是千秋万载、一统江湖的圣教主，岂能言而无信？我就和你在此拜堂成亲，结为夫妇如何？” </p><p>盈盈一怔，她虽早知令狐冲是个胆大妄为、落拓不羁之徒，却也料不到他竟会说出这番话来，不由得满脸通红，说道：“这……这如何可以？” </p><p>令狐冲哈哈大笑，说道：“那么咱们就此别过。”<br>    他深知盈盈的心意，待任我行率众攻打恒山，将自己杀死之后，她必自杀殉情，此事势所必然，无法劝阻。倘若此刻她能破除世俗之见，肯与自己在这朝阳峰上结成夫妻，同归恒山，得享数日燕尔新婚之乐，然后携手同死，更无馀恨。但此举太过惊世骇俗，我浪子令狐冲固可行之不疑，却决非这位拘谨腼腆的任大小姐所肯为，何况这么一来，更令她负了不孝之名。当下哈哈一笑，向任我行躬身行礼，说道：“岳父大人，小婿今日对不住了！”又向向问天及诸长老作个四方揖，说道：“令狐冲在见性峰上，恭侯诸位大驾！”说着转身便走。 </p><p>向问天道：“且慢！取酒来！令狐兄弟，今日不大醉一场，更无后期。”令狐冲笑道：“妙极，妙极！向大哥确是我知己。”日月教此番来到华山，事先详加筹划，百物具备，向问天一声“酒来”，便有属下教众捧过几坛酒来，打开坛盖，斟在碗中。向问天和令狐冲各乾一碗。 </p><p>人丛中走出一个矮胖子来，却是老头子，说道：“令狐公子，你大恩大德，小老儿永远不忘，今日来敬你一碗。”说着举起碗喝乾。他只是日月教管辖的一名江湖散人，和向问天的地位不可同日而语。令狐冲今日不肯入教，公然得罪任我行，老头子这样一个小脚色居然敢来向他敬酒，只怕转眼间便有杀身之祸。他重义轻生，自已将生死置之度外。群豪见他如此大胆，无不暗暗佩服。 </p><p>跟着祖千秋、计无施、蓝凤凰、黄伯流等人一个个过来敬酒。令狐冲酒到碗乾，眼见来敬酒的好汉仍络绎不绝，心想：“这许多朋友如此瞧得起我，令狐冲这一生也不枉了，却又何必害了他们的性命？”举起大碗，说道：“众位朋友，令狐冲已不胜酒力，今日不能再喝了。众位前来攻打恒山之时，我在恒山脚下斟满美酒，大家喝醉了再打！”说着将手中一碗酒乾了。群豪齐叫：“令狐掌门，快人快语！”有人叫道：“喝醉了酒，胡里胡涂乱打一场，倒也有趣。” </p><p>​    任我行听着属下教众谀词如潮，虽然有些言语未免荒诞不经，但听在耳中，着实受用，心想：“这些话其实也没错。诸葛亮武功固然非我敌手，他六出祁山，未建尺寸之功，说到智谋，难道又及得上我了？关云长过五关、斩六将，固是神勇，可是若和我单打独斗，又怎能胜得我的‘吸星大法’？孔夫子弟子不过三千，我属下教众何止三万？他率领三千弟子，栖栖遑遑的东奔西走，绝粮在陈，束手无策。我率数万之众，横行天下，从心所欲，一无阻难。孔夫子的才智和我任我行相比，却又差得远了。” </p><p>但听得“千秋万载，一统江湖！千秋万载，一统江湖！”之声震动天地，站在峰腰的江湖豪士跟着齐声呐喊，四周群山均有回声。任我行蹲踌满志，站起身来。<br>    教众见他站起，一齐拜伏在地。霎时之间，朝阳峰上一片寂静，更无半点声息。<br>    阳光照射在任我行脸上、身上，这日月神教教主威风凛凛，宛若天神。<br>    任我行哈哈大笑，说道：“但愿千秋万载，永如今……”说到那“今”字，突然声音哑了。他一运气，要将下面那个“日”字说了出来，只觉胸口抽搐，那“日”字无论如何说不出口。他右手按胸，要将一股涌上喉头的热血压将下去，只觉头脑晕眩，阳光耀眼。</p><h3 id="第41章-曲谐"><a href="#第41章-曲谐" class="headerlink" title="第41章 曲谐"></a>第41章 曲谐</h3><p>令狐冲大醉下峰，直至午夜方醒。酒醒后始知身在旷野之中，恒山群弟子远远坐着守卫。令狐冲头痛欲裂，想起自今而后，只怕和盈盈再无相见之期，不由得心下大痛。 </p><p>方证微笑道：“老僧今日拜山，乃为商量要事而来，令狐掌门不必客气。”顿了一顿，说道：“听说令狐掌门为了维护恒山一派，不受日月教副教主之位，固将性命置之度外，更甘愿割舍任大小姐这等生死同心的爱侣，武林同道，无不钦仰。” </p><p>令狐冲一怔，心想：“我不愿为了恒山一派而牵累武林同道，不许本派弟子泄漏此事，以免少林、武当诸派来援，大动干戈，多所杀伤。不料方证大师还是得到了讯息。”说道：“大师谬赞，令人好生惭愧。晚辈和日月教任教主之间，恩怨纠葛什多，说之不尽。有负任大小姐恩义，事出无奈，大师不加责备，反加奖勉，晚辈万万不敢当了。” </p><p>令狐冲点头道：“先师昔日常加教诲，自来正邪不两立，魔教和我正教各派连年相斗，仇怨极重。晚辈识浅，只道双方各让一步，便可化解，殊不知任教主与晚辈渊源虽深，到头来终于仍须兵戎相见。”<br>    方证道：“你说双方各让一步，便可化解，这句话本来不错。日月教和我正教各派连年相斗，其实也不是有什么非拚个你死我活的原由，只是双方首领都想独霸武林，意欲诛灭对方。那日老衲与冲虚道长、令狐掌门三人在悬空寺中晤谈，深以嵩山左掌门混一五岳剑派为忧，便是怕他这独霸武林的野心。”说着叹了口长气，缓缓的道：“听说日月教中有句话，说道是‘千秋万载，一统江湖’，既存此心，武林中如何更有宁日？江湖上各帮各派宗旨行事，大相径庭。一统江湖，既无可能，亦非众人之福。” </p><p>令狐冲大喜，叫道：“风太师叔！”方证道：“正是风前辈。这位风前辈派了六位朋友到少林寺来，示知令狐掌门当日在朝阳峰上的言行。这六位朋友说话有点缠夹不清，不免有些罗唆，又喜互相争辩，但说了几个时辰，老衲耐心听着，到后来终于也明白了。”说到这里，忍不住微笑。令狐冲笑道：“是桃谷六仙？”方证笑道：“正是桃谷六仙。” </p><p>令狐冲那日自华山朝阳峰下来，便已心灰意懒，眼见日月教这等声势，恒山派决非其敌，只等任我行那一日率众来攻，恒山派上下奋力抵抗，一齐战死便是。虽然也有人献议向少林、武当诸派求救，但令狐冲只问得一句：“就算少林、武当两派一齐来救，能挡得住魔教吗？”献议之人便即哑口无言。令狐冲又道：“既没法救得恒山，又何必累得少林、武当徒然损折不少高手？”在他内心，实不愿和任我行、向问天等人相斗，和盈盈共结连理之望既绝，不知不觉间便生自暴自弃之念，只觉活在世上索然无味，还不如早早死了的乾净。此刻见方证等受了风清扬之托，大举来援，精神为之一振，但真要和日月教中这些人拚死相斗，却还是提不起兴致。 </p><p>他在“圣教主千秋万载，一统江湖”的十一字之下，加上一句“阿弥陀佛”，听来十分滑稽，令狐冲不禁笑了出来，说道：“正是。晚辈只要一听到什么‘圣教主’，什么‘千秋万载，一统江湖’，全身便起鸡皮疙瘩。晚辈喝酒三十碗不醉，多听得几句‘千秋万载，一统江湖’，忍不住头晕眼花，当场便会醉倒。”<br>    方证微微一笑，道：“他们日月教这种咒语，当真厉害得紧。”顿了一顿，又道：“风前辈在朝阳峰上，见到令狐掌门头晕眼花的情景，特命桃谷六仙带来一篇内功口诀，要老衲代传令狐掌门。桃谷六仙说话缠夹不清，口授内功秘诀倒是条理分明，十分难得，想必是风前辈硬逼他们六兄弟背熟了的。便请令狐掌门带路，赴内堂传授口诀。” </p><p>令狐冲恭恭敬敬的领着方证大师来到一间静室之中。这是风清扬命方证代传口诀，犹如太师叔本人亲临一般，当即向方证跪了下去，说道：“风太师叔待弟子恩德如山。” </p><p>方证也不谦让，受了他跪拜，说道：“风前辈对令狐掌门期望极厚，盼你依照口诀，勤加修习。”令狐冲道：“是，弟子遵命。” </p><p>令狐冲也知方证所言什合正理，日月教要将恒山派杀得鸡犬不留，正教各派设计将任我行炸死，那是天经地义之事，无人能说一句不是。但要杀死任我行，他心中已颇为不愿，要杀向问天，更是宁可自己先死；至于盈盈的生死，反而不在顾虑之中，总之两人生死与共，倒不必多所操心。眼见众人的目光都射向自己，微一沉吟，说道：“事已至此，日月教逼得咱们无路可走，冲虚道长这条计策，恐怕是伤人最少的了。”<br>    冲虚道：“令狐兄弟说得不错。‘伤人最少’四字，正是我辈所求。” </p><p>​    他本来计算周详，日月教一攻上峰来，便如何接战，如何退避，预计任我行坐上九龙椅之时，少林、武当、恒山三派人众均已退入了深谷。不料日月教一上来竟不动手，来个什么先礼后兵，任我行更要和令狐冲单独在庵中相会，全是事先算不到的变局。他虽饶有智计，一时却浑没了主意。<br>​    方证大师也知局面紧急，亦什挂念令狐冲的安危，但他修为既深，胸怀亦极通达，只觉生死荣辱，祸福成败，其实并非什么了不起的大事，谋事在人，成事在天，到头来结局如何，皆是各人善业、恶业所造，非能强求。因此他内心虽隐隐觉得不安，却淡然置之，当真炸药炸了起来，尸骨为灰，那也是舍却这皮囊之一法，又何惧之有？ </p><p>​    却听得桃干仙幽幽叹了口气，学着盈盈的语气说道：“我却担心你的身子。爹爹没传你化解异种真气的法门，其实就是传了，也不管用。爹爹他自己，唉！”桃干仙逼紧着嗓子，说得极尽哀伤。<br>​    方证、冲虚、令狐冲三人听着，亦不禁都有凄恻之意。任我行一代怪杰，虽生平恶行不少，但如此下场，亦令人为之叹息。令狐冲对任我行的心情更为奇特，虽憎他威福自用，横行霸道，却也不禁佩服他的文武才略，尤其他肆无忌惮、独行其是的性格，倒和自己颇为相投，只不过自己绝无“一统江湖”的野心而已。<br>​    一时三人心中，同时涌起了一个念头：“自古帝皇将相，圣贤豪杰，奸雄大盗，元凶巨恶，莫不有死！” </p><p>三年后某日，杭州西湖孤山梅庄挂灯结彩，陈设得花团锦簇，这天正是令狐冲和盈盈成亲的好日子。 </p><p>​    一曲既毕，群豪纷纷喝采，道喜声中退出新房。喜娘请了安，反手掩上房门。<br>​    突然之间，墙外响起了悠悠的几下胡琴之声。令狐冲喜道：“莫大师伯……”盈盈低声道：“别作声。”<br>​    只听胡琴声缠绵宛转，却是一曲《凤求凰》，但凄清苍凉之意终究不改。这三年来，令狐冲一直挂念莫大先生，但派人前往衡山打听，始终不得确讯。衡山派也已推举了新掌门人，三年来倒也安然无事。此时令狐冲听到琴声，心下喜悦无限：“莫大师伯果然没死，他今日来奏此曲，是贺我和盈盈的新婚。”琴声渐渐远去，到后来曲未终而琴声已不可闻。 </p><p>令狐冲转过身来，轻轻揭开罩在盈盈脸上的霞帔。盈盈嫣然一笑，红烛照映之下，当真是人美如玉，突然间喝道：“出来！”令狐冲一怔，心想：“什么出来？”<br>    盈盈笑喝：“再不出来，我用滚水淋了！”<br>    床底下钻出六个人来，正是桃谷六仙。六人躲在床底，只盼听到新郎、新娘的说话，好到大厅上去向群豪夸口。令狐冲心神俱醉之际，没再留神。盈盈心细，却听到了他六人压得极细的呼吸之声。令狐冲哈哈大笑，说道：“六位桃兄，险些儿又上了你们的当！”<br>    桃谷六仙走出新房，张开喉咙，齐声大叫：“千秋万载，永为夫妇！千秋万载，永为夫妇！” </p><p>冲虚正在花厅上和方证谈心，听得桃谷六仙的叫声，不禁莞尔一笑，三年来压在心中的哑谜，此时方始揭开：原来那日令狐冲和盈盈在观音堂中山盟海誓，桃谷六仙却道是改了日月教的八字经。 </p><p>令狐冲怏怏不乐。盈盈道：“太师叔是世外高人，当真是神龙见首不见尾，不知到那里云游去了。”令狐冲叹道：“太师叔固然剑术通神，他老人家的内功修为也算得当世无双。这三年半来，我修习他老人家所传的内功，几乎已将体内的异种真气化除净尽。”盈盈道：“那可得多谢少林寺的方证大师了。咱们既见不到风太师叔，明日就动身去少林寺，向方证大师叩头道谢。”令狐冲道：“方证大师代传神功，多所解说引导，便好比是半个师父，原该去谢的。”盈盈抿嘴笑道：“冲哥，你到今日还是不明白，你所学的，便是少林派的《易筋经》内功。” </p><p>令狐冲“啊”的一声，跳起身来，说道：“这……这便是《易筋经》？你怎知道？” </p><p>盈盈笑道：“当日听你说，这内功是风太师叔叫桃谷六仙带口讯，告知方证大师的。我心下生疑，寻思这内功精微奥妙，修习时若有厘毫之差，轻则走火入魔，重则送了性命，如何能叫桃谷六仙代带口讯？桃谷六仙缠夹不清，又怎说得明白？方证大师虽说，多半是风太师叔逼他们背熟了，但终究太过凶险。后来我去问这六位仁兄，他们一口咬定确有其事。但要他们背诵几句，一个说早已忘得乾乾净净，一个说只能告知方证老和尚，不能说给别人听。六个人再说得几句，更加前言不对后语，破绽百出。后来露出口风，抵赖不得，才说是方证大师为了救你性命，郄不愿让你得知，才假托风太师叔传功，你若问起，叫他们代为隐瞒。” </p><p>令狐冲张大了口，半晌做声不得。盈盈又道：“但风太师叔叫他们传讯，却是有的，只是叫他们告知方证大师，说日月教要攻打恒山，请少林、武当两派援手。” </p><p>令狐冲道：“你也坏得够了，早知此事，却直到今日才说出来。”盈盈笑道：“那日在少林寺中，你脾气倔强得很。方证大师要你拜师，改投少林，便传你《易筋经》神功，但你说什么也不肯，一拂袖子便出了山门。方证大师倘若再提传授《易筋经》之事，生怕你老脾气发作，宁可性命不要，也不肯学，那岂不糟了？因此他只好假托风太师叔之名，让你以为这是华山派本门内功，自是学之无碍。” </p><p>令狐冲道：“啊，是了，你一直不跟我说，也怕我牛脾气发作，突然不练了？现下得知我异种真气化解殆尽，这才吐露真相。” </p><p>盈盈又抿嘴笑了笑，道：“你这倔脾气，大家知道是惹不得的。” </p><p>令狐冲叹了口气，拉住她手，说道：“盈盈，当年你将性命舍在少林寺，为的是要方证大师传我《易筋经》，虽然你并没死，方证大师却认定是答允了你的事没有办到。他是武林前辈，最重然诺，终于还是将这门神功传了给我。这是你用性命换来的功夫，就算我不顾死活，难道……难道一点也不顾到你，竟会恃强不练吗？”<br>盈盈低声道：“我原也想到的，只是心中害怕。” </p><p>令狐冲道：“咱们明天便下山去少林寺，我既学了《易筋经》，也只好到少林寺出家做和尚去了。”盈盈知他说笑，说道：“你这野和尚大庙不收，小庙不要，少林寺的清规戒律严谨得很，没半天便将你这酒肉和尚乱棒打将出来。” </p><p>盈盈道：“那日我爹爹来到朝阳峰上，这厮便来奉承献媚，说道得了‘辟邪剑法’的剑谱，前来献给爹爹。爹爹问他有何用意，他说想当日月教的一名长老。爹爹没空跟他多说，叫人将他看管起来。后来爹爹逝世，大夥儿忙成一团，谁也没去理他，将他带到了黑木崖。过了十几天，我才想起这件事来，叫他来一加盘问，却原来他自练‘辟邪剑法’不得其法，竟自己将一身武功尽数废了。这人是害你六师弟的凶手，而你六师弟生平爱猴，因此我叫人觅了两只大马猴来，跟他锁在一起，放在华山之上。”说着伸手过去，扣住令狐冲的手腕，叹道：“想不到我任盈盈，竟也终身和一只大马猴锁在一起，再也不分开了。”说着嫣然一笑，娇柔无限。 </p><p>令狐冲一生但求逍遥自在，笑傲江湖，自与盈盈结褵，虽偿了平生之愿，喜乐无已，但不免受到娇妻温柔的管束，真要逍遥自在，无所拘束，却做不到了。突然之间，心中响起了《笑傲江湖之曲》的曲调，忽想：“我奏这曲子，要高便高，要低便低，只有自己一个人奏琴，才可自由自在，然如和盈盈合奏，便须依照谱子奏曲，不能任意放纵，她高我也高，她低我也低，这才说得上和谐合拍。佛家讲求湼盘，首先得做到无欲无求，这才能无拘无束。但人生在世，要吃饭，要穿衣，要顾到别人，岂能当真无欲无求？湼盘是‘无为境界’，我们做人是‘有为境界’。在有为境界中，只要没有不当的欲求，就不会受不当的束缚，那便是逍遥自在了。” </p><h3 id="第42章-后记"><a href="#第42章-后记" class="headerlink" title="第42章 后记"></a>第42章 后记</h3><p>令狐冲是天生的“隐士”，对权力没有兴趣。盈盈也是“隐士”，她对江湖豪士有生杀大权，却宁可在洛阳隐居陋巷，琴箫自娱。她生命中只重视个人的自由，个性的舒展。惟一重要的只是爱情。这个姑娘非常怕羞腼腆，但在爱情中，她是主动者。令狐冲当情意紧缠在岳灵珊身上之时，是不得自由的。只有到了青纱帐外的大路上，他和盈盈同处大车之中，对岳灵珊的痴情终于消失了，他才得到心灵上的解脱。本书结束时，盈盈伸手扣住令狐冲的手腕，叹道：“想不到我任盈盈竟也终身和一只大马猴锁在一起，再也不分开了。”盈盈的爱情得到圆满，她是心满意足的，令狐冲的自由却又被锁住了。或许，只有在仪琳的片面爱情之中，他的个性才极少受到拘束。 </p><p>人生在世，充分圆满的自由根本是不能的。解脱一切欲望而得以大彻大悟，那是佛家所追求的最高境界“湼盘”，不是常人之所能。那些热中于政治和权力的人，受到心中权力欲的驱策，身不由己，去做许许多多违背自己良心的事，其实都是很可怜的。 </p><p>​    对于郭靖那样舍身赴难，知其不可而为之的大侠，在道德上当有更大的肯定。令狐冲不是大侠，是陶潜那样追求自由和个性解放的隐士。风清扬是心灰意懒、惭愧懊丧而退隐。令狐冲却是天生的不受羁勒。在黑木崖上，不论是杨莲亭或任我行掌握大权，旁人随便笑一笑都会引来杀身之祸，傲慢更加不可。“笑傲江湖”的自由自在，是令狐冲这类人物所追求的目标。 </p><p>推荐</p>]]></content>
    
    
    <categories>
      
      <category>书影音</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金庸武侠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内联函数</title>
    <link href="/2022/05/02/C%E5%92%8CC++/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/02/C%E5%92%8CC++/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>许多程序员使用带有参数的宏来完成简单函数的调用。宏替换的好处是没有函数调用的开销，能够加快代码的执行。</p><p>但宏替换是一种无类型机制，只能实现比较简单的功能，有时还会产生预期之外的副作用。而函数正好相反。</p><p>为了结合宏替换和函数的优点，C++语言允许定义内联函数。在函数原型前加上<code>inline</code>表示这是一个内联函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br></code></pre></div></td></tr></table></figure><p>在编译时，会将将调用内联函数的地方用相应的函数体替换，能够加快代码的执行，减少函数调用的开销。</p><p>需要注意的是，不是所有的函数都需要定义为内联函数，在使用内联函数时要注意一下事项：</p><ul><li>内联函数内不允许有循环语句和开关语句。如果内联函数内有这些语句，则按普通函数处理。</li><li>内联函数的函数体不宜过长，以1～5行为宜。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类型转换</title>
    <link href="/2022/05/02/C%E5%92%8CC++/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/05/02/C%E5%92%8CC++/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换是指将一种类型的值转换为另一种类型的值。C++中有两种形式的类型转换：<strong>显式类型转换</strong>和<strong>隐式类型转换</strong>。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>隐式类型转换发生在以下几种情况：</p><ul><li><strong>混合运算</strong>：级别低的类型向级别高的类型转换。（一般来说，某个类型的一个数据占用的存储空间越多，则该类型的级别越高）</li><li><strong>将表达式的值赋给变量</strong>：表达式的值向变量类型的值转换。</li><li><strong>函数实参向函数形参传值</strong>：实参的值向形参的值转换。</li><li><strong>函数返回结果</strong>：返回的值向函数返回类型的值进行转换。</li></ul><p>需要注意的是，<strong>隐式转换是在编译时进行的</strong>，因此不需要运算符的参与。</p><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><p>显示类型转换有下面几种风格：</p><ol><li>C风格：<code>(类型名)表达式</code>或<code>(类型名)(表达式)</code>;</li><li>C++风格：<code>类型名(表达式)</code>。此时，<strong>类型名</strong>就是一个<strong>类型转换运算符</strong>。</li><li><strong>类型安全的显式类型转换运算符</strong>：<ol><li><code>static_cast&lt;类型名&gt;(表达式)</code>：作用类似于C风格和C++风格的转换功能，同时也能用在不需要显式转换的地方。</li><li><code>const_cast&lt;类型名&gt;(表达式)</code>：将const或volaile数据转换为非<code>const</code>或非<code>volatile</code>的数据。</li><li><code>dynamic_cast&lt;类型名&gt;(表达式)</code>：将父类指针转换为子类指针。</li><li><code>reinterpret_cast&lt;类型名&gt;(表达式)</code>：将一个数据转换成一个完全不同意义的数据，在使用时一般要在这样的转换后再做逆转换。（这是一种具有潜在危险性的转换）</li></ol></li></ol><p>需要注意的是，无论是哪种类型转换，都需要申请一个临时单元，将要转换的值先复制到临时单元，转换发生在临时单元中。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《强风吹拂》</title>
    <link href="/2022/04/08/%E8%AF%BB%E4%B9%A6/%E5%BC%BA%E9%A3%8E%E5%90%B9%E6%8B%82/"/>
    <url>/2022/04/08/%E8%AF%BB%E4%B9%A6/%E5%BC%BA%E9%A3%8E%E5%90%B9%E6%8B%82/</url>
    
    <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="第一章-竹青庄的房客"><a href="#第一章-竹青庄的房客" class="headerlink" title="第一章 竹青庄的房客"></a>第一章 竹青庄的房客</h3><p>明明没有目的地，却仍日日不间断地跑下去——这样的人，能够断言自己究竟是喜欢还是讨厌跑步吗？</p><p>对阿走而言，能纯粹地享受跑步的乐趣，只停留在幼时踏着青草跑遍高山原野的时期。之后的跑步生涯，无非是被困在椭圆形跑道上，拼命挣扎并抵抗时间流逝的速度——直到那一天，那股一发不可收拾的冲动粉碎了过去堆砌起来的一切。</p><p>即使如此，他也没有因此觉得恐惧或不安。他对独自在人生地不熟的地方生活不以为苦，反而感觉如获新生。</p><p>“为了自我锻炼，”姆萨说，“人在黑暗中下水时，心中往往会产生很大的不安，然而我认为这是一帖省视自我的良方。阿走，你不妨也试试看。”</p><p>呼吸越来越困难，但阿走依然不换气，只是出于习惯地计数自己的心跳。比这还痛苦的经验，他在跑步时可尝过许多；跑到肺部充血，跑到血的气味涌上喉头，是很寻常的事。尽管如此，他还是继续在跑，这是为什么？因为他在跑步中找到快乐吗？还是他不想输给任何人，不想输给自己？</p><h3 id="第二章-天下第一险峰——箱根山"><a href="#第二章-天下第一险峰——箱根山" class="headerlink" title="第二章 天下第一险峰——箱根山"></a>第二章 天下第一险峰——箱根山</h3><p>不论是代表学校参加竞赛，或是在世界舞台上留下纪录的可能性，阿走对这些都毫无眷恋。相较之下，他更喜欢的是：感受肉体破风前进的舒畅感，自由任意的奔驰。那些被组织的期待与野心束缚、像只白老鼠一般任人宰制的日子，他早就厌倦了。</p><p>退出田径队后，阿走仍持续进行自我锻炼，想到达那个他尚未能得见的疾速世界。流逝而过的景色，掠过两耳的风。等他跑出五千米13分40秒的成绩时，自己将目睹什么样的景致？自己的肉体又会使血液沸腾到什么地步？无论如何，他一定要亲身体验这未知的世界。</p><p>“我很想知道，跑步的真谛究竟是什么。”</p><h3 id="第三章-开始练习吧！"><a href="#第三章-开始练习吧！" class="headerlink" title="第三章 开始练习吧！"></a>第三章 开始练习吧！</h3><p>在那样狭隘的人际关系里，他忙着求生存，根本无暇思考、感受其他事物。</p><p>换个角度来说，如果不每天跟自己的身体对话、累积练习量，就没办法在长跑项目拿到好成绩。每一种运动都需要天分，但长跑运动需要的“努力”绝对大于“天分”，而这也是它和其他运动最大的不同。</p><p>“阿走，你觉得什么样的人适合长跑？”</p><p>这种全心全意投注在同一件事上却不以为苦的个性，绝对很适合长跑。”</p><p>为跑步而生的阿走，以及很清楚“想跑却不能跑”有多痛苦的清濑。这两个对跑步怀抱无比热情的人，一定能影响彼此，抵达大多数人难以窥见的至高境界。</p><p>Cross country，是越野赛跑的简称</p><p>就是照着设定好的速度来跑。每一次跑步前，我都会依据你们的体能状态和跑力[2]来调整速度。”</p><p>跑步时最重要的是放松身体，好让自己能跑得久、跑得越来越远。</p><p>Jog，就是慢跑的意思</p><p>加速跑是慢慢地加快速度，然后冲刺；间歇跑则是一种快跑和慢跑交错组合的跑法</p><p>练跑的目的就是增加心肺功能的负担，当然要辛苦一点才有意义</p><p>清濑是个性谨慎细腻的人，因此要求每个人都要填写练习日志。除了必须记下训练表规定的练习花费多少时间，也得记录自己每天自发地做了哪些训练，跑了多久、多远。</p><h3 id="第四章-纪录赛登场"><a href="#第四章-纪录赛登场" class="headerlink" title="第四章 纪录赛登场"></a>第四章 纪录赛登场</h3><p>我把田径当成自己的第二生命，一般人却只把它当成一项无聊的比赛。这个事实对阿走造成很大的冲击，却又不禁同时沾沾自喜起来：原来我们每天拼死拼活追求的目标，大多数人都看不出来它多么有意义呀。</p><h3 id="第六章-灵魂的呼喊"><a href="#第六章-灵魂的呼喊" class="headerlink" title="第六章 灵魂的呼喊"></a>第六章 灵魂的呼喊</h3><p>不被任何事物牵绊，自由地尽情奔跑。不听从任何指挥，只听从身体和灵魂深处发出的呐喊，跑到天涯海角。</p><p>如果只是疯狂地拼命练习，绝对没办法掌握个中精髓。这是一场和自己内心搏斗的战役。我希望你们倾听自己身心的声音，小心谨慎地磨炼自己。”</p><p>战胜不安与恐惧，把自己锻炼得锐利光滑、百尘不侵——这样的力量，就是清濑所说的“强”之一吧。</p><h3 id="第七章-预赛，开跑！"><a href="#第七章-预赛，开跑！" class="headerlink" title="第七章 预赛，开跑！"></a>第七章 预赛，开跑！</h3><p>看着不断加速的阿走，清濑不禁陷入一阵狂喜。<br>大家好好睁大眼，看清楚他跑步的模样！看他那为跑步而生的身躯有多美丽！</p><p>清濑很想放声大喊，但现在只能想办法忍住。阿走，果然只有你。只有你可以这样体现跑步的真貌。能够鞭策我、让我见识到全新世界的人，只有你，阿走。</p><p>认真起来的阿走，竟然能跑这么快！他浑身散发出光芒，耀眼得让人无法直视。果然是万中选一的人。根本不用多说什么就能证明这一切。</p><p>他发出粗重的喘息声，一瞬间就从叶菜子面前经过，笔直地往前跑去，眼里只看得见终点线。他像在短跑一样全力冲刺，跑完最后的五十米，充满坚持和斗志的跑姿震慑了全场的观众。</p><p>因为我想，跟满脑子肌肉的你们，这辈子一起筑梦一次也不错，所以才……！</p><p>“他们犯的另外一个错误是，以为运动只要赢了就好，”藤冈继续说，“日本选手只要得第一名、拿金牌就好了吗？真是大错特错。这绝对不是运动的本质。如果今天我拿到第一却有种输给自己的感觉，对我而言这根本就不算胜利。比赛的成绩和排名，会让人眼花缭乱，模糊了焦点。所谓世界第一，应该由谁决定？我们追求的，不是这种东西；心里那个不变的理想和目标，才是支持我们继续跑下去的动力，不是吗？”</p><p>“要在箱根连胜，就是需要这样的意志力和真正的智慧吧。”</p><p>藤冈把心里的想法转换成语言的力量；他冷静分析自己内心迷惘、愤怒和恐惧的眼光。</p><p>藤冈很强。他的跑步速度本来就无人可出其右，但背后那股支撑着他的意志力其实更厉害。在我只知道不顾一切往前跑时，藤冈一定在他脑子里进行了无数的自我剖析，追求更高境界的跑法。</p><p>这就是我欠缺的。每次遇到说不清楚、讲不明白的地方，总是放任它过去，草草带过。从现在起，不能再这样了。我要像藤冈，不，我要跑得比藤冈更快。为了达到这个目标，我必须认清那个跑步中的我。</p><p>这一定就是清濑之前所说的那种“强”。<br>“我觉得我好像懂了。”</p><h3 id="第八章-冬天又来了"><a href="#第八章-冬天又来了" class="headerlink" title="第八章 冬天又来了"></a>第八章 冬天又来了</h3><p>阿走的心思，几乎全被跑步占去了，例如手腕摆动的幅度、双脚着地时的角度，或是肌肉的紧张和弛缓度等问题。这样比较好？还是那样？他对全身上下的每个细胞都保持高度关注，确认着跑出去的每一步。</p><p>榊每次说的话，其实都有他的道理。只不过，我跟他不一样。我所追求的、想透过跑步发现的事物，应该都跟榊不同吧。</p><p>阿走偷偷伸手摸摸自己的胸口。怎么回事啊？心脏竟然一阵阵隐隐作痛。就像喝冰的饮料时渗进牙齿那种感觉，让牙龈发肿、热热的、刺刺的那种痛。</p><p>愤怒，是他内心怯懦和缺乏自信的写照。清濑和叶菜子叫他要“相信”，其实是想叫他“勇敢面对”吧。勇敢面对自己、面对对手。</p><p>“我很后悔。我气自己那个时候除了打人，想不到其他的解决方法。只有这样而已。”</p><p>阿雪手上提着下北泽一家唱片行的袋子。无论有多忙，阿雪的生活里还是不能没有音乐。</p><p>“家家有本难念的经。总之，家人之间，最好不要对彼此有太多期待，就算关心也要保持适当的距离。”</p><p>明明是一个明年就会面临存亡危机的小社团。明明是一堆门外汉在硬撑，好不容易才走到今天。但是清濑不知道什么是放弃，永远向前看，给大家带来梦想和目标，坚定地领导竹青庄的每个人，追求跑步的最高境界，朝着结合个人竞技与团体竞技的终极目标——箱根驿传的顶点前进。</p><p>“我会让你们看到顶点的，不对，应该说，我们一起来享受站上顶点那种滋味。大家拭目以待。”</p><h3 id="第九章-奔向彼方"><a href="#第九章-奔向彼方" class="headerlink" title="第九章 奔向彼方"></a>第九章 奔向彼方</h3><p>“王子，到今天为止，一直勉强你陪着我们拼这一场，不好意思呐。”清濑说。</p><p>“灰二哥，我不想听到这种话，”王子笑着说，“在鹤见等我吧。”</p><p>总之他没抓到自己该有的节奏。</p><p>“我很难过，不能跟神童说‘真的不行的话，不要勉强参加’。”</p><p>北关东大的选手，在所有出赛者中拥有数一数二的纪录。阿雪早就把跟城太跑同一区间的选手数据给他看过，所以他知道，意气用事跟那个选手拼高下，只是白费力气而已。不过，东京学院大那个家伙，在追过我的时候已经气喘吁吁了。我迟早会追上去，再把它赢回来。</p><p>最后这段路是直线赛道，所以在一公里前就能看到平冢中继站。然而，一旦有了目标物，反而会让人心生一种再怎么跑都到不了的错觉。不可以心急。总之，一定要坚持下去，甩开这几个选手，尽可能争取好成绩，再把接力带交给城次。</p><p>阿走的生存之道，跟他跑步的样子很像：强而有力、直视前方，永远对眼中看到的一切抱着希望与期待。</p><p>但是，这不是我要的。我，我们想去的地方，不是箱根。我们的目的地，一定得靠着跑步才能到达，那是个更远、更深，更美丽的地方。虽然我现在没办法马上去到那里，但总有一天，我一定要亲眼目睹那里的风景。在那之前，我会一直跑下去。看着吧，熬过这痛苦的一公里，我会离那个世界更近一点。</p><p>“真的很痛苦的话，中途弃权也没关系。”<br>神童惊讶地转头，两眼直盯着阿雪。这句话，或许会对神经紧绷、战战兢兢的神童，在身心上都造成不良影响，但就算这样，阿雪还是没办法不说。<br>神童那对因发烧而有点浑浊的双眼，这一瞬间竟闪过一抹清澈的光芒。阿雪与神童四目相望，再次开口说：“就算你这么做，也不会有人会怪你的。所以，真的撑不下去时，拜托你一定要立刻弃权。”</p><p>好强，阿走突然想起。清濑曾经说过的“强”，或许就是这个意思。不论个人赛或驿传，跑步需要具备的强韧，在本质上是永远不会改变的。</p><p>那是再怎么痛苦也要向前进的一种力量，以及持续与自己战斗的勇气，也是不只着眼于眼睛看得到的纪录、更要一次又一次超越自我极限的毅力。</p><p>阿走不得不承认，神童真的很强。今天如果让阿走来跑五区，或许宽政会取得更好的名次，但这不代表阿走赢过神童。<br>神童非常强，而且还向阿走亲自示范了跑步应该是什么样子。<br>我，我们这群人，到底为了什么而跑？<br>阿走目不转睛看着巨幅屏幕。<br>明明这么痛苦，这么难过，为什么就是不能放弃跑步？因为全身细胞都在蠢蠢欲动，想要感受强风迎面吹拂的滋味。</p><p>竹青庄的每个人，都是有实力的人才。我想证明这一点。弱小的社团也好，外行人也好，只要有实力和热情，一样也能跑。不用对任何人唯命是从，只要凭着两只脚，就能跑到任何想去的地方。我想在箱根驿传里证明这件事。这是我长久以来的心愿。”</p><p>那天晚上，当你在街上狂奔、经过我身边的时候，”清濑平静地说，“我心想，终于让我找到了。当时我很想大喊，‘我的梦想，现在正奔驰在我眼前！’我骑着脚踏车追你，很快就发现你是仙台城西高的藏原走。明知道你是谁，却还是把无处可去的你拖下水。”</p><h3 id="第十章-流星"><a href="#第十章-流星" class="headerlink" title="第十章 流星"></a>第十章 流星</h3><p>感情的事，不是比赛，没有输赢。叶菜子的心，只属于叶菜子。城次的心只属于城次。而阿走的心，同样的，也只属于阿走，任谁也无法夺走，无法改变。这是一个不受任何框架束缚的领域。</p><p>阿走，你可别跑得太远。虽然我知道你追求的世界有多美，但那里未免太寂寞太寂寥了，不是我们活生生之人归属的境地。</p><p>“灰二啊，”尼古搔了搔头，“真的要轻松的话，不跑最轻松，我也不用减肥、戒烟了。不管用什么速度，只要决定要跑就不可能轻松。打从一开始，我就只是为了身体健康才跑的，所以呢，不管最后我跑几名，你可都不准抱怨。”</p><p>虽然清濑也会采取强势的手段来对付他们，但他从来不曾苛责那些没有跑步经验的人，也绝不会伤害他们的情感，或看不起别人引以为傲的事物。他总是配合每个人的性格，不厌其烦地引导着大家，让他们愿意主动面对跑步。</p><p>尼古的不幸是，没有任何指导者曾经告诉他，就算他不能当田径选手，也还是可以继续跑步；没有人告诉他，如果真的喜欢跑步，尽情享受跑步的美好就好。</p><p>过程中他终于明白了一个道理：没有意义也不是什么坏事。这不是在说什么漂亮话。跑步的目的，当然是要取得胜利，但胜利其实有许多种形式。所谓的胜利，不单是指在所有参赛者中跑出最好的成绩。就像人活在这世上，怎样才算“人生胜利组”，也没有明确的定义。</p><p>不管有没有意义，为了证明我们到今天为止所做的一切是值得自豪的，现在唯一能做的就是尽全力去跑。</p><p>是了，长跑就是这么寂寞，尼古心想。像在没有星星的夜空下，踏上旅途一般的孤独与自由。跳动到极限的心脏，涔涔的汗水冷却后又马上让肌肤发热、血液流窜奔腾的肌肉，这一切的感受除了尼古自己，都没有任何人知道。到跑完既定的道路、抵达既定的地点为止，都不会跟任何人有接触，尼古必须独自面对这场旁人无法理解的战斗。</p><p>从放弃田径那一刻起，我就一直在等待。等待有人再给我一次机会。等待有人就算知道我的身体不适合田径赛，但能看到我打从灵魂深处热爱跑步、追求跑步、渴望跑步。等待着有人能对我说：尽管去跑吧！</p><p>KING怎么也学不会跟人保持一种若即若离、自然而然的绝佳距离。不管身在何处，不论和谁相处，他都觉得自己像漂浮在半空中。虽然他可以八面玲珑、避免与人争执，却没办法向任何人敞开心胸，只会为了掩饰软弱而虚张声势。面对这样的KING，当然没有人会想踏入他的内心世界。再加上KING自己认为，觉得寂寞是很丢脸的事，结果他的表面功夫也越做越好。</p><p>灰二哥，你说我“是打从灵魂深处在探索跑步这件事”。这句话，说的应该是你吧。是灰二哥你自己的写照。</p><p>“这一年来，我看着你跑步的样子，跟你一起生活到现在，”清濑的声音有如一潭深邃的湖泊，静静地浸润阿走的内心，“我对你的感觉，已经不是‘有没有信心’这句话可以表达的了。相不相信不重要，重要的只有你。阿走，我心目中最棒的跑者，只有你而已。”</p><p>喜悦之情盈满阿走的心。这个人，给了我世间无可取代的东西。就在现在，给我一个永恒闪耀、最珍贵的宝物。</p><p>阿走的状况十分良好，内心却像无风的水面，宛如一面可以映照未来的魔法之水，清澄透澈、静谧无声，没有一丝涟漪。</p><p>完全没有多余的动作，完美的姿势展现出无比的强度与速度，仿佛在向世人宣告：“这才是跑步！”</p><p>“只要努力就一定能成功，其实是一种傲慢。”</p><p>“田径的世界没有那么天真，但是，目标也不是只有一个。”<br>就物理观点来看，大家都跑在同一条赛道上。然而，每个人到达的境界却各有不同，借由跑步找到属于自己的终点。跑者们总是不断在思考、迷惘、犯错，然后再重新来过。<br>如果每个跑者的答案与终点都相同，长跑就不会这么令人着迷了。如果跑步只是这么表面化的行为，看到像阿走这么梦幻的跑法后，恐怕不会还有人想继续跑下去。</p><p>跑步是力量，而不是速度；是虽然孤独，却也跟他人有所连结的一种韧性。</p><p>灰二哥，你说“信心”这个字眼不足以表达你心里的感受。我也这么想。因为任何说出口的话都有可能变成谎言，而百分之百的信任只会自然涌现在心里。这是我头一次明白，信任自己以外的某个人，是多么崇高的一件事。</p><p>既然是祭典，所以，大家开心就好了，阿走豁达地想。我不奢求有人理解自己到底是用什么样的心情在跑步，在这项运动中投注了多少体力与精神。这种痛苦和兴奋，只有跑者自己明白，但跑者可以和现场所有人分享参与比赛的喜悦。不论跑者或观众，都能够一起感受、一起玩味这一路连绵不绝直到大手町的热情欢呼声。<br>虽然只有一个人，却又不是一个人。跑者和观众将道路化成一条流动的河川。</p><p>“清濑，我们到底要跑到哪里才能停下？以为已经抵达目的地，结果前方还有路，而且又长又远。我所追求的跑步……”<br>清濑在藤冈的眼中，看到暗淡的绝望之光。一个人孤独地跑着，永无止境追求着。阿走身上也有跟他一样的阴影。<br>藤冈，你并不孤单。托你的福，让阿走变强了。今后你们俩一定会以彼此的存在相互激励，朝更高的境界迈进，直到有一天，克服万难，到达那个任何人都到不了的地方。<br>清濑其实想这么说，却紧闭着双唇不语，因为他心里其实非常羡慕。羡慕阿走，羡慕藤冈。因为他们是被“选中”的人。于是，清濑只是这么说：“但你还是不会放弃吧？”<br>他只说这么多。<br>“你就是没办法放弃跑步，不是吗？”<br>“说得对，”藤冈这次真的敞开心房，嘴角扬起笑意，“反正就是再重新来过而已。”</p><p>藤冈那些队友中没有任何人发现，即使他跑出决定胜负的成绩，同时创下区间新纪录，但藤冈心里仍然存在着一片无可填补的空虚。<br>这不是因为他输了，而是因为他不满足。而且正是这个原因，驱使他继续跑下去，变得更加强大。<br>“原来，被选中的人也有很多烦恼啊，”清濑喃喃自语着，往王子走去，“阿走应该已经收到情报了吧？”</p><p>从第一次相遇的那天晚上起，我就知道了。我一直等待的、一心一意追求的，就是你，阿走。<br>阿走让清濑亲眼目睹了自己心目中的跑步。那是他长久以来不断渴求，却因为遍体鳞伤而不得已打算舍弃的梦想，阿走却轻而易举地将它展现在他眼前。在这个世界上，我从没见过比阿走更美丽的生物。<br>宛如划破夜空的流星。你奔跑的姿态，就像那一道冷冽的银色流光。<br>如此璀璨夺目。我可以看到，你奔行的轨迹散发出白色的光辉。</p><p>在那个当下，心理和生理处于一种兴奋状态，仿佛跑到天涯海角都不成问题。但他现在的感觉，跟“跑者高潮”有点不太一样，而是一种更澄澈、更冷静的恍惚感。</p><p>清濑的样子有如自始至终都站在那里一样，定定凝视着阿走。他的神情喜悦中又带点哀愁，对阿走绽开笑颜。</p><p>没有必要呼喊对方的名字。只在接触的一瞬间，眼神交会，一切尽在不言中。<br>灰二哥，我们终于来到这么远的地方。言语或肢体碰触，在这最后一刻都不需要了。前往这遥远的国度，我们一起做到了。</p><p>清濑面对的敌人，不是其他大学的选手，而是时间，以及自己脚上的旧伤。</p><p>“ZONE”的意思是指在精神高度集中下，身心产生变化的一种特殊状态。据说，经过严酷训练的运动员在比赛中发挥体能极限时，有少数人可以达到“ZONE”的境界。</p><p>清濑思考了很久。关于长跑比赛，关于跑步这件事的意义，他都彻底思考过，最后选择了宽政大。六道大的每个选手，毫无疑问都拥有继续成长的实力。那样的地方，他觉得不适合自己。但他想继续跑下去的愿念，又像火焰一般炙热、无法平息，因此他觉得自己必须找一个地方，而那里的人与跑步完全无关，然后再次省视自己、问自己。</p><p>我，到底为什么而跑？</p><p>不管跑不跑步，每个人都有自己的痛苦，同理，也有各自的喜悦。不论任何人，都有他必须面对的烦恼；即使明知愿望无法达成，也挣扎着向前进。</p><p>跟田径保持一段距离后，清濑反而认清一个道理：既然不论去任何地方都一样，不如坚定立场，遵循内心的渴望坚持到最后。</p><p>“你啊，被他骗了那么多次，怎么就是学不乖。”<br>无所谓，阿走心想，两眼直盯着不久后可以看到清濑身影出现的转角。被骗多少次都无所谓。只要灰二哥说他要跑，我就会等他。我会一直静静等下去，等着亲眼看到灰二哥使尽全力跑来的那一刻。</p><p>清濑感觉到真中大选手的视线停留在自己左脸颊上，借此刺探他的动向。但他完全没有转头看对手，只是看着前方往前跑。</p><p>清濑在前方看到自己追求的目标。竹青庄的伙伴们站在写着“东京往返箱根大学驿传大赛”的横幅布条下。他们正在对清濑大声呐喊着。</p><p>我一定会跑到那里的。拂过身边的强风告诉我，我还在跑。我正在用自己的身躯，体现我心目中的跑步。好痛快。这辈子从来不曾比现在还要幸福。</p><p>阿走的视线再度回到清濑身上，几乎已经准备冲到赛道上。但当他与清濑四目相对时，看到清濑汗水淋漓的脸上慢慢绽出微笑。那是当一个人豁出所有、也得到所求的一切时，才会露出的神情。</p><p>阿走收回踏上前的脚步。我没办法阻止他，也不能叫他不要再跑了。渴望跑步、决心为跑步献出一切的灵魂，谁也没有资格阻止。</p><p>阿走看到了。突然仰头望向天空的清濑，仿佛找到什么珍贵又美丽的东西，脸上浮现豁然清明的神情。<br>灰二哥，你曾经对我说，你想知道跑步的真谛究竟是什么。我们之间的一切，就从这里开始。现在，让我告诉你，我的回答。<br>我不知道。虽然我还是不知道答案，但我知道在跑步里有幸福也有不幸。我知道在跑步这件事中，存在着我和你的一切。</p><p>阿走有一种近乎确信的预感。我，大概到死为止都会一直跑下去吧。<br>就算有一天，我的身体再也跑不动，我的灵魂在我咽下最后一口气之前，也不会放弃跑步。因为跑步带给阿走一切。这地球上存在的最珍贵事物——喜悦、痛苦、快乐，或是嫉妒、尊敬、愤怒，还有希望——透过跑步，阿走学到这一切。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>“对我来说，是灰二哥他教会我关于跑步的一切，”阿走说，“除了一件事以外。”<br>“那是什么事？”<br>跑步的真谛到底是什么？<br>只有这件事，灰二哥他没有教我。或许，这是不能靠别人来教的事。<br>因为想知道答案，阿走才会跑步，持续不停地跑。他也曾经以为自己已经到达顶点，但那感觉总是瞬间即逝，而且这些成绩也不代表跑步的意义。<br>“你很快就自己发现那是什么了，”阿走平静地对身旁的一年级新生说，“只要你继续跑步，总有一天也会开始追寻它。”</p>]]></content>
    
    
    <categories>
      
      <category>书影音</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跑步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《飞狐外传》</title>
    <link href="/2022/04/03/%E8%AF%BB%E4%B9%A6/%E9%A3%9E%E7%8B%90%E5%A4%96%E4%BC%A0/"/>
    <url>/2022/04/03/%E8%AF%BB%E4%B9%A6/%E9%A3%9E%E7%8B%90%E5%A4%96%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="第2章-大雨商家堡"><a href="#第2章-大雨商家堡" class="headerlink" title="第2章 大雨商家堡"></a>第2章 大雨商家堡</h3><p>​    田归农脸如白纸，望着院子中的大雨。<br>​    三个人的目光瞧着三处，谁也不瞧谁一眼，各自安安静静的坐着，一言不发。但三人心中，却如波涛汹涌，有大哀伤，有大决心，也有大恐惧。</p><h3 id="第3章-宝刀和柔情"><a href="#第3章-宝刀和柔情" class="headerlink" title="第3章 宝刀和柔情"></a>第3章 宝刀和柔情</h3><p>那小姐相貌娇美，肤色白腻，樱红小嘴，双目灵动，别说北地罕有如此佳丽，即令江南也是少有。她身穿一件葱绿织锦的皮袄，颜色鲜艳，但在她容光映照之下，再灿烂的锦缎也显得黯然无色。<br>    众人眼前一亮，不由得都有自惭形秽之感，有的讪讪的竟自退到了廊下，厅上登时空出一大片地方来。 </p><p>客店中夥伴客人见这三人到来，早知不妙，这时见取出兵刃，人人远避，登时大厅中空荡荡的一片。南小姐关心苗人凤安危，却留在厅角之中。苗人凤见她一个娇怯弱女，居然有此胆量，大是喜慰。只因南小姐在厅角这么一站，苗人凤自此对她生死以之，倾心相爱，当下向她微微一笑，抽出冷月宝刀。 </p><p>​    他一生慷慨豪侠，素来不理会小节，然而这是他生死以之相爱的人……在他脑子里，一直觉得南兰应该逃出去，她是女人，不会半点武功，见到了浓烟烈火自然害怕，她那时又不是他妻子，陪着他死了，又有什么好处？……但在心里，他深深盼望在自己遇到危难之时，有个心爱的人守在身旁，盼望心爱的人不要弃他而先逃……他一直羡慕胡一刀有个真心相爱的夫人，自己可没有。胡一刀虽早死，这一生却比自己过得快活。 </p><p>为什么当日救她的不是这位风流俊俏的田相公，偏生是这个木头一般睡在身旁的丈夫？她却不懂，这个田相公武功不够，根本救不了她，就算能救，他也不肯冒险出手。 </p><h3 id="第4章-英雄年少"><a href="#第4章-英雄年少" class="headerlink" title="第4章 英雄年少"></a>第4章 英雄年少</h3><p>福公子搁下了玉箫，伸出手去搂她纤腰。马春花娇羞地避开了，第二次只微微让了一让。<br>    但当他第三次伸手过去时，她已陶醉在他身上散发出来的男子气息之中。夕阳将玫瑰花的枝叶照得撒在地下，变成斑驳陆离的影子。在花影旁边，一对青年男女的影子渐渐偎倚在一起。太阳快落山了，影子变得很长，斜斜的很难看。<br>    唉，青年男女的热情，不一定是美丽的。 </p><p>​    她嘴角边带着微笑，但这不是为他二人笑的。她看到了他们，却全然没看见他们，她只是在想着适才的幸福和甜蜜。福公子常常向她偷看一眼两眼，但她决不敢回看，因为她很明白，只要回看他一眼，四目交投，再也分拆不开了。 </p><p>他是使暗器的大高手，最恨旁人在暗器之上喂毒，常自言道：“暗器原是正派兵器，以小及远，与拳脚、器械，同为武学三大门之一，只是给无耻小人一喂毒，便让人瞧低了。” </p><h3 id="第5章-铁厅烈火"><a href="#第5章-铁厅烈火" class="headerlink" title="第5章 铁厅烈火"></a>第5章 铁厅烈火</h3><p>赵半山双手负在背后，在厅中缓步来去，朗声说道：“咱们学武的，功夫自然有高有下，但只要心地光明磊落，行事无愧于天地，那么功夫高的固然好，武艺低也是一般受人敬重。我赵某人生平最恨的就是行事歹毒、卑鄙无耻的小人。”他越说声音越严厉，双目瞪着陈禹不动。 </p><p>赵半山拍拍他肩头，说道：“贤弟，你三哥没什么了不起，你将来所作所为，一定要胜过三哥十倍，那才真正是男子汉大丈夫。”胡斐道：“可惜我爹爹过世得早，今日得见三哥，我做人才有了榜样。” </p><p>胡斐哈哈一笑，心道：“我贫你富，你赠我黄金，我也不能拒却。三哥怕我推辞，赠金之后急急驰走，未免将我胡斐当作小孩子了。” </p><h3 id="第6章-血印石"><a href="#第6章-血印石" class="headerlink" title="第6章 血印石"></a>第6章 血印石</h3><p>这二人手腕给胡斐抓在掌中，宛如给铁箍牢牢箍住了一般，那里还动弹得半分？胡斐低声道：“我本是个杀人不眨眼的大盗，现下改邪归正，学做生意，要一万两银子办货，可是短了本钱，只得向二位各借五千两。”二人大吃一惊，齐声道：“我……我没有啊。”胡斐道：“好，你们把凤老爷逼死人命的事，说给我听。那一位说得明白仔细，我便不向他借钱。这一万两银子，只好着落在另一位身上。”二人忙道：“我来说，我来说。”先前谁都不肯说，这时生怕独力负担，做了单头债主，竟争先恐后起来。 </p><p>料想白日定然无人露面，便在僻静处找了株大树，爬上树去闭目养神，想到锺家四口受害的惨状，悲愤难平，心中翻覆起誓：“若不杀那凤贼全家，我胡斐枉自生于天地之间。”又想：“世事变化百端，实在难办得紧。我只是个一勇之夫，单凭武功，岂能事事顺利？” </p><h3 id="第7章-紫衣女郎"><a href="#第7章-紫衣女郎" class="headerlink" title="第7章 紫衣女郎"></a>第7章 紫衣女郎</h3><p>胡斐早看清来人是个妙龄少女，但见她身穿紫衣，身材苗条，正是途中所遇那个骑白马的女子。她背上负着一个包袱，却不是自己在饭铺中所失的是什么？只见她一张瓜子脸，双眉修长，眼大嘴小，姿形秀丽，容光照人，不禁大为惊讶：“这女子年纪和我相若，难道便有一身极高武功，如此轻轻巧巧的取去包袱，竟让我丝毫不觉？” </p><p>她每天只行五六十里路程，但胡斐始终没追上来，芳心可可，竟尽记着这个浑身臭泥的小泥鳅胡斐。</p><h3 id="第8章-风雨深宵古庙"><a href="#第8章-风雨深宵古庙" class="headerlink" title="第8章 风雨深宵古庙"></a>第8章 风雨深宵古庙</h3><p>​    胡斐伸了伸舌头，道：“嘿，武林十三家总掌门，这名头可够威风啊。”袁紫衣笑道：“胡大哥，你武艺这般强，何不也抢几家掌门人做做？咱们一路收过去。你收一家，我收一家，轮流着张罗。到得北京，我是十三家总掌门，你也是十三家总掌门。咱哥儿俩一同去参与福大帅的什么天下掌门人大会，岂不有趣？</p><p>​    两人并肩坐着，突然间同时转过头来，目光相触，微微一笑，各自把头转开。隔了一会，胡斐问道：“你的赵三叔身子安好吧？”袁紫衣道：“好啊！他会有什么不好？”胡斐道：“他在那里？我想念他得紧，真想见见他。”袁紫衣道：“那你到回疆去啊。只要你不死，他不死，准能见着。”胡斐一笑，问道：“你是刚从回疆来吧？”袁紫衣回眸微笑，道：“是啊。你瞧我这副模样像不像？”胡斐摇头道：“我不知道。我先前只道回疆是沙漠荒芜之地，那知竟有姑娘这般美女。”<br>袁紫衣红晕上脸，“呸”了一声，道：“你瞎说什么？”胡斐一言既出，微觉后悔，暗想孤男寡女在这古庙之中，说话可千万轻浮不得，岔开话题，问道：“福大帅开这个天下掌门人大会，到底是为了什么，姑娘能见告么？”袁紫衣听他语气突转端庄，不禁向他望了一眼，说道：“他王公贵人，吃饱了饭没事干，找些武林好手消遣消遣，还不跟斗鸡斗蟋蟀一般？只可叹天下无数武学高手，受了他愚弄，竟不自知。” </p><p>火光映照之下，袁紫衣娇脸如花，低语央求，胡斐不由得心肠软了，见到她握着银鞭的手莹白如玉，一股冲动，便想抛下单刀，伸手去握她的小手。一转念间，想她如此恳切相求，太过不近情理，其中多半有诈，心道：“胡斐啊胡斐，你若惑于美色，不顾大义，枉为英雄好汉。你爹爹胡一刀一世豪杰，岂能有你这等不肖子孙？”叫道：“如此便得罪了。”单刀一起，一招“大三拍”，刀光闪闪，已将袁紫衣上盘罩住，左手扬处，一锭纹银往凤天南心口打去。 </p><p>胡斐呆了半晌，包上包袱，手中却拿了那只玉凤凰，吹灭柴火，躺在稻草堆里，思潮起伏：“若说她对我好，何以要救凤天南，竭力跟我作对？若说对我不好，这玉凤凰，这洗乾净、缝补好的衣服鞋袜又为了什么？”<br>    一时睁大了双眼，那里还睡得着？黑暗之中，依稀闻到袁紫衣身上的淡淡幽香，伸出臂去，似乎抱到了她软软的腰肢，心想：“我抱住了她，她叫我放开，我便放开！她如心里当真对我好得很，那么叫我放开是假的。我是个大傻瓜，其实不该放开，我好后悔。她叫我放开，此刻后不后悔呢？”</p><h3 id="第9章-江湖风波恶"><a href="#第9章-江湖风波恶" class="headerlink" title="第9章 江湖风波恶"></a>第9章 江湖风波恶</h3><p>​    胡斐虽与他一见心折，但唯恐他是杀父仇人，恩仇之际，实所难处，待听他说自己父亲是他生平知交，心头一喜，双手接过女孩，见她约莫七八岁年纪，生得什是娇小，抱在手里，又轻又软，淡淡星光之下见她合眼睡着，呼吸低微，嘴角边露着一丝微笑。 </p><h3 id="第10章-毒手药王"><a href="#第10章-毒手药王" class="headerlink" title="第10章 毒手药王"></a>第10章 毒手药王</h3><p>​    他过去牵了马匹，说道：“咱们不过是邀他治病，又或讨一份解药，对他并无恶意。他最多不肯，那也罢了，何必要害咱们性命？”锺兆文道：“小兄弟，你年纪还轻，不知江湖上人心险诈。你对他虽无恶意，但他跟你素不相识，怎信得你过？眼前便是一个例子，刘鹤真对苗大侠绝无歹意，却何以弄瞎了他眼睛？”胡斐默然。 </p><p>​    那村女道：“你这人很好，我便索性连名字也都跟你说了。我叫程灵素，‘灵枢’的‘灵’，‘素问’的‘素’。”胡斐不知“灵枢”和“素问”乃中国两大医经，只觉这两个字很雅致，不像农村女子的名字，这时已知她决不是寻常乡下姑娘，也不以为异，笑道：“那我便叫你‘灵姑娘’，别人听来，只当我叫你是姓林的姑娘呢。”程灵素嫣然一笑，道：“你总有法儿讨我欢喜。”胡斐心中微动，觉她相貌虽不什美，但这么一言一笑，自有一股妩媚风致。 </p><p>程灵素道：“你说好了！他处处小心，反而着了我道儿，是不是？处处小心提防便有用了吗？只有像你这般，才会太平无事。”胡斐道：“我怎么啊？”程灵素笑道：“叫你挑粪便挑粪，叫你吃饭便吃饭。这般听话，人家怎会忍心害你？”胡斐笑道：“原来做人要听话才好。可是你整人的法儿也太巧妙了些，我还是摸不着头脑。” </p><h3 id="第11章-七心海棠"><a href="#第11章-七心海棠" class="headerlink" title="第11章 七心海棠"></a>第11章 七心海棠</h3><p>胡斐一怔，这才想起，她和自己约法三章，自己可一条也没遵守：“她要我不跟旁人说话，我不但说话，还自报姓名。她要我不许动武，我却连打两人。她叫我不得离开她身子三步，咳，我离开她十步也不止了……”越想越歉然，讪讪的道：“真对不起，只因我见这三人凶狠得紧，只怕伤到了你，心里着急，登时什么都忘了。” </p><p>程灵素微微一笑，道：“你是为我的一片好心，胡大哥，我还是领你的情。” </p><p>程灵素抬起头来，淡淡的道：“什么啊？瞧你急成这副样子！”胡斐定了定神道：“倘若你师哥师姊……并无非杀不可的过恶，请你给他们留一条改过自新的道路。”程灵素道：“是啊，我师父原也这么说。”顿了一顿，说道：“可惜你见不到我师父了，否则你们一老一少，一定挺说得来。”口中说话，手上团扇仍不住拨动。胡斐搔了搔头，指着蜡烛问道：“这毒烟……这毒烟不会致人死命么？”程灵素道：“啊，原来咱们胡大侠在大发慈悲啦。我是要救人性命，不是在伤天害理。”说着转过头来，微微一笑，神色颇为妩媚。胡斐满脸通红，心想自己又做了一次傻瓜，虽不懂喷放毒烟为何反是救人，心中却什感舒畅。 </p><p>程灵素道：“我这蓝花是新试出来的品种，总算承蒙不弃，没在半路上丢掉。”胡斐微笑道：“这花颜色娇艳，很是好看。”程灵素道：“幸亏这蓝花好看，倘若不美，你便把它抛了，是不是？”胡斐一时不知所对，只说：“唔……唔……”心中在想：“倘若这蓝花果真十分丑陋，我会不会仍藏在身边？是否幸亏花美，这才救了我和锺大哥的性命？” </p><p>程灵素指着门外的竹箩道：“大师哥便在这竹箩之中。小妹留下的海棠花粉，足够为他解毒。二师哥何不乘机跟他修好言和，也可得一强助？”姜铁山大喜，他一直为大师哥的纠缠不休而烦恼，想不到小师妹竟已安排了这一举两得的妙计，既退强敌，又解了师兄弟间多年的嫌隙，忙连声道谢，将竹箩提进门去。<br>    胡斐从铁门板上拾起那束枯了的蓝花，放入怀中。程灵素晃了他一眼，向姜铁山挥手道别，说道：“二师哥，你头脸出血，身上毒气已然散去，可别怪小妹无礼啊。”姜铁山一楞，登时醒悟，心道：“她叫王铁匠打我，固是惩我昔日的凶横，但也未始不无善意。鹊妹毒气未散，还得给她放血呢！”想起事事早在这个小师妹的算中，自己远非其敌，终于死心塌地，息了抢夺师父遗着《药王神篇》的念头。 </p><p>程灵素微笑道：“你若求我，我便去。只是你也须答允我一件事。”胡斐大喜，忙道：“答允得，答允得，什么事啊？”程灵素笑道：“这时还不知道，将来我想到了便跟你说，就怕你日后要赖。”胡斐道：“我赖了便是个贼王八！”<br>    程灵素一笑，道：“我收拾些替换衣服，咱们便走。”胡斐见她身子瘦瘦怯怯，低声道：“你一夜没睡，只怕太累了。”程灵素轻轻摇头，翩然进房。 </p><p>胡斐道：“我当是宝贝，你瞧来可不值一笑。”将布包摊开了送到她面前，道：“这是我小时候平四叔给我削的一柄小竹刀，这是我结义兄长赵三哥给的一朵红绒花，这是我祖传的拳经刀谱……”指到袁紫衣所赠的那只玉凤，顿了一顿，说道：“这是朋友送的一件玩意儿。”<br>    那玉凤在月下发出柔和的莹光，程灵素听他语音有异，抬起头来，说道：“是一个姑娘朋友吧？”胡斐脸上一红，道：“是！”程灵素笑道：“这还不是价值连城的宝贝吗？”说着微微一笑，将布包还给胡斐，随即躺倒，闭上眼睛，不再说话。 </p><h3 id="第12章-恩仇之际"><a href="#第12章-恩仇之际" class="headerlink" title="第12章 恩仇之际"></a>第12章 恩仇之际</h3><p>​    胡斐不去看苗人凤的伤目，只望着程灵素神色，要从她脸色之中，看出苗人凤的伤目是否有救。但见程灵素的眼珠晶莹清澈，犹似一泓清水，脸上只露出凝思之意，既无难色，亦无喜容，直教人猜度不透。 </p><p>胡斐见程灵素拿了刀针走到苗人凤身前，心中突然生念：“苗大侠和那毒手药王有仇。江湖上人心难测，若他们安排恶计，由程姑娘借治伤为名，却下毒手，岂不是我胡斐第二次又给人借作了杀人之刀？这时苗大侠全身穴道放松，只须在要穴中轻轻一针，即能制他死命。”正自踌躇，程灵素回过头来，将小刀交了给他，道：“你给我拿着。”忽见他脸色有异，当即会意，笑道：“苗大侠放心，你却不放心吗？”胡斐道：“若是给我治伤，我放一百二十个心。”程灵素道：“你说我是好人呢，还是坏人？”<br>    这句话单刀直入的问了出来，胡斐绝无思索，随口答道：“你自然是好人，非常好的好人！”程灵素很欢喜，向他一笑。她肌肤黄瘦，本算不得美丽，但一笑之下，神采焕发，犹如春花初绽。胡斐心中更无半点疑虑，报以一笑。程灵素道：“你真的信我了吧？”说着脸上微微一红，转过头去，不再和他眼光相对。 </p><p>程灵素在七心海棠上采下四片叶子，在一只瓦钵中捣得烂了，敷在苗人凤眼上。苗人凤脸上肌肉微微一动，接着身下椅子格的一响。<br>    程灵素道：“苗大侠，我听胡大哥说，你有位千金，挺可爱的，她在那里啊？”苗人凤道：“这里不太平，送到邻舍家玩去了。”程灵素用布条给他缚在眼上，说道：“好啦！三天之后，待得疼痛过去，麻痒难当之时，揭开布带，便没事了。现下请进去躺着歇歇。胡大哥，咱们做饭去。” </p><p>​    程灵素见胡斐脸有黯然之色，要逗他高兴，说道：“胡大哥，你累了半天，坐一忽儿吧！”胡斐摇头道：“我不累。”程灵素道：“你坐下，我有话跟你说。”胡斐依言坐下，突觉臀下一虚，喀的一声轻响，椅子四脚全断，碎得四分五裂。程灵素拍手笑道：“五百斤的大牯牛也没你重。” </p><p>胡斐下盘功夫极稳，虽坐了个空，但双腿立时拿桩，并没摔倒，只什觉奇怪。程灵素笑道：“那七心海棠的叶子敷在肉上，痛于刀割十倍，若是你啊，只怕叫出我的妈来啦。”胡斐一笑，这才会意，适才苗人凤忍痛，虽不动声色，但一股内劲，早把椅子坐得脆烂了，程灵素意在跟他开个玩笑。 </p><p>胡斐心中欢喜，说道：“多谢指点。晚辈终身受益。”举着筷子欲夹不夹，思量着他那几句话，筷子停在半空。程灵素用筷子在他筷子上轻轻一敲，笑道：“饭也不吃了吗？”胡斐正自琢磨刀诀，全身的劲力不知不觉都贯注右臂之上。程灵素的筷子敲了过来，他筷子上自然而然的生出一股反震之力，嗒的一声轻响，程灵素的一双筷子竟尔震为四截。她“</p><p>啊”的一声轻呼，笑道：“显本事么？” </p><p>胡斐忙陪笑道：“对不起，我想着苗大侠那番话，不禁出了神。”随手将手中筷子递了给她。程灵素接过来便吃。胡斐却喃喃念着：“嫩胜于老，迟胜于急，与其以客犯主……”一抬头，见她正用自己使过的筷子吃饭，竟丝毫不以为忤，不由得脸上一红，欲待拿来代她拭抹乾净，为时已迟，要道歉几句吧，却又太着形迹，便到厨房去另行取了一双筷子。 </p><p>​    胡斐自这口白菜一吃，才真正踏入了第一流高手的境界，回想适才花了这许多力气才胜得田归农，霎时之间又喜欢，又惭愧。<br>​    程灵素见他终于抢到白菜，笑吟吟的望着他，由衷为他欢喜。<br>​    苗人凤道：“胡家刀法今日终于有了传人，唉，胡大哥啊，胡大哥！”说到这里，语音什为苍凉。 </p><p>”<br>    胡斐听得她全心全意的护着自己，好生感激，但想到她要以厉害毒药去对付苗人凤，说也奇怪，反而不自禁的凛然生惧。<br>    心中又想：“这姑娘聪明才智，胜我十倍，武功也自不弱，但整日和毒物为伍，总是……”他自己也不知“总是……”什么，心底只隐隐觉得对她未免无益，不由得生了关怀照顾之意。</p><h3 id="第13章-古怪的盗党"><a href="#第13章-古怪的盗党" class="headerlink" title="第13章 古怪的盗党"></a>第13章 古怪的盗党</h3><p>​    程灵素解下负在背上的胡斐包袱，问道：“你要回去拿包袱吗？我给你带着了。”<br>​    胡斐喜道：“多谢你了。”程灵素道：“你包袱里东西太多，背着撞得我背脊疼，刚才我打开来整理了一下，放得平整服贴些，匆匆忙忙的，别丢失了东西，那只玉凤凰可更加丢不得。”胡斐给她说中心事，脸上一红，说道：“幸亏你带来了包袱，否则连今晚吃饭住店的银子也没了。最要紧的是我家传的拳经刀谱，决计丢不得。”程灵素打开包袱，取出他那本拳经刀谱，淡淡的道：“可是这本？我给你好好收着。”<br>​    胡斐道：“你真细心，什么都帮我照料着了。”程灵素道：“就可惜那只玉凤给我在路上丢了，真过意不去。”胡斐见她脸色郑重，不像说笑，心中一急，道：“我回头找找去，说不定还能找到。”说着转头便走。程灵素忽道：“咦，这里亮晃晃的是什么东西？”伸手到青草之中，拾起一物，莹然生光，正是那只玉凤。<br>​    胡斐大喜，笑道：“你是女诸葛，小张良，小可甘拜下风。”程灵素道：“见了玉凤凰，瞧你欢喜得什么似的。还给你吧！”将刀谱、玉凤和包袱都还了给他，说道：“胡大哥，咱们后会有期。” </p><p>胡斐一怔，柔声道：“你生气了么？”程灵素道：“我生什么气？”但眼眶一红，珠泪欲滴，忙转过了头去。胡斐道：“你……你去那里？”程灵素道：“我不知道。”胡斐道：“怎么不知道？”程灵素道：“我没爹没娘，师父又死了，又没人送什么玉凤凰、玉麒麟给我，我……我怎么知道去那里。”说到这里，泪水终于流了下来。<br>    胡斐自和她相识以来，见她心思细密，处处占人上风，遇上任何难事，无不迎刃而解，但这时见她悄立晓风之中，残月斜照，怯生生的背影微微耸动，不由得大生怜惜，说道：“我送你一程。”<br>    程灵素背着身子，拉衣角拭了拭眼泪，说道：“我又不去那里，你送我做什么？你要我医治苗大侠的眼睛，我已经给治好啦。” </p><p>胡斐要逗她高兴，说道：“可是还有一件事没做。”程灵素转过身来，问道：“什么？”胡斐道：“我求你医治苗大侠，你说也要叫我做一件事的。什么事啊，你还没说呢。”程灵素究是个年轻姑娘，突然破涕为笑，道：“你不提起，我倒忘了，这叫做自作孽，不可活。好，我要你干什么，你都答允，是不是？”胡斐确是心甘情愿的为她无论做什么事，昂然道：“只要我力所能及，无不从命。”<br>    程灵素伸出手来，道：“好，那只玉凤凰给了我。”胡斐一呆，大是为难，但他终究言出必践，当即将玉凤递了过去。程灵素不接，道：“我要来干什么？我要你把它砸得稀烂。”<br>    这一件事胡斐可万万下不了手，呆呆的怔在当地，瞧瞧程灵素，又瞧瞧手中玉凤，不知如何是好，袁紫衣那俏丽娇美的身形面庞，刹那间在心头连转了几转。<br>    程灵素缓步走近，从他手里接过玉凤，给他放入怀中，微笑道：“从今以后，可别随便答允人家什么。世上有许多事情，嘴里虽答允了，却是没法办到的呢。好吧，咱们可以走啦！”胡斐心头怅惘，感到一股说不出的滋味，给她捧着那盆七心海棠，跟在后面。 </p><p>​    两人稍加休息，又到大厅，你看我，我看你，见对方身上衣履都焕然一新。程灵素低声笑道：“胡大哥，过新年吗？打扮得这么齐整。”胡斐见她脸上薄施脂粉，清秀之中微增娇艳之色，竟似越看越美，浑不似初会时那么肌肤黄瘦，黯无光采，笑道：“你可真像新娘子一般呢。”程灵素脸上一红，转过了头不理。胡斐暗悔失言，但偷眼相瞧，她脸上却不见有何怒色，目光中只露出又顽皮、又羞怯的光芒。 </p><p>胡斐翻阅一遍，大是迷惘，将簿子交给程灵素，道：“你看。”程灵素看了，也猜不透是什么用意，笑道：“胡大员外，恭喜发财！” </p><p>只见程灵素稍施脂粉，容貌虽不算美，却也颇觉俏丽，突然心中一动：“倘若我娶了她为妻，在这里过些太平日子，那是一生中从未享过的福气。袁姑娘虽比她可爱得多，但她不断跟我作对，显是凤天南这大恶霸的一党。况且第一，她未必肯嫁我。第二，就算嫁了我，整天打打杀杀、吵吵闹闹，而程姑娘却对我那么好，在一起有趣得多。只不过这里的主人结交官府，显非良善之辈，我胡斐难道贪图财富安逸，竟与这等人同流合污，狼狈为奸？” </p><p>​    程灵素道：“咱们白吃白喝，白住白宿，半点也没损了什么。这么说来，那主人似乎并没安着歹心。”胡斐道：“我总觉这件事阴阳怪气，很有点儿邪门。”程灵素笑道：“我倒盼这种邪门事儿多遇上些，一路上阴阳怪气个不停。喂，胡大爷，你到底是去那里啊？”胡斐道：“我要上北京。你也同去玩玩，好不好？”程灵素笑道：“好是没什么不好，就只怕有些儿不便。”胡斐奇道：“什么不便？”程灵素笑道：“胡大爷去探访那位赠玉凤的姑娘，还得随身带个使唤丫鬟么？” </p><p>程灵素问道：“这位袁姑娘是个美人儿，是不是？”胡斐微微一怔，脸都红了，说道：“算是很美吧。”程灵素道：“比我这丑丫头好看得多，是不是？”<br>    胡斐没防到她竟会如此单刀直入的询问，不由得颇是尴尬，道：“谁说你是丑丫头了？袁姑娘比你大了几岁，自然生得高大些。”程灵素一笑，说道：“我八岁的时候，拿妈妈的镜子来玩。我姊姊说：‘丑八怪，不用照啦！照来照去还是个丑八怪。’哼！我也不理她，你猜后来怎样？”<br>    胡斐心中一寒，暗想：“你可别把姊姊毒死了。”说道：“我不知道。” </p><p>程灵素听他语音微颤，脸有异色，猜中了他心思，道：“你怕我毒死姊姊吗？那时我还只八岁呢。嗯，不过第二天，家里的镜子通统不见啦。”胡斐道：“这倒奇了。”<br>    程灵素道：“一点也不奇，都给我丢到了井里。”顿了一顿，说道：“但我丢完了镜子，随即就明白了。生来是个丑丫头，就算没了镜子，还是丑的。那井里的水面，便是一面圆圆的镜子，把我的模样给照得清清楚楚。那时候啊，我真想跳到井里去死了。”说到这里，突然举起鞭子狂抽马臀，向前急奔。 </p><p>胡斐纵马跟随，两人一口气驰出十馀里路，程灵素才勒住马头。胡斐见她眼圈红红的，显是适才哭过来着，不敢朝她多看，心想：“你虽没袁姑娘美貌，但决不是丑丫头。何况一个人品德第一，才智方是第二，相貌好不好乃是天生，何必因而伤心？你事事聪明，怎么对此便这地看不开？”瞧着她瘦削的侧影，心中大起怜意，说道：“我有一事相求，不知你肯不肯答允，不知我是否高攀得上？” </p><p>程灵素身子一震，颤声道：“你……你说什么？”胡斐从她侧后望去，见她耳根子和半边脸颊全都红了，说道：“你我都没父母亲人，我想跟你结拜为兄妹，你说好么？”<br>    程灵素的脸颊刹时间变为苍白，大声笑道：“好啊，那有什么不好？我有这么一位兄长，当真是求之不得呢！” </p><p>胡斐听她语气中含有讥讽之意，不禁颇为狼狈，说道：“我是一片真心。”程灵素道：“我难道是假意？”说着跳下马来，在路旁撮土为香，双膝一曲，便跪在地上。胡斐见她如此爽快，也跪在地上，向天拜了几拜。两人相对磕头行礼。程灵素道：“人人都说八拜之交，咱们得磕足八个头……一、二、三、四、……七、八……嗯，我做妹妹，多磕两个。”果然多磕了两个头，这才站起。 </p><p>​    胡斐见她言语行动之中，突然微带狂态，自己也有些不自然起来，说道：“从今而后，我叫你二妹了。”程灵素道：“对，你是大哥。咱们怎么不立下盟誓，说什么有福共享、有难同当？”胡斐道：“结义贵在心盟，说不说都是一样。”程灵素道：“啊，原来如此。”说着跃上了马背，这日直到黄昏，始终没再跟胡斐说话。 </p><p>程灵素道：“你认不认他们？”胡斐道：“待明儿上了道，到荒僻无人之处，这才上前相认。”程灵素笑道：“荒僻无人之处？啊，那可了不得！他们不当你这小胡子是劫镖的强人才怪。”胡斐一笑，道：“这枝镖不值得胡大寨主动手。程二寨主，你瞧如何？”程灵素笑道：“瞧那镖头身上无钱，什是寒伧。你我兄弟盗亦有道，不免拍马上前，送他几锭金子便了。”胡斐哈哈一笑。他确有赠金之心，只是要盘算个妥善法儿，赠金之时须得不失了敬意，才不损人家面子。 </p><p>胡斐心想：“这人所说的人数，和我所猜的一点不错，总算没骗我。管他强援是谁，我岂能舍马姑娘而去？二妹却不能平白无端的在此送了命。”低声道：“二妹，你先骑这马突围出去，我一人照料马姑娘，那便容易得多。”<br>    程灵素知他顾念自己，说道：“咱们结拜之时，说的是‘有难共当’呢，还是‘有难先逃’？”胡斐道：“你和马姑娘从不相识，何必为她犯险？至于我，那可不同。”<br>    程灵素的眼光始终没望他一眼，道：“不错，我何必为她犯险？可是我和你，难道也是从不相识么？” </p><p>胡斐心中大是感激，自忖一生之中，甘愿和自己同死的，平四叔是会的，赵半山也会的，（奇怪得很，一瞬之间，心中忽地掠过一个古怪的念头：苗人凤也会的），今日又有一位年轻姑娘安安静静的站在自己身旁，一点也不踌躇，只是这么说：“活着，咱们一起活，要死，便一起死！” </p><p>程灵素微微一笑，低声问道：“大哥，待会如果走不脱，你救我呢，还是救马姑娘？”胡斐道：“两个都救。”程灵素道：“我是问你，倘若只能救出一个，另一个非死不可，你便救谁？”胡斐微一沉吟，说道：“我救马姑娘！我跟你同死。”<br>    程灵素转过头来，满脸深情，低低叫了声：“大哥！”伸手握住了他手。胡斐心中一震，忽听得屋外脚步声响，往窗孔中一望，叫道：“啊哟，不好！” </p><p>胡斐皱眉道：“这姓商的挺狡猾……”程灵素道：“你要不要出手？”胡斐道：“我是为助马姑娘而来，但是……但是……我可真不知她心意到底怎样？”程灵素对马春花什为不满，说道：“马姑娘决没危险，你好心相助，她未必领你这个情。咱们不如走吧！”胡斐见徐铮的单刀给商宝震掌力逼住了，砍出去时东倒西歪，已全然不成章法，瞧着什是凄惨，说道：“二妹，你说的是，这件事咱们管不了。” </p><pre><code class="hljs">胡斐弯下腰去，俯身在徐铮耳边，低声道：“徐大哥，你有什么未了之事，兄弟给你办去。”徐铮望望妻子，望望商宝震，苦笑了一下，低声道：“没有。”胡斐道：“我去找到你的两个孩子，抚养他们成人。”他和徐铮全没交情，只眼见他落得这般下场，激于义愤，忍不住挺身而出。 徐铮又苦笑了一下，低声说了一句话，气息太微，胡斐听不明白，把右耳凑到他口边，只听他道：“孩子……孩子……嫁过来之前……早……早就有了……不是我的……”一口气呼出，不再吸进，便此气绝。 </code></pre><h3 id="第14章-北京众武官"><a href="#第14章-北京众武官" class="headerlink" title="第14章 北京众武官"></a>第14章 北京众武官</h3><p>胡斐脸色一沉，道：“那么他打死徐铮徐大哥，是出于福大帅的授意？”<br>    秦耐之忙道：“那倒不是，福大帅贵人事忙，怎知马姑娘已跟那姓徐的成婚？他只是心血来潮，想起了旧情，派几个当差的南来打探一下消息。此刻已有两个兄弟飞马赴京赶报喜讯，福大帅得知他竟有两位公子，这番高兴自不用说了。”<br>    这么一说，胡斐心头许多疑团，一时尽解。只觉此事怨不得马春花，也怨不得福康安，商宝震杀徐铮固然不该，可是他已一命相偿，也已无话可说，只是徐铮一生忠厚老实，明知二子非己亲生，始终隐忍，到最后落得如此下场，深为恻然，长长叹了口气，说道：“秦大哥，此事已分剖明白，原是小弟多管闲事。”轻轻一纵，落在地下。 </p><p>​    胡斐次晨转醒，见自己背上披了一件长袍，想是程灵素在晚间所盖。她站在窗口，秀发为晨风一吹，微微飞扬。胡斐望着她苗条背影，心中混和着感激和怜惜之意，叫了声：“二妹！”程灵素“嗯”的一声，转过身来。<br>​    胡斐见她睡眼惺忪，大有倦色，道：“你一晚没睡吗？啊，我忘了跟你说，有马姑娘在此，他们不敢对咱们怎样。”程灵素道：“马姑娘半夜里悄悄出屋，至今未回。她出去时轻手轻脚，怕惊醒了你，我也就假装睡着。”胡斐微微一惊，转过身来，果见马春花所坐之处只剩下一张空櫈。 </p><p>再走出数丈，见林中堆着两座新坟，坟前并无标志，也不知那一座是徐铮的，那一座是商宝震的。胡斐心想：“虽一个是丈夫，一个是杀丈夫的仇人，但在马姑娘心中，恐怕两人也无多大差别，都是爱着她而她并不爱的人，都是为了她而送命的不幸之人。”想到此处，不由得喟然长叹，于是将秦耐之的说话向程灵素转述了。 </p><p>​    程灵素道：“马姑娘心中喜欢福公子，徐铮就是活着，也只徒增苦恼。他小小一个倒霉的镖师，怎能跟人家兵部尚书、统兵大元帅相争？”胡斐道：“不错，倒还是死了乾净。”在两座坟前拜了几拜，说道：“徐大哥、商公子，你们生前不论和我有恩有怨，死后一笔勾销。马姑娘从此富贵不尽，你们两位死而有知，也不用再记着她了。”<br>​    二人牵了马匹，缓步出林。程灵素道：“大哥，咱们上那儿去？”胡斐道：“先找到客店，让你安睡半日，再说别的，可别累坏了我的好妹子！”程灵素听他说“我的好妹子”，心中说不出的欢喜，转头向他甜甜一笑。 </p><p>程灵素道：“你去跟这福大帅捣捣蛋，不也好吗？我瞧还有一个人是必定要去的。”胡斐道：“谁啊？”程灵素微笑道：“这叫作明知故问了。你还是给我爽爽快快的说出来的好。”<br>    胡斐早已明白她心意，也不再假装，说道：“她也未必一定去。”顿了一顿，又道：“这位袁姑娘是友是敌，我还弄不明白呢。”程灵素道：“如果每个敌人都送我一只玉凤儿，我倒盼望遍天下都是敌人才好……”忽听得窗外一个女子声音说道：“好，我也送你一只！”声音甫毕，嗤的一响，一物射穿窗纸，向程灵素飞来。胡斐拿起桌上程灵素裁衣的竹尺，向那物一敲，击落在桌，左掌挥出，烛火应风而灭。接着听得窗外那人说道：“挑灯夜谈，美得紧哪！”<br>    胡斐听话声依稀便是袁紫衣的口音，胸口一热，冲口而出：“是袁姑娘么？”却听步声细碎，顷刻间已然远去。 </p><p>胡斐打开绢包，不由得呆了，原来包里又是一只玉凤，竟和先前留赠自己的一模一样，心中立想：“难道我那只竟失落了，还是给她盗了去？”伸手到怀中一摸，触手生温，那玉凤好端端的便在怀中，取出来一看，两只玉凤果然雕琢得全然相同，只是一只凤头向左，一只向右，显是一对儿。<br>    绢包中另有一张小小白纸，纸上写道：“马归正主，凤赠侠女。”胡斐又是一呆：“这马又不是我的，怎说得上‘马归正主’？难道要我转还给赵三哥么？”将简帖和玉凤递给程灵素道：“袁姑娘也送了一只玉凤给你。”<br>    程灵素一看简帖上的八字，说道：“我又是什么侠女了？不是给我的。”胡斐道：“包上不明明写着‘程姑娘’？她昨晚又说：‘好，我也送你一只！’”程灵素淡然道：“既是如此，我便收下了。这位袁姑娘如此厚爱，我可无以为报了。” </p><p>但是，北京终于到了，胡斐和程灵素并骑进了都门。<br>    进城门时胡斐向程灵素望了一眼，隐隐约约间似乎看到一滴泪珠落在地下尘土之中，只是她将头偏着，没能见到她容色。<br>    胡斐心头一震：“这次到北京来，可来对了吗？”<br>    其时正当乾隆中叶，升平盛世。京都积储殷富，天下精华，尽汇于斯。 </p><p>胡斐生性极爱结交朋友，对做官的虽无好感，但见这一干人对自己什为尊重，而他本来又喜赌钱，笑道：“还是秦大哥推庄，小弟来下注碰碰运气。聂大哥，你先收着，待会输乾了再问你借。”将银子推还给那姓聂武官。转头问程灵素道：“二妹，你赌不赌？”程灵素抿嘴笑道：“我不会，我帮你捧银子。” </p><p>​    程灵素待他走远，道：“大哥，这座大宅子只怕值二万两银子也不止。这件事大不寻常。”胡斐点头道：“不错，你瞧这中间有什么蹊跷？”程灵素微笑道：“我想总是有个人在暗暗喜欢你，因此故意接二连三，一份一份的送你大礼。”<br>​    胡斐知她在说袁紫衣，脸上一红，摇了摇头。程灵素笑道：“我是跟你说笑呢。我大哥慷慨豪侠，也不会把这些田地房产放在心上。这送礼之人，决不是你的知己，否则的话，还不如送一只玉凤凰。这送礼的若非怕你，便是想笼络你。嗯，谁能有这么大手笔啊？”胡斐凛然道：“是福大帅？” </p><p>程灵素目澄如水，脉脉的望着胡斐，心想这些英雄事迹，你一路上从来不说。 </p><h3 id="第15章-紫罗衫动红烛移"><a href="#第15章-紫罗衫动红烛移" class="headerlink" title="第15章 紫罗衫动红烛移"></a>第15章 紫罗衫动红烛移</h3><p>袁紫衣的匕首翻飞击刺，招招不离胡斐要害，出手狠辣凌厉，直如性命相搏一般。<br>    胡斐那敢怠慢，凝神接战，耳听得凤天南纵声长笑，叫道：“胡家小兄弟，老哥哥失陪了，咱们后会有期。”笑声愈去愈远，黑夜中遥遥听来，便似枭鸣。 </p><p>胡斐快步走到亭中，拿起茶杯喝了一口，低声道：“此人厉害，不可轻敌。”袁紫衣眼皮低垂，细声道：“我多次坏你大事，你不怪我么？”这一句话胡斐却答不上来，说是不怪，可是她接连三次将凤天南从自己手底下救出；说是怪她罢，瞧着她若有情、若无情的眼波，却又怎能怪得？ </p><p>袁紫衣见胡斐走入亭来教自己提防，芳心大慰，她本来心下担忧，生怕斗不过这八卦门高手，这时精神一振，低声道：“我心里好对你不起！我如不行，请你帮我照看着。”依她原来好胜的性子，这句话明显服软，无论如何是不肯说的，但今晚又坏了他的大事，心下什歉，说这句话，是有意跟他说和修好。 </p><p>袁紫衣继续说道：“可是一路之上，我偷你的包袱，跟你打打闹闹，将你推入河里，全无赔罪之意，只因赵半山把你说得太好，夸上了天去，说当今十几岁的少年人中，没一个及得上你。我也是十几岁的人，心里可不服气了。你武功是强的，为人仁义，果然了不起，可是……可是……”胡斐接口道：“可是这小胡斐做事顾前不顾后，脑筋太过胡涂。两个小流氓三言两语，就把他引开了。锺家三口人，还不是死在他胡涂之下？他一心要做好事，却帮助坏人送信去给苗人凤苗大侠，弄瞎了他一双眼睛。福公子派人来接他的老相好、私生子，他却又没来由的打什么抱不平。人家摆个圈套要为凤天南说合，他想也不想，一头就钻了进去。这小胡斐是个鲁莽匹夫，就论武功，也胜不了一个十几岁的小姑娘。那晚在湘妃庙中，那小姑娘如当真要杀了他，还不是早已要了他性命？” </p><p>​    胡斐万万料想不到，这个一直跟自己作对为难的姑娘，竟会当面称赞自己，不由得满脸通红，大为发窘，心中却什感甜美舒畅。从广东直到北京，风尘行旅，间关千里，他心间意下，无日不有袁紫衣的影子在，只是每想到这位美丽动人、却又刁钻古怪的姑娘，七分欢喜之中，不免带着两分困惑，一分着恼。今夜一夕长谈，嫌隙尽去，原来中间竟有这许多原委，怎不令他在三分酒醉之中，再加上了三分心醉？ </p><p>袁紫衣道：“程家妹子，你在那单刀之上，干么不下致命毒药？”程灵素目中含泪，愤然道：“我虽是毒手药王的弟子，但生平从没杀过一个人。难道我就能随随便便的害你么？何况……何况你是他的心上人，从湖南到北京，千里迢迢，他整天除了吃饭睡觉，念念不忘，便是在想着你。我怎会当真害你？”说到这里，泪珠儿终于夺眶而出。<br>    袁紫衣一愕，站起身来，飞快的向胡斐掠了一眼，只见他脸上显得什是忸怩尴尬。<br>    程灵素这一番话，突然吐露了胡斐的心事，实大出他意料之外，不免什是狼狈，但目光之中，却满含款款柔情。<br>    袁紫衣上排牙齿一咬下唇，说道：“我是个苦命人，世上的好事，全跟我无缘。我有时情不自禁，羡慕人家的好事，可是老天注定了的，我一生下来便命苦，比不上别人！人家对我的好意，我只好心里感激，却难以报答，否则师父不容、菩萨不容、上天不容……胡大哥，我自己作不了主，请你原谅……”说到这里，声音哽咽了，泪水扑簌簌的掉在胸前，蓦地里纤手一扬，噗的一声，搧灭了烛火，穿窗而出，登高越房而去。<br>    胡斐和程灵素都是一惊，忙奔到窗边，但见宿雨初晴，银光泻地，早不见了袁紫衣的人影，回过头来，月光下只见桌上兀自留着她的点点泪水。</p><h3 id="第16章-华拳四十八"><a href="#第16章-华拳四十八" class="headerlink" title="第16章 华拳四十八"></a>第16章 华拳四十八</h3><p>提着他走到假山之后，低声喝问：“福康安何以要拿我？”那武官道：“实……实在不知。”胡斐道：“这时他在那里？”那武官道：“福大帅……福大帅从马姑娘的阁子中出来，嘱咐了我们，又……又回进去了。”胡斐伸手点了他哑穴，说道：“命便饶你，明日有人问起，你须说这姓聂的也是我杀的。你如走漏消息，他家小有什风吹草动，我将你全家杀得乾乾净净，老小不留。”那武官说不出话，不住点头。胡斐顺手一拳，将他打得昏晕过去</p><p>​    程灵素“嗯”了一声，微笑道：“人家是九家半总掌门，难道你便连一家也当不上？”她这句话一出口，立即好生后悔：“为什么总念念不忘的想着袁姑娘，又不断提醒大哥，叫他也念念不忘？”见胡斐昂然走出假山，瞧着他的背影，又想：“我便不提醒，他难道便有一刻忘了？”见他大踏步走向戏台，不禁又甜蜜，又心酸。 </p><p>。<br>    胡斐向台上那人一抱拳，说道：“天字派弟子程灵胡，请师兄指教。”<br>    程灵素在假山背后听得清楚，听他自称“程灵胡”，不禁微笑，心中随即一酸：“倘若他当真是我的亲兄长，倒免却了不少烦恼。” </p><p>。<br>    忽听得一个声音在耳边柔声道：“大哥，你作什么梦了？”胡斐跃起身来，揉了揉眼睛，微一凝神，说道：“我来照料马姑娘，该当由你睡一忽儿了。”程灵素道：“先给你装上胡子，这才放心。”拿起浆硬了的一条条头发，用胶水给他黏在颏下和腮边。这一番功夫好不费时，黏了将近一个时辰，眼见红日当窗，方才黏完。<br>    胡斐揽镜一照，不由得哑然失笑，只见自己脸上一部络腮胡子，虬髯戟张，不但面目全非，且大增威武。胡斐很是高兴，笑道：“二妹，我这模样儿挺美啊，日后我真的便留上这么一部大胡子。”<br>    程灵素想说：“只怕你心上人未必应许。”话到口边，终于忍住。她忙了一晚，到这时心力交困，眼见马春花睡得安稳，再也支持不住，伏在桌上便睡着了。<br>    十年之后，胡斐念着此日之情，果真留了一部络腮大胡子，那自不是程灵素这时所能料到了。 </p><h3 id="第17章-龙潭虎穴"><a href="#第17章-龙潭虎穴" class="headerlink" title="第17章 龙潭虎穴"></a>第17章 龙潭虎穴</h3><p>​    汪铁鹗颤声道：“我是戍正当值，天稍黑便该去了。”胡斐道：“你给张九告个假，说他生了病，不能当差。我在这儿等你，快天黑时你来接我。”汪铁鹗呆了半晌，心想只要这一句话儿答允下来，一生便变了模样，要做个铁铮铮的汉子，什么荣华富贵，就一笔勾销；但若一心一意为福大帅出力，不免是非不分，于心不安。 </p><p>胡斐听了那身材瘦削的汉子那声呼喝，又见了这一跃的身法，已知是程灵素前来接应，喜道：“二妹，原来是你！”程灵素“哼”的一声，并不答话。胡斐又问：“马姑娘怎样？病势没转吧？”程灵素道：“不知道。”胡斐知她生气了，柔声道：“二妹，我没听你话，是我的不是，请你原谅这一次。”程灵素道：“我说过不治病，便不治。难道我说的不是人话么？” </p><p>​    胡斐又道：“二妹，你这条计策真再妙不过，倘若不是雇用深夜倒粪的粪车，寻常大车一辆辆停在街心，给巡夜官兵瞧见了，定会起疑。”程灵素冷笑道：“起疑又怎么样？反正你不爱惜自己，便死在官兵手中，也是活该。”胡斐笑道：“我死是活该，只是累得姑娘伤心，那便过意不去。”程灵素冷笑道：“你不听我话，自己爱送命，才没人为你伤心呢。除非是你那个多情多义的袁姑娘……她又怎么不来助你一臂之力？”<br>​    胡斐道：“她只有不断跟我为难，几时帮过我？天下只一位姑娘，才知我会这般蛮干胡来，也只有她，才能在紧急关头救我性命。”这几句话说得程灵素心中舒服慰贴无比，哼了一声，道：“当年救你性命的是马姑娘，因此你这般念念不忘，要报她大恩。”胡斐道：“在我心中，马姑娘又怎能跟我的二妹相比？”<br>​    程灵素在黑暗中微微一笑，道：“你求我救治马姑娘，什么好听的话都会说。待得不求人家了，便又把我的说话当作耳边风。”胡斐道：“倘若我说的是假话，教我不得好死。”程灵素道：“真便真，假便假，谁要你赌咒发誓了？”她这句话口气松动不少，显是胸中的气恼已消了大半。 </p><p>程灵素嫣然一笑，道：“咱们第一天见面，你便没听我吩咐。我叫你不可离我身边，叫你不可出手，你听话了么？”胡斐道：“我以后定要多听你话。”程灵素幽幽的道：“还有以后吗？”胡斐一本正经的道：“有，有！自然有！”程灵素一笑，笑容中颇含苦涩，心中却也欢喜。 </p><h3 id="第18章-天下掌门人大会"><a href="#第18章-天下掌门人大会" class="headerlink" title="第18章 天下掌门人大会"></a>第18章 天下掌门人大会</h3><p>​    胡斐听得邻桌上的一个老者说道：“武林之中，有的是门派抬高了人，有的是人抬高了门派。那位青什么道长，只因是武当山太和宫的观主，便算是天下四大掌门人之一，我看未必便有什么真才实学吧？至于‘三才剑’一门呢，若不是出了汤大侠这样一位百世难逢的人物，在武林中又能占到什么席位呢？”一个壮汉接口道：“师叔说得是。”胡斐听了也暗暗点头。 </p><p>仆役送菜上来，福大帅府宴客，端的非比寻常，单是那一坛坛二十年的状元红陈绍，便是极难尝到的美酒。胡斐酒到杯乾，一口气喝了二十馀杯。程灵素见他酒兴什豪，只抿嘴微笑，自己在烟袋中抽一两口旱烟，偶尔回头，便望凤天南一眼，生怕他走得没了影踪。 </p><p>胡斐心道：“福康安治军严整，确非平庸之辈。无怪他数次出征，每一次都打胜仗。”但见他满脸春风，神色什喜，又想：“这人全无心肝，害死了心上人，两个儿子给人抢了去，竟漫不在乎。”随即转念：“这人当真厉害之极，家里出了这等大事，脸上却半点不露。” </p><p>​    许多有见识的掌门人均想：“这那里是少了许多纷争？各门各派一分等级次第，武林中立时便惹出无穷祸患。这二十四只御杯势必你争我夺。天下武人从此为名位而争斗，自相残杀，刀光血影，再也没宁日了。” </p><p>福康安又道：“得了这二十四只御杯的，自然须得好好的看管着。倘若给别门别派抢了去、偷了去，那玉龙八门、金凤八门、银鲤八门，跟今日会中所定，却又不同了哇！”这番话说得又明白了一层，却仍有不少武人附和哄笑。 </p><h3 id="第19章-宝刀银针"><a href="#第19章-宝刀银针" class="headerlink" title="第19章 宝刀银针"></a>第19章 宝刀银针</h3><p>​    他明知在此处多耽得一刻，便多增一分凶险，但一来心中存着这许多疑团未解；二来眼见凤天南便在身旁，好容易知道了他的下落，岂能又让他走了？三来也要瞧一瞧馀下的三只玉龙杯由那派的掌门人所得。<br>​    其实，这些都只是他心里所计较的原因，真正的原因，却是在心中隐隐约约觉得的：袁紫衣一定会来。既知她要来，他就决计不走。便有天大危险，也吓他不走。 </p><h3 id="第20章-相见欢"><a href="#第20章-相见欢" class="headerlink" title="第20章 相见欢"></a>第20章 相见欢</h3><p>他自从蓦地里见到那念念不忘的俊俏姑娘竟是个尼姑，便即神魂不定，始终无法静下来思索，脑海中诸般念头此去彼来，犹似乱潮怒涌，连背上的伤痛也忘记了。 </p><p>​    圆性却蒙峨嵋派中一位辈份什高的尼姑救去，带到天山，自幼便给她落发，授以武艺。那位尼姑的住处和天池怪侠袁士霄及红花会群雄相去不远，平日切磋武学，时相过从。圆性天资极佳，她师父的武功原已极为高深繁复，但她贪多不厌，每次见到袁士霄，总缠着他要传授几招，而从陈家洛、霍青桐直至心砚，红花会群雄无人不是多多少少的传过她一些功夫。天池怪侠袁士霄老来寂寞，对她传授尤多。袁士霄于天下武学，几乎说得上无所不知，何况再加上十几位明师，是以圆性艺兼各派之所长，她人又聪明机警，以智巧补功力不足，若不是年纪太轻，内功修为尚浅，直已可跻一流高手之境。<br>​    这一年圆性禀明师父，回中土为母报仇，鸳鸯刀骆冰便托她带来白马，遇到胡斐时赠送于他。只赵半山将胡斐夸得太好，圆性少年性情，心下不服，这才有途中和胡斐数度较量之事。不料两人见面后惺惺相惜，心中情苗暗茁。圆性待得惊觉，已柔肠百转，难以自遣了。她自行制约，不敢多和胡斐见面，只暗中跟随。后来见他结识了程灵素，她既自伤，亦复宽慰，自己是方外之人，终身注定以青灯古佛为伴，她自幼蒙师父教养长大，十六岁上曾立下重誓，要作师父的衣钵传人，师恩深重，决计不敢有背。程灵素聪明智慧，犹胜于己，对胡斐更一往情深，胡斐得以为侣，原亦大佳。因此上留赠玉凤，微通消息，但暗地里却已不知偷弹了多少珠泪，自伤身世，伤痛不禁……她此番东来报仇，大仇人是甘霖惠七省汤沛，心想若暗中行刺下毒，原亦不难，但此人一生假仁假义，沽名钓誉，须得在天下好汉之前揭破他的假面具，那比将他一剑穿心更加痛快。 </p><p>​    眼见再奔得几步，凤天南便可逃出福府，圆性遥遥望见，急叫：“胡大哥……这恶人要逃走了！快杀了他！” </p><p>须知“儒以文乱法，侠以武犯禁”，历来人主大臣，若不能网罗文武才士以为己用，便欲加之斧钺而诛灭，以免为患民间，扇动天下，自来便是如此。这时听到石万嗔大叫：“有人在茶酒之中下了毒药。”个个心惊肉跳，至于福康安自己和众卫士其实也肚中疼痛，旁人自然不知。 </p><p>胡斐瞧了马春花的情状，便程灵素不说，也知已命在顷刻，想起商家堡中昔日之情，不禁怔怔的掉下泪来。他自在福康安府中见到袁紫衣成了尼姑圆性，心中一直郁郁，此刻眼泪一流，触动心事，再也忍耐不住，呜呜咽咽的哭了起来。 </p><p>程灵素和圆性如何不明白他因何伤心？程灵素道：“我再去瞧瞧马姑娘。”缓步走进厢房。圆性给他这么一哭，眼圈也早红了，强自忍住便欲夺眶而出的眼泪，颤声道：“胡大哥，多谢你待我的一片……一片……”说到这里，泪水再也难忍。<br>    胡斐泪眼模糊的抬起头来，道：“你……你难道不能……不能还俗吗？待杀了那姓汤的，报了父母大仇，求求你，不要再做尼姑了。” </p><p>胡斐追了出去，颤声问道：“你……你去那里？”圆性道：“你何必管我？此后便如一年之前，你不知世上有我，我不知世上有你，岂不乾净？”胡斐道：“我不要乾净！我只要跟你在一起！”话声什是固执。圆性柔声道：“我们命里没这福气……”话没说完，拂袖出门。 </p><p>胡斐本来生性谨细，绝非莽撞之徒，只是他究属少年，血气方刚，眼看马春花为福康安害得这等惨法，激动了侠义之心，一切全豁了出去，什么也不理会了。<br>    也说不定由于他念念不忘的美丽姑娘忽然之间变成了个尼姑，令他觉得世情惨酷，人生悲苦，要大闹便大闹一场，最多也不过杀头丧命，又有什么大不了？ </p><p>蓦地里听得一人长声吟道：“浩浩愁，茫茫劫。短歌终，明月缺。郁郁佳城，中有碧血。碧亦有时尽，血亦有时灭，一缕香魂无断绝。是耶？非耶？化为蝴蝶。” </p><p>陈家洛道：“我明白啦！你要我假冒那个伤天害理、负心薄幸的福康安，去安慰一下这位多情多义的马姑娘？”胡斐低声道：“正是！”群雄均觉胡斐这个荒唐的念头果然异想天开之至，可是谁也笑不出来。<br>    陈家洛眼望远处，黯然出神，说道：“墓中这位姑娘临死之际，如能见我一面，那是多么的快活！可惜终难如愿……”转头向胡斐道：“好，我便去见见这位马姑娘。” </p><p>两个孩子扑向榻上，大叫：“妈妈，妈妈！”马春花睁开眼来，见是爱子，陡然间精神一振，也不知那里来的力气，将两个孩子紧紧搂在怀里，叫道：“孩子，孩子，妈想得你们好苦！”三个人相拥良久，她转眼见到胡斐，对两个孩子道：“以后你们跟着胡叔叔，好好听他的说话……你们……拜了他作义……义……”<br>    胡斐知她心意，说道：“好，我收了他们作义儿，马姑娘，你放心吧！”马春花脸露微笑，道：“快……快磕头，我好……好放心……”两个孩子跪在胡斐面前，磕下头去。<br>    胡斐让他们磕了四个头，伸手抱起两人，低声道：“马姑娘，你还有什么吩咐么？”马春花道：“我死了之后，求你……求你将我葬……葬在我丈夫徐……师哥的坟旁……他很可怜……从小便喜欢我……可是我不喜欢……不喜欢他。” </p><p>​    过了好一会儿，陈家洛从庙门里慢慢踱了出来。他向胡斐点了点头。胡斐知道马春花离开这世界了。她临死之前见到了心爱的两个儿子，也见到了“情郎”。胡斐不知道她跟陈家洛说了些什么，是责备他的无情薄幸呢，还是诉说自己终生不渝的热情？除了陈家洛之外，这世上是谁也不知道了。 </p><h3 id="第21章-恨无常"><a href="#第21章-恨无常" class="headerlink" title="第21章 恨无常"></a>第21章 恨无常</h3><p>​    程灵素吸一口毒血，便吐在地下，若是寻常毒药，她可以用手指按捺，从空心金针中吸出毒质，便如替苗人凤治眼一般，但碧蚕毒蛊、鹤顶红、孔雀胆三大剧毒入体，又岂是此法所能奏效？她直吸了四十多口，眼见吸出来的血液已全呈鲜红之色，这才放心，吁了一口长气，柔声道：“大哥，你和我都很可怜。你心里喜欢袁姑娘，那知道她却出家做了尼姑……我……我心里……”她慢慢站起身来，柔情无限的瞧着胡斐，从药囊中取出两种药粉，替他敷在手背，又取出一粒黄色药丸，塞在他口中，低低的道：“我师父说中了这三种剧毒，无药可治，因为他只道世上没一个医生，肯不要自己的性命来救活病人。大哥，他决计想不到我……我会待你这样……” </p><p>胡斐只想张口大叫：“我不要你这样，不要你这样！”但除了眼光中流露出反对的神色之外，委实无法示意。<br>    程灵素打开包裹，取出圆性送给她的那只玉凤，凄然瞧了一会，用一块手帕包了，放入胡斐怀里。再取出一枝蜡烛，插在神像前的烛台上，一转念间，从包中另取一枝烛身较细的蜡烛，拗去半截，晃火摺点燃了，放在后院天井中，让蜡烛烧了一会，再取回来放在烛台旁，另取一枝新烛插上烛台。她又从怀里取出一颗黄色药丸，喂在胡斐嘴里。<br>    胡斐瞧着她这般细心布置，不知是何用意，只听她道：“大哥，有一件事我本来不想跟你说，以免惹起你伤心。现下咱们要分手了，不得不说。在掌门人大会之中，我那狠毒的师叔和田归农相遇之时，你可瞧出蹊跷来么？他二人是早就相识的。田归农用来毒瞎苗大侠眼睛的断肠草，定是石万嗔给的。你爹爹所以中毒，刀上毒药多半也是石万嗔配制的。”胡斐登时心中雪亮，只想大叫：“不错！”<br>    程灵素道：“你爹爹妈妈去世之时，我尚未出生，我那几个师兄、师姊，也年纪尚小，未曾投师学艺。那时候当世擅于用毒之人，只先师和石万嗔二人。苗大侠疑心毒药是我师父给的，因之跟他失和动手，我师父既然说不是，当然不是了。我虽疑心这个师叔，可是并无佐证，本来想慢慢查明白了，如果是他，再设法为你报仇。今日事已如此，不管怎样，总之是要杀了他……”说到这里，体内毒性发作，身子摇晃了几下，摔在胡斐身边。<br>    胡斐见她慢慢合上眼睛，口角边流出一条血丝，真如是万把钢锥在心中攒刺一般，只想紧紧抱住她，张口大叫：“二妹，二妹！”但便如深夜梦魇，不论如何大呼大号，总是喊不出半点声息，心里虽然明白，却连一根小指头儿也转动不得。 </p><p>胡斐身旁躺着三具尸首，一个是他义结金兰的小妹子程灵素，两个是他义妹的对头、背叛师门的师兄师姐。破庙中一枝黯淡的蜡烛，随风摇曳，忽明忽暗，他身上说不出的寒冷，心中说不出的凄凉。 </p><p>终于蜡烛点到了尽头，忽地一亮，火焰吐红，一声轻响，破庙中漆黑一团。<br>    胡斐心想：“我二妹便如这蜡烛一样，点到了尽头，再也不能发出光亮了。她一切全算到了，料得石万嗔他们一定还要再来，料到他小心谨慎不敢点新蜡烛，便将那枚混有七心海棠花粉的蜡烛先行拗去半截，诱他上钩。她早死了，在死后还是杀了两个仇人。她一生没害过一个人的性命，她虽是毒手药王的弟子，生平却从未杀过人。她是在自己死了之后，再来清理师父门户，再来杀死这两个狼心狗肺的师兄师姊。” </p><p>“她没跟我说自己的身世，我不知她父亲母亲是怎样的人，不知她为什么要跟无嗔大师学这一身可惊可怖的本事。我常向她说我自己的事，她总是关切的听着。我多想听她说说她自己的事，可是从今以后，再也听不到了。”<br>    “二妹总是处处想到我，处处为我打算。我有什么好，值得她对我这样？值得她用自己的性命，来换我的性命？其实，她根本不必这样，只须割了我的手臂，用他师父的丹药，让我在这世界上再活九年。九年的时光，那已足够了！我们一起快快乐乐的渡过九年，就算她要陪着我死，那时候再死不好么？” </p><p>忽然想起：“我说‘快快乐乐’，这九年之中，我是不是真的会快快乐乐？二妹知道我一直喜欢袁姑娘，虽然发觉她是个尼姑，但思念之情，并不稍减。那么她今日宁可一死，是不是为此呢？” </p><p>在那无边无际的黑暗之中，心中思潮起伏，想起了许许多多事情。程灵素的一言一语，一颦一笑，当时漫不在意，此刻追忆起来，其中所含的柔情密意，才清清楚楚的显现出来。<br>    小妹子对情郎——恩情深，<br>    你莫负了妹子——一段情，<br>    你见了她面时——要待她好，<br>    你不见她面时——天天要十七八遍挂在心！<br>    王铁匠那首情歌，似乎又在耳边缠绕，“我要待她好，可是……可是……她已经死了。她活着的时候，我没待她好，我天天十七八遍挂在心上的，是另一个姑娘。” </p><p>天渐渐亮了，阳光从窗中射进来照在身上，胡斐却只感到寒冷，寒冷……<br>    终于，他觉到身上的肌肉柔软起来，手臂可以微微抬一下了，大腿可以动一下了。他双手撑地，慢慢站起，深情无限的望着程灵素。突然之间，胸中热血沸腾。“我活在这世上还有什么意思？二妹对我这么多情，我却如此薄幸的待她！不如跟她一齐死了！” </p><p>但一瞥眼看到慕容景岳和薛鹊的尸身，立时想起：“爹娘的大仇还没报，害死二妹的石万嗔还活在世上。我这么轻生一死，什么都撒手不管，岂是大丈夫的行径？”<br>    却原来，程灵素在临死之时，这件事也料到了。她将七心海棠蜡烛换了一枝细身的，毒药份量较轻的，她不要石万嗔当场便死，要胡斐慢慢的去找他报仇。石万嗔眼睛瞎了，胡斐便永远不会再吃他亏。她临死时对胡斐说道，害死他父母的毒药，多半是石万嗔配制的。那或许是实情，或许只是猜测，但这足够叫他记着父母之仇，使他不致于一时冲动，自杀殉情。<br>    她什么都料到了，只是，她有一件事没料到。胡斐还是没遵照她的约法三章，在她危急之际，仍出手和敌人动武，终致身中剧毒。<br>    又或许，这也是在她意料之中。她知道胡斐并没爱她，更没有像自己爱他一般深切的爱着自己，但他仁厚侠义，真心待自己好，自己遭到危难之时，他必不顾性命的来救。不如就这样了结。用情郎身上的毒血，毒死了自己，救了情郎的性命。 </p><p>很凄凉，很伤心，可是乾净利落，一了百了，那正不愧为“毒手药王”的弟子，不愧为天下第一毒物“七心海棠”的主人。<br>    少女的心事本来是极难捉摸的，像程灵素那样的少女，更加永远没人能猜得透到底她心中在想些什么。<br>    突然之间，胡斐明白了一件事：“为什么前天晚上在陶然亭畔，陈总舵主祭奠墓中那个姑娘时，竟哭得那么伤心？”原来，当你想到最亲爱的人永远不能再见面时，不由得你不哭，不由得你不哭得这么伤心。 </p><p>他将程灵素和马春花的尸身搬到破庙后院。心想：“两人的尸身上都沾着剧毒，须得小心，别沾上了。我还没报仇，可死不得！”生起柴火，分别将两人火化了。他心中空空洞洞，似乎自己的身子也随着火焰成烟成灰，随手在地下掘了个大坑，把慕容景岳和薛鹊夫妇葬了。 </p><p>眼见日光西斜，程灵素和马春花尸骨成灰，在庙中找了两个小小瓦坛，将两人的骨灰分别收入坛内，心想：“我去将二妹的骨灰葬在我爹娘坟旁，她虽不是我亲妹子，但她如此待我，岂不比亲骨肉还亲么？马姑娘的骨灰，要带去湖北广水，葬在徐大哥墓旁。”回到厢房，见程灵素的衣服包裹兀自放在桌上，凝目良久，忍不住又掉下泪来。 </p><p>只听得她咳了好半晌，才渐渐止了，轻轻的道：“倘若当年我不是在师父跟前立下重誓，终身伴着你浪迹天涯，行侠仗义，岂不是好？胡大哥，你心中难过。但你知不知道，我可比你更伤心十倍啊？”抚着墓碑，低声道：“在那湘妃庙里，你抱住了我，怎么又放开我？……你如不放开我，此刻我不是便在你身边？那晚只要你不放开，便永远不放开了……” </p><p>圆性转过头来，向他看了一眼，心中在说：“我何尝不知该当好好休养，若不是为了你，我何必鞍马劳顿，连夜奔波？”问道：“程家妹子呢？怎么不见她啊？”胡斐泪盈于眶，颤声道：“她……她已去世了。”圆性大惊，站了起来，道：“怎……怎么……去世了？”胡斐道：“你坐下，慢慢听我说。”将自己如何中了石万嗔的剧毒、程灵素如何舍身相救等情一一说了。圆性黯然垂泪。良久良久，两人相对无语，回思程灵素的侠骨柔肠，都是难以自已。<br>    一阵秋风吹来，寒意侵袭，圆性轻轻打了个颤。胡斐脱下身上长袍，披在她的身上，低声道：“你睡一忽儿吧。”圆性道：“不，我不睡。我是赶来跟你说一句话，这……这便要去。”胡斐惊道：“你到那里去？”<br>    圆性凝望着他，轻轻道：“借如生死别，安得长苦悲？”<br>    胡斐听了这两句话，不由得痴了，跟着低声念道：“借如生死别，安得长苦悲？” </p><p>胡斐低声道：“我向东冲出，引开众人，你快往西去。那匹白马系在松树上。”圆性道：“白马是你的，不是我的。”胡斐道：“这当儿还分什么你的、我的！我的命也是你的。我不用照顾你，管教能够突围。”圆性听他说“我的命也是你的”，心里一甜，也想跟着说一句“我的命也是你的”，突然间想到刚逝世的程灵素，终于硬生生忍住，说道：“我不用你照顾，你这就去罢。” </p><p>倘若依了胡斐的计议，一个乘白马奔驰如风，一个持勇力当者披靡，未始不能脱险。可是圆性不愿意，其实在胡斐心中，也是不愿意。也许，两人决计不愿在这生死关头分开；也许，两人早就心中悲苦，觉得还是死了乾净。 </p><p>。<br>    圆性见胡斐挖坑埋葬程灵素的骨灰，心想自己与他立时也便身归黄土，当下悄悄跪倒，忍住背上疼痛，合什为礼，轻轻诵经。<br>    胡斐左肩的伤痛越来越厉害，两只手渐渐挖深，一转头，瞥见圆性合什下跪，神态庄严肃穆，忽感喜慰：“她潜心皈佛，我何苦勉强要她还俗？幸亏她没应允，否则她临死之时，心中不得平安。” </p><p>胡斐弹刀清啸，心中感慨，还刀入鞘，将宝刀放回土坑之中，使它长伴父亲于地下，再将程灵素的骨灰坛也轻轻放入土坑，拨土掩好。他取出金创药为圆性敷上伤口，给她包扎好，说道：“从今以后，你跟着我再也不离开了！”<br>    圆性含泪道：“胡大哥，不成的……我见到你是我命苦，不见你，我仍然命苦……”她跪倒在地，双手合什，轻念佛偈：<br>    一切恩爱会，无常难得久。<br>    生世多畏惧，命危于晨露。<br>    由爱故生忧，由爱故生怖。<br>    若离于爱者，无忧亦无怖。<br>    念偈时泪如雨下，念毕，悄然上马，缓步西去。胡斐牵过骆冰所赠的白马，快步追将上去，说道：“你骑了这马去吧。你身上有伤，还是……还是……”圆性摇摇头，纵马便行。<br>    胡斐望着她背影，那八句佛偈，在耳际心头不住盘旋。<br>    他身旁那匹白马望着圆性渐行渐远，不由得纵声悲嘶，不明白旧主人为什么竟不转过头来。 </p><p>​    胡斐见她背影渐小，即将隐没，突然之间，耳畔似乎又响起了王铁匠的情歌：<br>​    你不见她面时，天天要十七八遍挂在心！<br>​    “袁姑娘，二妹，连同我三个儿，我们又没做坏事，为什么都这样苦恼？难道都是天生命苦吗？” </p><p>回头望望父亲坟前程灵素骨灰的埋葬之处，一阵凉风吹来，吹得坟边青草尽皆伏倒。“再过几天，这些青草都变黄了，最后也都死了。它们倒可在这里长伴二妹，我却不能。二妹今年只十八岁。明年我再来看她，她仍是十八岁，我却一年年大了、老了，到最后还不是同这些青草一般？‘无忧亦无怖’有什么好？恩爱会也罢，不是恩爱会也罢，总都是‘无常难得久’！” </p><p>第22章 后记</p><p>​    程灵素身上夸张的成份不多，她是一个可爱、可敬的姑娘，她虽然不太美丽，但我十分喜欢她。她的可爱，不在于她身上的现实主义，而在于她浪漫的、深厚的真情，每次写到她，我都流眼泪的，像对郭襄、程英、阿碧、小昭一样，我都爱她们，但愿读者也爱她们。 </p>]]></content>
    
    
    <categories>
      
      <category>书影音</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金庸武侠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less is More:De-amplifying I/Os for Key-value Stores with a Log-assisted LSM-tree</title>
    <link href="/2022/03/26/%E8%AF%BB%E8%AE%BA%E6%96%87/L2SM/"/>
    <url>/2022/03/26/%E8%AF%BB%E8%AE%BA%E6%96%87/L2SM/</url>
    
    <content type="html"><![CDATA[<h1 id="Less-is-More-De-amplifying-I-Os-for-Key-value-Stores-with-a-Log-assisted-LSM-tree"><a href="#Less-is-More-De-amplifying-I-Os-for-Key-value-Stores-with-a-Log-assisted-LSM-tree" class="headerlink" title="Less is More: De-amplifying I/Os for Key-value Stores with a Log-assisted LSM-tree"></a>Less is More: De-amplifying I/Os for Key-value Stores with a Log-assisted LSM-tree</h1><h2 id="0x00-Motivation"><a href="#0x00-Motivation" class="headerlink" title="0x00 Motivation"></a>0x00 Motivation</h2><p>LSM-Tree的结构决定了其必须要管理大量的小键值对。在实际的工作负载中，大量随机且频繁的KV更新请求会快速破坏LSM的结构。因此，LSM-KV Store必须不断通过Compaction操作来维持KV对的有序性并降低同一Level中不同SSTable之间Key的重叠率。此外，在LSM-Tree中，越深层的Level，Compaction会触发的越频繁。这会给系统带来巨大的计算和IO开销。</p><p>图1展示了LSM-tree的维护成本。上层SSTable的key相较下层较为稀疏，在Compaction操作时会带来很严重的写放大（图中上层的1个SSTable要与下层的4个SSTable执行归并排序，这就意味着下层的4个SSTable都要被重写）。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/L2SM-F1-2.png" alt="image-20220325194722218"></p><p>图2展示了随着时间的变化，不同Level的磁盘I/O数量。L0中的SSTable是无序的，因此其维护成本变化不大，其他Level的磁盘I/O都随着请求的增加而增加。此外，可以看到越深层的Level，其磁盘I/O次数增长越快。</p><h2 id="0x10-L2SM-Design"><a href="#0x10-L2SM-Design" class="headerlink" title="0x10 L2SM Design"></a>0x10 L2SM Design</h2><h3 id="0x11-Architecture-Overview"><a href="#0x11-Architecture-Overview" class="headerlink" title="0x11 Architecture Overview"></a>0x11 Architecture Overview</h3><p>L2SM的关键设计目标是在维持LSM-Tree结构的基础上，尽量减少I/O放大。</p><p>如图3所示，L2SM将数据保存在内存和磁盘中：</p><ul><li>In-Memory structures：与经典LSM-tree结构相似，L2SM维护了两个内存数据结构MemTable和ImmuTable来吸收和组织大量无序且随机的KV对，随后顺序写到磁盘上。</li><li>On-disk structures：磁盘上的数据被划分为两部分，分别存储到LSM-tree和SST-log，SST-log用于吸收那些会破坏LSM-tree结构的操作。SST-log也是个多层结构，除了L0以外，LSM-tree和SST-log层层对应，SST-log也由多个SSTable组成。其目的是用此日志结构来吸收大量对LSM-tree结构造成破坏的操作，以更稳定的状态和更低的更新开销来保护LSM-tree结构。</li></ul><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/L2SM-F3.png"></p><p>L2SM的数据流：</p><ol><li>KV对先写到MemTable中，随后转为ImmuTable，接着Minor Compaction操作会将ImmuTable持久化为L0中的SSTable；</li><li>当某一层的SSTable数量达到阈值时，选择出那些对LSM-tree潜在造成较大破坏的SSTable（例如包含hot-key range的SSTable），然后通过Presudo Compaction（PC）操作将其移动到同一Level的SST-log中，由Log Metadata Manager管理。需要注意的是，PC操作只是通过更新元数据来进行<strong>逻辑移动</strong>，并不会带来任何物理I/O开销。</li><li>如果SST-log的Level大小超过阈值，则Aggregate Compaction（AC）操作会从该Level中选择SSTable来与LSM-tree下一Level的有重叠范围SSTable进行合并。</li></ol><p>因此，在L2SM中，一个KV项首先会水平从LSM-tree中移到SST-log，然后垂直移动到LSM-Tree的下一Level中。</p><h3 id="0x12-LSM-Tree-and-SST-log"><a href="#0x12-LSM-Tree-and-SST-log" class="headerlink" title="0x12 LSM-Tree and SST-log"></a>0x12 LSM-Tree and SST-log</h3><h4 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h4><p>在L2SM中，Compaction操作被划分为：PC操作和AC操作。PC操作将SSTable从LSM-Tree移到同一层的SST-Log中，AC操作将SSTable与LSM-Tree中下一Level的重叠SSTable进行合并。</p><p>PC和AC操作根据SSTable的属性（hotness和density，热度和密度）来选择SSTable进行移动和合并。</p><p>此外，经典LSM-Tree KV-Store一次仅选择一个SSTable来与下一Level的重叠SSTable进行合并。而L2SM一次AC操作会从SST-Log中选择多个SSTable来进行更加密集的合并，以实现更好的I/O性能。</p><h4 id="SST-Log"><a href="#SST-Log" class="headerlink" title="SST-Log"></a>SST-Log</h4><p>SST-Log主要由以下四个作用：</p><ul><li>从LSM-Tree中剥离出那些反复破坏LSM-Tree结构的「hot」数据（频繁更新的数据），并将其存到SST-Log提供的独立空间中；</li><li>提供一个缓冲区来识别和压缩那些键值范围稀疏的SSTable，然后将它们合并到LSM-Tree中；</li><li>延迟并减轻对LSM-Tree的破坏性操作，例如将多次Compaction操作累积为一个；</li><li>允许尽早从LSM-Tree中删除过时和lazy delte的数据；</li></ul><p>不同于LSM-Tree，SST-Log不要求每一Level中的KV保持有序，因此同一Level的不同SSTable的键值范围会有重叠。所以在SST-Log中进行查找时必须查找所有的SSTable，这会带来一定的开销。但在L2SM中允许这种重叠是必须的，因为SST-Log的设计目的便是为了吸收和累积更新，以使这些更新在AC操作中可以合并为一个，这可以尽量减少对LSM-Tree的影响。</p><p>在LSM-Tree中，越深层的Level，其SSTable的访问频率越低，SSTable的密度也更高。因此，对于深层的Level来来说，不需要为其分配太大的SST-Log Level。L2SM通过一个称为「Inverse Proportional Log Size」的方案来决定SST-Log中每一个Level 的大小。具体看原文，这里不多做叙述。</p><h3 id="0x13-Hotness-and-Density"><a href="#0x13-Hotness-and-Density" class="headerlink" title="0x13 Hotness and Density"></a>0x13 Hotness and Density</h3><p>为了减轻对LSM-Tree结构的破坏性干扰，L2SM需要识别出频繁更新和稀疏的SSTable，并将它们隔离在SST-Log中。</p><p>L2SM使用两个指标，hotness和density，来定量分析SSTable的属性。「hotness」用于衡量SSTable中KV对的更新频率，「density」用于衡量SSTable的key覆盖和影响的范围。这两个指标共同描述了若将相关KV项保存在LSM-Tree中可能会对LSM-Tree的结构造成潜在破坏的严重程度。</p><h4 id="Hotness-of-SSTables"><a href="#Hotness-of-SSTables" class="headerlink" title="Hotness of SSTables"></a>Hotness of SSTables</h4><p>L2SM通过维护一个「Hotness Detecting Bitmap（HotMap）」来定量分析一个SSTable的「hotness」。HotMap是一个存在于内存中全局多层布隆过滤器（Bloom Filter， BF）。</p><p>如图4所示，一个M层的HotMap有M个对齐的BF组成。当一个KV项在第$i$次更行时，将第$i$层的BF相应bit位重置为1。因此，一个M层的HotMap最多可以记录给定KV项的M次更新。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/L2SM-F4.png" alt="image-20220325213716525"></p><p>一个SSTable的「hotness」计算方式为$\sum_{i=1}^{m-1}(x_i \times 2^i)$，其中$x^i$表示HotMap指示SSTable中访问次数为$i$的KV项的数量。</p><p>HotMap能不能发挥作用主要看参数M和P，下面介绍L2SM是如何配置这两个参数的。</p><p><strong>Configuring M</strong></p><p>M是HotMap的层数，决定了其能记录的KV项的更新次数。显然M越大，HotMap能记录的更新次数越多，HotMap也就越精确，但这也会带来较大的内存开销。L2SM使用一个简单的方法来设置M。</p><p>对$n$个key进行$r$次请求的工作负载，每个key的平均访问次数为$\tau = r/n$，L2SM使用$M = \left \lceil r/n \right \rceil$来设置HotMap的层数。其合理性也很容易解释，当一个KV项的更新次数超过平均更新次数时，该KV项便可以被认为是hot-key。</p><p><strong>Configuring P</strong></p><p>P是每个BF所表示的bit数组的大小，决定了BF的FPR（False Positive Rate）。当P过小时，BF的FPR会过高，能发挥的作用有限。</p><p>另$\rho$表示在工作负载的所有唯一key中hot-key所占的比例。用N表示所有唯一Key的数量，K表示BF中使用的哈希函数数量，<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf">根据已有的研究</a>，bit数组的大小应该被设置为$P = \frac{K \times N}{ln2}$。</p><p><strong>Auto-turning HotMap</strong></p><p>随着时间的推移，HotMap会被逐渐填满，最终失去区分hot-key和cold key的作用。因此，必须确保HotMap能自适应工作负载，在运行时能始终发挥作用。</p><p>为了保持一个较低FPR，需要周期性的对HotMap进行更新和扩容。L2SM提出了一个称为Online Adaptive Auto-tuning的方案来自动调整HotMap。</p><p>有几种情况会触发该调整方案来调整HotMap。</p><p>如图5所示，如果顶层的BF接近其容量限制，这表明HotMap过小而无法以较低的FPR来服务于其设计目的，此时将停用该层。当停用该层时，会进一步检查下一层。如果下一层的空间消耗超过20%，则将顶层的BF大小扩大10%，将其所有位重置为0，然后将其旋转到底层，如图5(a)所示；否则，若下一层的使用情况小于20%，为了节省空间，直接将顶层BF的大小设置为当前底层BF的大小，将其所有位重置为0，然后旋转到底层，如图5(b)所示。其原理是，若第二层消耗很小，则很可能大多数键都是冷的，并且工作集没有增长，当前的HotMap大小是足够的。</p><p>假设顶层的BF足够大，可以容纳所有的唯一写入，如果任何两个相邻层接受的唯一键太接近（例如，两层之间接受的插入差异小于10%，并且每层占用超过层大小20%），也即两层过于相似，这发生在重复更新一组键时。此时，可以通过重置顶层BF并将其旋转到底层来将其退休，如图5(c)所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/L2SM-F5.png" alt="image-20220326100338719"></p><p><strong>Overhead</strong></p><p>内存开销可以用$M \times P$来表示。M是BF的数量，P是BF的大小。</p><h4 id="Density-of-SSTables"><a href="#Density-of-SSTables" class="headerlink" title="Density of SSTables"></a>Density of SSTables</h4><p>在L2SM中，大多数情况下SSTable的大小一致，并且其KV项是有序的。L2SM使用SSTable中KV项的数量和key range的比值来表示其密度。</p><p>SSTable的key range是SSTable中第一个key和最后一个key之间的差。但由于实际工作负载中，key的表示形式不同，可能为字符串或数字。因此不能直接通过数字减法来计算。</p><p>L2SM通过将key转换为128位的二进制值来简化此计算过程。然后通过逐位比较两个128位二进制值（比较第一个key和最后一个key），以找到两个key中不同的最高位。假设不同的最高位是第$i$位，则SSTable的key range可以粗算为$2^i$。如果此SSTable包含$k$个KV项，则其密度可以计算为$k/2^i$。为了进一步简化计算，L2SM使用对数来表示SSTable的密度值，即$lg(k/2^i) = lgk - i$。此外，还可以用$S = i - lgk$来表示SSTable的sparseness，这是与density相反的表示方式。</p><h3 id="0x14-Pseudo-Compaction"><a href="#0x14-Pseudo-Compaction" class="headerlink" title="0x14 Pseudo Compaction"></a>0x14 Pseudo Compaction</h3><p>在L2SM中，当LSM-Tree中的某个Level被写满时，根据SSTable的hotness 和density ，PC能够快速选择出那些对LSM-Tree结构造成潜在破坏的SSTable，将其隔离在SST-Log中，以降低I/O放大。</p><p>为了确定移入SST-Log的最佳SSTable，L2SM使用一个Combined Weight来联合考虑hotness和density，以确定SSTable的选择。</p><p>对于给定的SSTable $i$，假设其hotness为$H_i$，sparseness 为$S_i$，则权重方程为$W_i = \alpha \times H_i + (1 - \alpha) \times S_i$，其中$\alpha$</p><p>是预设的权重参数，默认为0.5 。</p><p>要计算SSTable的组合权重，首先需要将S和H都归一化到0～1之间。归一化后其组合权重可以表示为：<br>$$<br>W_i = \alpha  \times \frac{H_i}{H_{max} - H_{min}} + (1 - \alpha) \times  \frac{S_i}{S_{max} - S_{min}}<br>$$</p><h3 id="0x15-Aggregated-Compaction"><a href="#0x15-Aggregated-Compaction" class="headerlink" title="0x15 Aggregated Compaction"></a>0x15 Aggregated Compaction</h3><p>AC操作负责回收SST-Log的空间，它尝试在SST-Log中保留那些对LSM-Tree结构影响最大的SSTable，并将</p><p>冷而密集的SSTable合并到LSM-Tree的下一Level中。</p><p>当SST-Log超过其大小限制时，会触发AC操作将冷而密集的SSTable合并到LSM-Tree，同时将热而稀疏的SSTable保存在SST-Log。此时需要对SST-Log中的所有SSTable进行组合权重计算，以选择SSTable。</p><p>整个Compaction过程如下所示：</p><ol><li>根据组合权重W找到最冷最密集的「种子」SSTable，并使用该SSTable在SST-Log中递归找到所有与它的key range重叠的SSTable，根据版本顺序对所有的SSTable进行排序；</li><li>基于步骤1选择出的SSTable，从最旧的SSTable开始，放入victim Compaction Set（CS），在LSM-Tree的下一Level中找到与CS中的SSTable有重叠Key range的SSTable，将其放入victim Involved Set（IS）；</li><li>重复步骤2，直到步骤1中找到的所有SSTable都放在CS中，或者IS和CS中SSTable的比值大于预设值（默认为10，用于控制AC所引起的I/O放大）；</li><li>最后开始正式的归并排序。首先从CS中最旧的SSTable开始，删除其中所有已标记删除和过时的KV项。然后将其与IS中的相关SSTable进行合并，最后将生成的新的SSTable插入到LSM-Tree的下一Level中，这样便完成了AC过程。</li></ol><p>图6是该AC过程的一个示例。块中的数字表示其时间顺序，也即版本（越小表示越旧）。SST-Log中有6个SSTable，SSTable 8为最冷最密集的SSTable，有三个SSTable与其有重叠（SSTable 6、14和29）。CS中包括SSTable 6、8和14，虽然SSTable 29也与SSTable 8有重叠，但因为超过了I/O限制，其不参与此次AC过程。所以，最后是SSTable 6、8和14与IS中的SSTable进行合并重写。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/L2SM-F6.png" alt="image-20220326112729159"></p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《书剑恩仇录》</title>
    <link href="/2022/03/19/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%89%91%E6%81%A9%E4%BB%87%E5%BD%95/"/>
    <url>/2022/03/19/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%89%91%E6%81%A9%E4%BB%87%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天突然想起「慧极必伤，情深不寿」这句话，记不清出处，又查了一下，原文应该是「情深不寿，强极则辱，谦谦君子，温润如玉」。此句出自金庸的第一部武侠小说《书剑恩仇录》。</p><p>就真的因为这句话去读了这本小说。我是用微信读书看的，经常能看到网友的批注，其中不乏对文中各个角色的点评，甚至是批评。私以为，大可不必。人入江湖，身不由己，纵你神功盖世，也无可奈何，每个人都有其局限性。当局者迷，旁观者清。</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>第5章 置酒弄丸招薄怒 还书贻剑种深情</p><p>霍青桐奔了一段路，忽然勒马回身，见陈家洛正自呆呆相望，一咬嘴唇，举手向他招了两下。陈家洛见她招手，不由得一阵迷乱，走了过去。霍青桐跳下马来。两人面对面的呆了半晌，说不出话来。 </p><p>霍青桐见他神情落寞，心中很不好受，微一踌躇，说道：“你不要我跟你去救文四爷，为了什么，我心中明白。你昨日见了那少年对待我的模样，便瞧我不起。这人是陆菲青陆老前辈的徒弟，是怎么样的人，你可以去问陆老前辈，瞧我是不是不知自重的女子！”说罢纵身上马，绝尘而去。 </p><p>第6章 乌鞘岭口拚鬼侠 赤套渡头扼官军</p><p>陈家洛手托短剑，呆呆的出神，望着霍青桐追上回人大队，渐渐隐没在远方大漠与蓝天相接之处，心头一震，正要去问陆菲青，一个念头猛地涌上心来：“汉回不通婚，他们回人自来教规极严，霍青桐姑娘对我虽好，但除非我皈依回教，做他们的族人，否则多惹情丝，终究没有结果，徒然自误误人，各寻烦恼而已。”“我对回教的真神并不真心信奉，如为了霍青桐姑娘而假意信奉，未免不诚，非正人君子之所为。岂不遭人轻视耻笑？”正出神间，忽见前面一骑如一溜烟般奔来，越到身前越快，却是心砚回来了。 </p><p>第7章 有情有义怜难侣 无法无天振饥民</p><p>回首西望，天上众星明亮，遥想平沙大漠之上，这星光是否正照到了那青青翠羽，淡淡黄衫？ </p><p>第8章 琴音朗朗闻雁落 剑气沉沉作龙吟</p><p>​    陈家洛也带了心砚到湖上散心，在苏堤白堤漫步一会，独坐第一桥畔，望湖山深处，但见竹木森森，苍翠重叠，不雨而润，不烟而晕，山峰秀丽，挺拔云表，心想：“袁中郎初见西湖，比作是曹植初会洛神，说道：‘山色如娥，花光如颊，温风如酒，波纹如绫，才一举头，已不觉目酣神醉。’不错，果然是令人目酣神醉！”<br>​    他幼时曾来西湖数次，其时未解景色之美，今日重至，才领略到这山容水意，花态柳情。</p><p>​    “锦绣乾坤佳丽，御世立纲陈纪。四朝辑瑞徵师济，盼皇畿，云开雉扇移。黎民引领鸾舆至，安堵村村扬酒旗。恬熙，御炉中靉靆瑞云霏。” </p><p>陈家洛道：“先严已不幸谢世。小弟碌碌庸才，功名利禄，与我无缘。”</p><p>陈家洛道：“与其残民以逞，不如曳尾于泥涂耳。”</p><p>东方耳又道：“纳兰公子绝世才华，自是人中英彦，但你瞧他词中这一句：‘且由他蛾眉谣诼，古今同忌。身世悠悠何足问，冷笑置之而已。’未免自恃才调，过于冷傲。少年不寿，词中已见端倪。”说罢双目盯住陈家洛，意思是说少年人恃才傲物，未必有什么好下场。陈家洛笑道：“大笑拂衣归矣，如斯者古今能几？向名花美酒拚沉醉。天下事，公等在。”这又是纳兰之词。东方耳见他一派狂生气概，不住摇头，但又不舍得就此作别，想再试一试他的胸襟气度，随手翻过扇子，见反面并无书画，说道：“此扇小弟极为喜爱，斗胆求兄见赐，不知可否？”陈家洛道：“兄台既然见爱，将去不妨。”东方耳指着空白的一面道：“此面还求兄台挥毫一书，以为他日之思。兄台寓所何在？小弟明日差人来取如何？”陈家洛道：“既蒙不嫌鄙陋，小弟即刻就写便是。”命心砚打开包裹，取出笔砚，略加思索，在扇面上题诗一绝，诗云：<br>    “携书弹剑走黄沙，瀚海天山处处家，大漠西风飞翠羽，江南八月看桂花。” </p><p>第9章 千军岳峙围千顷 万马潮汹动万乘</p><p>侍卫牵过御马，乾隆对陈家洛道：“你骑我这匹马。”侍卫忙又牵过一匹马来。两人上马，向春熙门而去。<br>这时郁雷之声渐响，轰轰不绝。待出春熙门，耳中尽是浪涛之声，眼望大海，却是平静一片，海水在塘下七八丈，月光淡淡，平铺海上，映出点点银光。<br>乾隆望着海水出了神，隔了一会，说道：“你我十分投缘。我明天回杭州，再住三天就回北京，你也跟我同去好吗？最好以后常在我身边。我见到你，就如同见到令尊一般。”<br>陈家洛万想不到他会如此温和亲切的说出这番话来，一时倒怔住了难以回答。<br>乾隆道：“你文武全才，将来做到令尊的职位，也非难事，这比混迹江湖要高上万倍了。”皇帝这话，便是允许将来升他为殿阁大学士。清代无宰相，大学士是一人之下万人之上的高位，心想他必定喜出望外，叩头谢恩。那知陈家洛道：“你一番好意，我十分感谢，但如我贪恋富贵，也不会身离阁老之家，孤身流落江湖了。”<br>乾隆道：“我正要问你，为什么好好的公子不做，却到江湖上去厮混，难道是不容于父兄么？”陈家洛道：“那倒不是，这是奉我母亲之命。我父亲、哥哥是不知道的。他们花了很多心力，到处找寻，直到这时，哥哥还在派人寻我。”乾隆道：“你母亲叫你离家，那可真奇了，却又干么？”</p><p>​    玉色晶莹，在月亮下发出淡淡柔光，陈家洛谢了接过，触手生温，原来是一块异常珍贵的暖玉。玉上以金丝嵌着四行细篆铭文：“情深不寿，强极则辱。谦谦君子，温润如玉。” </p><p>乾隆笑道：“如我不知你是胸襟豁达之人，也不会给你这块玉，更不会叫你赠给意中人。这四句铭文虽似不吉，其中实含至理。”陈家洛低吟“情深不寿，强极则辱”那两句话，体会其中含意，只觉天地悠悠，世间不如意事忽然间一齐兜上心头，悲从中来，直欲放声一哭。乾隆道：“少年爱侣，情深爱极，每遭鬼神之忌，是以才子佳人多无美满下场，反不如伧夫俗子常能白头偕老。情不可极，刚则易折，先贤这话，确是合乎万物之情。” </p><p>​    一丘黄土，埋香掩玉，陈家洛想起旧时情谊，不禁凄然，在坟前作了三个揖。 </p><p>第11章 烟腾火炽走豪侠 粉腻脂香羁至尊</p><p>待众人游船围着玉如意花舫时，只见她启朱唇、发皓齿，笛子声中，唱了起来：“望平康，凤城东，千门绿杨。一路紫丝缰，引游郎，谁家乳燕双双？隔春波，碧烟染窗；倚晴天，红杏窥墙，一带板桥长。闲指点，茶寮酒舫，声声卖花忙。穿过了条条深巷，插一枝带露柳娇黄。” </p><p>众人把那卷轴打开，见是一幅书法，写的是：“西湖清且涟漪，扁舟时荡晴晖。处处青山独住，翩翩白鹤迎归。昔年曾到孤山，苍藤古木高寒。想见先生风致，画图留与人看。”笔致什为秀拔，却无图章落款，只题着“临赵孟俯书”五字。 </p><p>古往今来，嫖院之人何止千万，却要算乾隆这次嫖得最为规模宏大，当真是好威风，好煞气，于日后“十全武功”，不遑多让焉。后人有《西江月》一首为证，词曰：<br>    铁甲层层密布，刀枪闪闪生光，忠心赤胆保君皇，护主平安上炕。<br>    湖上选歌徵色，帐中抱月眠香。刺嫖二客有谁防？屋顶金钩铁掌。 </p><p>第12章 高塔入云盟九鼎 快招如电显双鹰</p><p>关明梅把陈家洛拉在一旁道：“你娶了亲没有？”陈家洛脸一红道：“没有。”关明梅又道：“定了亲么？”陈家洛道：“也没有。”关明梅点点头，温颜微笑，忽然厉声道：“如你无情无义，将来负了赠剑之人，我老婆子决不饶你。”陈家洛不禁愕然无辞以对。 </p><p>第13章 盈盈彩烛三生约 霍霍青霜万里行</p><p>李沅芷知道说错了话，涨红了脸，过了一会，低声道：“你骂我爹爹！人各有志我也不敢勉强。只要你爱这样，我也会觉得好的。我应承听你的话，以后决不再去帮爹爹，我想我师父也会欢喜。”最后两句话说得声音响了些，多半窗外的陆菲青也听见了。余鱼同坐在桌边，只是不语。李沅芷低声道：“你说我官家小姐不好，那我就不做官家小姐。你说你红花会好，那我也……我也跟着你做……做江湖上的亡命之徒……”这几句话用了极大的气力才说出口，说到最后，又羞又急，竟哭了出来。 </p><p>陈家洛道：“前辈太客气了。令徒曾到过回部吧？”陆菲青道：“她从小在西北一带。”陈家洛道：“嗯，我见他和那位回人姑娘好似交情不错。”霍青桐和陈家洛离别之时，曾说过一句话：“那人是怎样的人，你可以去问她师父。”陈家洛几次想问陆菲青，总觉太着痕迹，始终忍着不问，此刻陆菲青自己过来谈起，这才轻描淡写、似乎漠不关心的问了几句，其实心中已在怦怦暗跳，手心潜出汗水。 </p><p>余鱼同接过打开，见纸上写着十六个细字：“情深意真，岂在丑俊？千山万水，苦随君行。”笔致娟秀，认得是李沅芷的字迹，不料她竟一路跟随而来，他眉头一皱，把字条交给陈家洛。</p><p>第14章 吐气扬眉雷掌疾 惊才绝艳雪莲馨</p><p>“多才惹得多愁，多情便有多忧，不重不轻证候，甘心消受，谁教你会风流？” </p><p>出得房来，想下岗去找李沅芷，经过殿堂时见到壁画，驻足略观，见画的是八位高僧出家的经过，一幅画中题词说道，这位高僧在酒楼上听到一句曲词，因而大彻大悟。余鱼同不即往下看去，闭目凝思，那是一句什么曲词，能有偌大力量？睁开眼来，见题词中写着七字：“你既无心我便休”。这七个字犹如当头棒喝，耳中嗡嗡作响，登时便呆住了。 </p><p>第15章 密意柔情锦带舞 长枪大戟铁弓鸣</p><p>霍青桐向妹妹偷望一眼，见她容光焕发，凝望着陈家洛，眼光中流露着千般仰慕，万种柔情，竟无丝毫担心害怕，不由得暗暗叹了口气，转头望陈家洛时，见他神定气闲，泰然自若。两人目光相接，陈家洛微微点头，温然微笑。霍青桐脸上一阵晕红，转开了头。 </p><p>木卓伦道：“青儿，你妹子真勇敢。”霍青桐点点头，掩面奔进营帐。一时之间，似乎有个大铁椎在不住敲打自己胸口，腹酸心痛，恨不得立时死了才好。 </p><p>第16章 奇谋破敌将军苦 儿戏降魔玉女嗔</p><p>。<br>    她发令已毕，独自骑马向西，下马跪下，泪流满面，低声祷祝：“万能的真主，愿你圣道得胜，打败入侵的敌人。现今我爹爹不相信我，哥哥不相信我，连我部下也不相信我，为了要使他们听令，我只得杀人。安拉，求你佑护，让我们得胜，让爹爹和妹妹平安归来。如果他们要死，求你千万放过，让我来代替他们。求你让陈公子和妹妹永远相爱，永远幸福。你把妹妹造得这样美丽，一定对她特别眷爱，望你对她眷爱到底。” </p><p>香香公主微笑着对陈家洛道：“你对这位大哥说，我们很是高兴，请他和我们同去找姊姊。”陈家洛这才和李沅芷行礼厮见，说道：“李大哥怎么也来啦？别来可好？”李沅芷红了脸，只是格格的笑，望着余鱼同，下巴微扬，示意要他说明。余鱼同道：“总舵主，她是我陆师叔的徒弟。”陈家洛道：“我知道，我们见过几次。”余鱼同笑道：“她是我师妹。”陈家洛惊问：“怎么？”余鱼同道：“她出来爱穿男装。” </p><p>第17章 我见犹怜二老意 谁能遣此双姝情</p><p>陈家洛心想：“我不知李沅芷是女扮男装，何尝不笨？”“难道自己真的瞧不出李沅芷是女扮男装吗？”她虽装得什像，但面目娇媚秀美，一望而知是个绝色美人。但一来其时初接总舵主大任，深惧不胜负荷，又逢文泰来被捕，不知如何搭救，戒慎恐惧之际，不敢再惹儿女之情，二来陈家洛一生之中，相处熟稔的女孩子只是晴画、雨诗那样的小丫头，温柔婉顺，他说什么就听什么，霍青桐这般英风飒飒，虽美而不可亲，一见就只想远观而不愿接近，似乎自己故意想找个藉口来退缩在一边。其实他见李沅芷面目美秀，脂粉气什重，只当她是个善于调情骗女人的浮浪子弟，但确比自己俊美得多，他一生事事皆占上风，忽然间给人比了下去，既感气恼，又生了醋意成见，不免故意对其贬低，不肯正视真相。其后天目山徐天宏洞房之夕李沅芷前来混闹，陈家洛也料到是陆菲青的女弟子，内心深处，却不愿由此消去对霍青桐的芥蒂，此后也正因此而得与香香公主相爱，却又未免辜负了霍青桐的一番心意，对她不免有愧于心。喜愧参半，不由得叹了口长气。 </p><p>第18章 为民除害方称侠 抗暴蒙污不愧贞</p><p>关明梅望着渐渐在大漠边缘沉下去的太阳，缓缓说道：“什么都讲个缘法。从前，我常常很是难受，但近来我忽然高兴了。”伸手把陈正德大褂上一个松了的扣子扣上了，又道：“一个人天天在享福，却不知道这就是福气，总是想着天边拿不着的东西，那知道最珍贵的宝贝就在自己身边。现今我是懂了。”陈正德红光满面，神采焕发，望着妻子。 </p><p>第19章 驱驴有术居奇货 除恶无方从佳人</p><p>李沅芷垂下泪来，叫道：“你心里是不喜欢我的，我知道。你快带我见爹爹去，我要死啦。”眼望远处幻象，道：“那是西湖，我爹爹在西湖边上做提督，他……他……你认识他么？” </p><p>第20章 心伤殿隅星初落 魂断城头日已昏</p><p>陈家洛硬起心肠，道：“你跟姊姊去吧！”香香公主垂泪道：“你一定要回来！”陈家洛点点头。香香公主道：“你十年不来，我等你十年；一辈子不来，我等你一辈子。”陈家洛想送件东西给她，以为去日之思，伸手在袋里一摸，触手生温，摸到了乾隆在海塘上所赠的那块温玉，取出来放在香香公主手中，低声道：“你见这玉，就如见我一般。”香香公主含泪接了，说道：“我一定还要见你。就算要死，也是见了你再死。”陈家洛微笑道：“干么这般伤心？等大事成功之后，咱们一起到北京城外的万里长城去玩。”香香公主出了一会神，脸上微露笑意，道：“你说过的话，可不许不算。”陈家洛道：“我几时骗过你来？”香香公主这才勒马不跟。 </p><p>天虹叹道：“诸行无常，诸法无我。人之所滞，在以无为有。若托心本无，异想便息。”陈家洛道：“众生方大苦难。高僧支道林曾有言道：桀纣以残害为性，岂能由其适性逍遥？”</p><p>第21章 忍见红颜堕火窟 空馀碧血葬香魂</p><p>她低声道：“至神至圣的安拉，我不是不信你会怜悯我，但是除了用我身上的鲜血之外，没有别的法子可以教他逃避危难。”于是从衣袖中摸出短剑，在身子下面的砖块上划了“不可相信皇帝”几个字，轻轻叫了两声：“大哥！”将短剑刺进了那世上最纯洁最美丽的胸膛。 </p><p>霍青桐又是伤心，又是愤恨，怒道：“你怎地如此胡涂，竟会去相信皇帝？”陈家洛惭愧无地，道：“我只道他是汉人，又是我的亲哥哥。”霍青桐道：“汉人又怎样？难道汉人就不做坏事么？做了皇帝，还有什么手足之情？”陈家洛哽咽道：“是我害了喀丝丽！我……我恨不得即刻随她而去。” </p><p>白振见众人都是空手不带兵刃，暗暗叹息，想要对陈家洛暗提几句警告，思前想后，总是不敢。 </p><p>​    李可秀拉着女儿的手，叫道：“在我身边！”他一面和白振两人分别传令，督率侍卫拦截，一面拉着女儿，防她混乱中受伤。余鱼同见状，长叹一声，心想：“我与她爹爹势成水火，她终究非我之偶！”一阵难受，挥笛冲入。<br>​    李沅芷右手使劲一挣，李可秀拉不住，当即被她挣脱。李沅芷叫道：“爹爹保重，女儿去了！”反身跃起，纵入人丛。李可秀大出意外，急叫：“沅儿，沅儿，回来！” </p><p>​    无尘叫道：“十弟，下来吧！”章进只是不动，骆冰去扶他时，只觉他身子僵硬，原来已经气绝。骆冰伏尸大哭。文泰来正在抵敌众侍卫，接应赵半山、常氏双侠等过来，听得骆冰哭声，不由得洒了几点英雄之泪，怒气上冲，挥刀连毙三敌。 </p><p>​    霍青桐见师父抱住师公不住垂泪，忙走过去，只见陈正德背上伤口中的血如泉涌，汩汩流出。陆菲青也抢了过来，拿出金创药给他敷治。陈正德苦笑摇了摇头，对关明梅道：“我对不住你……累得你几十年心中不快活，你回到回部之后，和袁……袁大哥去成为夫妻……我在九泉，也心安了。陆兄弟，你帮我成全了这桩美事……” </p><p>白振避开一掌，接了一掌，知道不是敌手，跳开一步，叫道：“陈总舵主，我不是你对手。”陈家洛道：“我敬重你是条汉子，只要你不再给皇帝卖命，那就去吧！”赵半山守在东面窗口，往旁侧一让。白振凄然一笑，道：“多谢两位美意。在下到此地步，还有什么面目再混迹于江湖？”纵身从窗口跳出，远远去了。 </p><p>陈家洛提笔醮墨，先写了“香冢”两个大字，略沉吟，又写了一首铭文：<br>    “浩浩愁，茫茫劫，短歌终，明月缺。郁郁佳城，中有碧血。碧亦有时尽，血亦有时灭，一缕香魂无断绝！是耶非耶？化为蝴蝶。”<br>    群雄伫立良久，直至东方大白，才连骑向西而去。 </p><p>第22章 魂归何处</p><p>阿凡提一抹胡子，森然说道：“陈兄弟，这柄长剑，是秃鹫陈正德老爷子用来自杀的。还有一柄，雪雕陈夫人用来抹了自己脖子。翠羽黄衫托我将这柄剑带来给你。她说你再要自杀，不要悬梁，就用陈老爷子这把剑。翠羽黄衫一得知你的死讯，她就用她师父陈夫人的短剑自杀。我们穆斯林说一是一，说二是二，从来没有说了不算数的。” </p><p>陈家洛默然不语。陆菲青缓缓摇头，叹道：“‘一朝之忿，忘其身，以及其亲，非惑与？’红花会的众位兄弟，今日都是你的‘亲’了，你自暴自弃的自尽，只不过出于一朝之忿，把他们全都忘了。”陈家洛道：“晚辈也不是出于一朝之忿，而是前后思量，实在无德无能、无智无勇，愚而信人，可说是罪不容诛，非自尽不足以谢天下……”说着不禁流下泪来，言语中已带呜咽。陆菲青轻拍他肩头，说道：“‘君子之过也，如日月之食也：过也，人皆见之；更也，人皆仰之。’这是《论语》中的话。”陈家洛道：“前辈教训得是。不过我们一败涂地，已经无可更改的了。” </p><p>陆菲青凛然道：“孟子说：‘居天下之广居，立天下之正位，行天下之大道。得志，与民由之，不得志，独行其道。富贵不能淫，贫贱不能移，威武不能屈，此之谓大丈夫。’何况红花会众兄弟跟我们这些人，个个都是舍生忘死，为国为民，行的是天下之大道，并非单只你‘独行其道’。虽然前途艰难，未必有成，但大丈夫知其不可而为之，自反而缩，虽万千人，吾往矣！”伸掌大力在胸口拍了几下，说道：“总舵主，咱们英雄好汉，又怕了什么？” </p><p>微信读书</p><p>陈家洛默然不语。陆菲青缓缓摇头，叹道：“‘一朝之忿，忘其身，以及其亲，非惑与？’红花会的众位兄弟，今日都是你的‘亲’了，你自暴自弃的自尽，只不过出于一朝之忿，把他们全都忘了。”陈家洛道：“晚辈也不是出于一朝之忿，而是前后思量，实在无德无能、无智无勇，愚而信人，可说是罪不容诛，非自尽不足以谢天下……”说着不禁流下泪来，言语中已带呜咽。陆菲青轻拍他肩头，说道：“‘君子之过也，如日月之食也：过也，人皆见之；更也，人皆仰之。’这是《论语》中的话。”陈家洛道：“前辈教训得是。不过我们一败涂地，已经无可更改的了。” </p><p>陆菲青凛然道：“孟子说：‘居天下之广居，立天下之正位，行天下之大道。得志，与民由之，不得志，独行其道。富贵不能淫，贫贱不能移，威武不能屈，此之谓大丈夫。’何况红花会众兄弟跟我们这些人，个个都是舍生忘死，为国为民，行的是天下之大道，并非单只你‘独行其道’。虽然前途艰难，未必有成，但大丈夫知其不可而为之，自反而缩，虽万千人，吾往矣！”伸掌大力在胸口拍了几下，说道：“总舵主，咱们英雄好汉，又怕了什么？” </p><p>微信读书</p>]]></content>
    
    
    <categories>
      
      <category>书影音</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金庸武侠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticBF:Elastic Bloom Filter with Hotness Awareness for Boosting Read Performance in Large Key-Value Stores</title>
    <link href="/2022/03/19/%E8%AF%BB%E8%AE%BA%E6%96%87/ElasticBF-2/"/>
    <url>/2022/03/19/%E8%AF%BB%E8%AE%BA%E6%96%87/ElasticBF-2/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在论文<a href="https://www.usenix.org/system/files/conference/hotstorage18/hotstorage18-paper-zhang.pdf"><strong>ElasticBF: Fine-grained and Elastic Bloom Filter Towards Efficient Read for LSM-tree-based KV Stores</strong></a>中，作者认为在基于LSM的KV-Store中，即使是同一Level中的不同SSTable之间也存在访问倾斜。也即有的SSTable访问频率高，而有的SSTable访问频率较低。</p><p>而在论文<a href="https://www.usenix.org/system/files/atc19-li-yongkun.pdf">ElasticBF: Elastic Bloom Filter with Hotness Awareness for Boosting Read Performance in Large Key-Value Stores</a>中，作者进一步认为，在同一SSTable内的不同区域之间也存在访问倾斜。基于数据访问倾斜的特性，在设计Bloom Filter时，可以对hot data分配更大的bits-per-key，来减少FPR，以进一步减少由于FP导致的额外I/O提高KV Store的读性能。</p><p>下面将对该论文的内容进行摘要总结。</p><h2 id="0x10-Motivation"><a href="#0x10-Motivation" class="headerlink" title="0x10 Motivation"></a>0x10 Motivation</h2><p>为了证明不仅SSTable之间存在访问倾斜，而且SSTable内部不同区域之间也存在访问倾斜，作者做了一系列实验进行验证。这些实验关闭了SSTable的Bloom Filter，这样在查找某个key时，只能一层一层的，一个SSTable一个SSTable的进行查找。</p><p>图2展示了不同SSTable的访问频率。可得出如下结论：</p><ol><li>lower level的SSTable访问频率更高，这是因为在执行查找时总是自上而下查找的；</li><li>从曲线的波动情况来看，同一层中不同的SSTable之间的访问频率也有很大的差异，而且这种情况不只发尚在某一层中，而是在每层都普遍存在的，且高层的波动范围更剧烈，这说明越高的level，其数据冷热差异越明显；</li></ol><p>第二点结论也说明Moneky论文提出的单纯基于level来确定Bloom Filter的bits-per-key，以利用数据倾斜，是不够合理的。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F2.png" alt="image-20220318202320399"></p><p>为了进一步利用顺序写的带宽优势，SSTable的大小有可能会进一步增加，例如RocksDB的SSTable达到了64MB。因此，SSTable内部的访问倾斜可能也很严重。</p><p>记录每个KV对的访问频率对内存和CPU来讲都是很大的开销，因此本文在进行实验验证时将64MB的SSTable划分为64个区域，每个区域1MB，仅记录每个区域的访问频率。</p><p>图3展示了同一SSTable中所有区域的最大和最小访问频率之差与其平均访问频率之比。可以看到，在很多的SSTable中，此比值是非常大的。这也意味着，即使是在同一SSTable中，不同区域之间也存在很严重的访问倾斜。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F3.png" alt="image-20220318210059442"></p><p>因此，可以通过调整Bloom Filter，根据SSTable或者SSTable的区域的热度来调整bits-per-key，在不增加额外内存空间的基础上减少FPR。</p><h2 id="0x20-Design"><a href="#0x20-Design" class="headerlink" title="0x20 Design"></a>0x20 Design</h2><p>ElasticBF的架构图如图4所示，包括三个部分：</p><ul><li>fine-grained Bloom filter allocation；</li><li> hotness identification and inheritance；</li><li>Bloom filter management in memory；</li></ul><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F4.png" alt="image-20220318212024736"></p><h3 id="0x21-Fine-grained-Bloom-Filter-Allocation"><a href="#0x21-Fine-grained-Bloom-Filter-Allocation" class="headerlink" title="0x21 Fine-grained Bloom Filter Allocation"></a>0x21 Fine-grained Bloom Filter Allocation</h3><p>可以通过减少Bloom Filter 的FP所造成的额外I/O来提高KV Store的读性能。下面将分析如何为SSTable构建多个Bloom Filter，并根据热度动态调整Bloom Filter以减少FP。</p><h4 id="Construction-of-multiple-Bloom-filters"><a href="#Construction-of-multiple-Bloom-filters" class="headerlink" title="Construction of multiple Bloom filters"></a>Construction of multiple Bloom filters</h4><p>ElasticBF为每个SSTable生成多个具有较少bits-per-key的Bloom Filter，每个Bloom Filter采用不同且独立的哈希函数。Elastic将每个Bloom Filter称为filter unit，单个SSTable的所有filter unit构成一个filter group，如图5所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F.png" alt="image-20220318213054052"></p><p>一个Filter Group的FPR等于具有相同bits-per-key的单个Bloom Filter（$(0.618^{b/n})^n = 0.618^b$）。</p><h4 id="Finer-grained-design-with-chunking"><a href="#Finer-grained-design-with-chunking" class="headerlink" title="Finer-grained design with chunking"></a>Finer-grained design with chunking</h4><p>前面提到，即使是在同一SSTable中也存在很严重的访问倾斜，因此可以通过进一步区分同一SSTable中不同key的访问热度来减少FP。但是记录每个key的热度会带来很大的CPU和内存开销。权衡之下，将每个SSTable划分为多个区域，每个区域称为segment，以segment的粒度来计算访问热度。如图7所示，每个segment分配一组filter unit。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F7.png" alt="image-20220318214244025"></p><p>需要注意的是，segment的大小设置很重要，过于大了体现不出热度区分，过于小了开销太大。</p><h3 id="0x22-Hotness-Identification-and-Inheritance"><a href="#0x22-Hotness-Identification-and-Inheritance" class="headerlink" title="0x22 Hotness Identification and Inheritance"></a>0x22 Hotness Identification and Inheritance</h3><h4 id="Hotness-identification"><a href="#Hotness-identification" class="headerlink" title="Hotness identification"></a>Hotness identification</h4><p>segment的热度主要由其访问频率和自上次访问以来的持续时间所决定。</p><p>文章提出了一个expiring policy策略来区分segment的cold或hot。该策略表述如下。</p><p>维持一个名为currentTime的全局变量，代表整个KV Store的Get请求次数。每个Segment关联一个expiredTime，表示其被「expired」的时间。$expiredTime = lastAccessedTime + lifeTime$，lastAccessedTime表示其上次被访问的时间，lifeTime是个固定值。每当一个segment被访问时，currentTime加1，并更新该segment的lastAccessedTime，进而更新其expiredTime。</p><p>当currentTime超过一个segment的expiredTime时，该segment被标记为「expired」。也就是，当一个segment在最近的lifeTime次请求中没有被访问时，其被标记为「expired」，也即认为该segment的cold的。</p><h4 id="Hotness-inheritance-after-compaction"><a href="#Hotness-inheritance-after-compaction" class="headerlink" title="Hotness inheritance after compaction"></a>Hotness inheritance after compaction</h4><p>Compaction操作会对SSTable执行归并排序生成新的SSTable。因此，如何对新的SSTable中的Segment热度进行初始化是个很重要的问题。</p><p>Elastic使用旧的segment的热度来估计新的segmented热度，其计算方法如图8所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F8.png" alt="image-20220318220340377"></p><h3 id="0x23-Bloom-Filter-Management-in-Memory"><a href="#0x23-Bloom-Filter-Management-in-Memory" class="headerlink" title="0x23 Bloom Filter Management in Memory"></a>0x23 Bloom Filter Management in Memory</h3><p>本小节描述如何管理segment的filter unit。</p><h4 id="Bloom-filter-adjusting-rule"><a href="#Bloom-filter-adjusting-rule" class="headerlink" title="Bloom filter adjusting rule"></a>Bloom filter adjusting rule</h4><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-M1.png" alt="image-20220318220706788"></p><ul><li>E[Extra IO]表示由于FP所导致的预计额外IO次数，来指导Bloom Filter的调整；</li><li>M表示KV Store的总segment数量；</li><li>$f_i$表示segment $i$的访问频率；</li><li>$r_i$表示segment $i$的FPR；</li></ul><p>当一个segment被访问时，更新其访问频率和E[Extra IO]。检查是否可以通过enable某个segment的filter unit并disable其他某个segment的filter unit，在不增加内存占用的情况下减少E[Extra IO]，若可行，则应用该调整。</p><h4 id="Realizing-dynamic-adjustment-with-Multi-Queue"><a href="#Realizing-dynamic-adjustment-with-Multi-Queue" class="headerlink" title="Realizing dynamic adjustment with Multi-Queue"></a>Realizing dynamic adjustment with Multi-Queue</h4><p>如图9所示，ElasticBF在内存中维持一个LRU队列来管理每个segment的元数据。将这些队列依次命名为$Q_0,…Q_n$，其中n表示每个segment可以分配的filter unit数量上限，$Q_i$表示该队列中的segment有$i$个enabled filter unit。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic2-F9.png" alt="image-20220318221906124"></p><p>查找哪个filter unit应该被disable的步骤如下：</p><ul><li>首先，从$Q_m$到$Q_1$查找「expired」segment；</li><li>然后再从每个队列的LRU侧向MRU侧查找；</li><li>找到「expired」segment后检查是否可以通过disable它的filter unit来减少E[Extra IO]，若可行则释放它的一个filter unit，并将其降到下一层队列中；</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticBF:Fine-grained and Elastic Bloom Filter Towards Efficient Read for LSM-tree-based KV Stores</title>
    <link href="/2022/03/16/%E8%AF%BB%E8%AE%BA%E6%96%87/ElasticBF/"/>
    <url>/2022/03/16/%E8%AF%BB%E8%AE%BA%E6%96%87/ElasticBF/</url>
    
    <content type="html"><![CDATA[<h2 id="0x10-Background"><a href="#0x10-Background" class="headerlink" title="0x10 Background"></a>0x10 Background</h2><p>在键值数据库中，Bloom Filter通常用来减少读操作中的I/O次数。在LevelDB中，每个SSTable都有一个关联的Bloom Filter。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/ElasticBF-F2.png" alt="image-20220315201539916"></p><p>图2展示了两种不同的工作负载下的文件访问频率。</p><p>可以看到，随着Level的增加，文件的访问频率在降低，因为越高的Level拥有越多的SSTable，访问的SSTable也会增加。</p><p>因此，lower level的SSTable相比heigher level的SSTable需要更低的误报率（False Positive Rate，FPR）。</p><p><a href="https://stratos.seas.harvard.edu/files/stratos/files/monkeykeyvaluestore.pdf">Monkey</a>通过在lower level上为每个Bloom Filter增加更多的bits-per-key来最大化均匀数据分布下的读操作吞吐量。但是，该论文指出，即使是在同一Level中，SSTable的访问频率不一致也是非常普遍的，显然Monkey并没有考虑这种同一Level中的数据访问倾斜。</p><p>因此，从访问局部性的角度来看，为同一Level中不同SSTable的Bloom Filter分配相同的bits-per-key显然不是有效的做法。</p><p>所以，对Hot-SSTable的Bloom Filter分配更多的bits-per-key，并对Cold-SSTable的Bloom Filter减少bits-per-key，可以在占用相同内存空间的情况下减少FPR。</p><h2 id="0x20-ElasticBF"><a href="#0x20-ElasticBF" class="headerlink" title="0x20 ElasticBF"></a>0x20 ElasticBF</h2><h3 id="0x21-Main-Idea"><a href="#0x21-Main-Idea" class="headerlink" title="0x21 Main Idea"></a>0x21 Main Idea</h3><p>Hot-SSTable的数量要远小于Cold-SSTable的数量，因此，可以通过增加Hot-SSTable对应的BF的bits-per-key来减少FP，进而减少由于FP所带来的额外I/O数。</p><p>同时，还可以通过减少Cold-SSTable的BF的bits-per-key来控制整体BF所占用的内存空间。</p><p>问题在于，为每个Filter所分配的bits-per-key是固定大小的，且一旦生成Filter便无法再对其进行调整。因此，无法在运行时态去动态调整Filter的bits-per-key。</p><p>为了解决以上问题，该论文选择在构建每个SSTable时为其分配多个Filter，每个Filter为其分配较少的bits-per-key，将其称为Filter Unit。可以通过使一些Filter Unit生效并将其加载到内存中，或关闭部分Filter unit并将其移出内存，来动态调整每个SSTable的Filter数量（也可以说成调整Filter大小）。</p><p>通过这种方法，能够弹性的去动态调整bits-per-key或着说是FPR，该论文将该实现称为ElasticBF。</p><p>在ElasticBF中，每个SSTable在初始化是为其分配多个Filter Unit，每个Filter Unit采用不同的哈希函数，Filter Unit按顺序放在SSTable的元数据区域。一个SSTable的所有Filter Unit合称为一个Filter Group。</p><p>ElasticBF的结构如图3所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic-F3.png" alt="image-20220315215434714"></p><p>因为在一个Filter Group中的所有Filter Unit是相互独立的，因此在查询key时，只要有一个Filter Unit指示不存在此key，便能确定所属SSTable不含此key。只有当所有的Filter Unit都指示可能包含时才会进一步查询。</p><p>假设每个Filter Unit是一个具有b/n bits-per-key的过滤器，所以他的FPR可以表示为$0.618^{b/n}$ ，又因为各个Filter Unit是相互独立的，所以一个具有n个Filter Unit的Filter Group的FPR为$(0.618^{b/n})^n = 0.618^b$。</p><p>所以，我们可以得出结论，一个总共具有b bits-per-key的Filter Group与具有b bits-per-key的单个Filter Bloom有相同的FPR。</p><p>将ElasticBF部署在KV Store 中主要有两个挑战：</p><ul><li><ol><li>如何设计一个调整规则来为每个SSTable选择合适的Filter Unit数量；</li></ol></li><li><ol start="2"><li>如何以较小的开销实现动态调整；</li></ol></li></ul><h3 id="0x22-Adjusting-Rule"><a href="#0x22-Adjusting-Rule" class="headerlink" title="0x22 Adjusting Rule"></a>0x22 Adjusting Rule</h3><p>为SSTable调整Bloom Filter的目标是减少FP（False Positive）所带来的额外I/O开销。因此该论文文使用一个Metric来指导调整Filter Unit，该Metric被定义为FP所带来的预计I/O次数，也即E[Extra_IO]，具体可表示为：</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic-M1.png" alt="image-20220316084351908"></p><ul><li>n 表示KV Store中的SSTable总数量；</li><li>$f_i$表示SSTable i的访问频率；</li><li>$fp_i$表示FPR，它由SSTable i被加载到内存中的Filter Unit的数量所决定；</li></ul><p>ElasticBF仅当在不多占用内存空间且可以减少E[Extra_IO]时才会去为每个SSTable调整其Filter Unit数量。</p><p>在使用相同大小的Bloom Filter时，访问频率较高的SSTable贡献了更多的E[Extra_IO]。因此在固定内存空间大小的情况下减少E[Extra_IO]就需要为Hot-SSTable分配更多的Filter Unit。</p><p>调整BF的步骤如下：</p><ol><li>当一个SSTable被访问时，将他的访问频率加1，并更新E[Extra_IO]；</li><li>检查是否可以通过enable此SSTable的Filter Unit数量，并disable其他SSTable同等数量Filter Unit的前提下减少E[Extra_IO]，也即在不增加内存空间的情况下通过合理调整不同SSTable的Filter Unit数量来减少I/O开销；</li></ol><p>然而这又带来了新的问题，也即如何在不增加开销的情况下快速寻找哪些Filter Unit可以被disable。</p><h3 id="0x23-Dynamic-Adjustment-with-MQ"><a href="#0x23-Dynamic-Adjustment-with-MQ" class="headerlink" title="0x23 Dynamic Adjustment with MQ"></a>0x23 Dynamic Adjustment with MQ</h3><p>如图4所示，该论文维护了多个LRU（Least-Recently-Used）队列来管理每个SSTable的元数据，这些队列被依次命名为$Q_0,…, Q_m$，m是SSTable被分配的Filter Unit数量上限。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/Elastic-F4.png" alt="image-20220316192852860"></p><p>需要注意的是，Filter Group中的所有Filter Unit和SSTable中的其他数据都存储在磁盘中，但并不是所有的Filter Unit都是enable的，只有enabled的Filter Unit才会被用于执行key-existence检查。</p><p>LRU队列中的每个元素都与一个SSTable关联，并记录了该SSTable的元数据，其中就包含其驻于内存中的enabled filter units。$Q_i$管理enabled filter unit的数量为$i$的SSTable，例如$Q_2$中的每个SSTable都有两个enabled filter unit。</p><p>为了确定哪个filter unit应该被disable并将其移出内存，本文采用了一个「expiring」策略。该策略将MQ中的每个item都与一个名为expiredTime的变量关联，该变量表示相应的SSTable应该变为expired，并需要选择一个SSTable来调整其BF的时间点。</p><p>具体来讲，$expiredTime = currentTime + lifeTime$，其中$currentTime$表示到目前为止KV Store的$Get$请求总数，$lifeTime$是一个固定值（实践表明ElasticBF对其取值并不敏感）。</p><p>根据以上定义，当一个SSTable被插入到一个队列时，其$expiredTime$被初始化为$currentTime+lifeTime$。并且，每当读到该SSTable时，其$expiredTime$值都会根据当前的$currentTime$值进行更新。</p><p>当$currentTime$大于某个SSTable的$expiredTime$时，其被标记为expired，这意味在其$liftTime$期间未被访问，此时该SSTable被视为Cold-SSTable，并且将会disable它的部分Filter Unit。</p><p>对于每次访问，我们根据原始的MQ算法来寻找「expired」SStable。为了避免「expired」SSTabkle仍然有大量的enabled filter unit，我们将会垂直按照$Q_m$到$Q_1$，水平按照从LRU到MRU的顺序来查找「expired」 SSTable。当找到一个「expired」SSTable后将会disable它的一个Filter Unit，并将其移到下一层的队列中。重复以上步骤，直到找到足够的内存空间来将Hot-SSTable的Filter Unit加载到内存。若是找不到足够的内存空间则跳过此次调整。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>REMIX:Efficient Range Query for LSM-trees</title>
    <link href="/2021/12/15/%E8%AF%BB%E8%AE%BA%E6%96%87/REMIX:%20Efficient%20Range%20Query%20for%20LSM-trees/"/>
    <url>/2021/12/15/%E8%AF%BB%E8%AE%BA%E6%96%87/REMIX:%20Efficient%20Range%20Query%20for%20LSM-trees/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h2><p>LSM树在内存中缓存数据的更新，并周期性的将它们刷新到磁盘上，生成不可变的table文件，完成数据持久化。但是这也降低了查询效率，因为一个range中的key可能在不同的table文件中，并且由于较高的计算和I/O成本，这可能会潜在的降低查询速度。</p><p>学术界针对此问题已经做了大量工作来加快查询性能。为了加快点查询，每个table文件通常都与内存中的一个布隆过滤器相关联，以此来跳过不含目标key的table文件。但是布隆过滤器不能处理范围查询。</p><p>为了限制查询请求不得不访问的table数量，LSM树会在后台运行一个Compaction线程来不断对table进行归并排序。其中table的选择由Compaction策略来决定。</p><h4 id="Leveled-Compaction"><a href="#Leveled-Compaction" class="headerlink" title="Leveled Compaction"></a>Leveled Compaction</h4><p>Leveled Compaction策略被包括LevelDB和RocksDB在内的大量KV-Store使用。Leveled Compaction将多个较小的有序run归并排序为一个较大的有序run，以保证存在重叠的table文件数量小于指定的阈值。Leveled Compaction通过如上策略提供了较高的读效率，但因为其密集的归并排序策略，这也带来了比较高的「写放大」（Write Amplification，WA）。</p><h4 id="Tiered-Compaction"><a href="#Tiered-Compaction" class="headerlink" title="Tiered Compaction"></a>Tiered Compaction</h4><p>Tiered Compaction压缩策略等待多个大小相似的有序run，将它们合并为一个更大的run。其提供了更低的WA和更高的吞吐量，被Cassandra和ScyllaDB等KV-Store使用。但是Tiered Compaction不能有效降低存在key重叠的table数量，与Leveled Compaction相比这会带来更高的查询成本。</p><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>其他的一些压缩策略虽然能比较好的平衡读写性能，但都没能同时实现高效的读写性能。</p><p>主要问题在于，为了限制有序run的数量，KV-Store必须进行归并排序和重写数据。<strong>现在的存储技术已经大大提高了随机读的性能。</strong>例如，对于Flash SSD来说，随机读的速度能达到顺序读速度的50%。例如3D-XPoint等新技术，为随机读和顺序读提供了几乎相同的性能。<strong>因此，KV-pairs不需要为了快速访问而进行物理排序；相反，KV-Store可以通过逻辑排序来提供高效的点查询和范围查询，以避免大量的重写操作。</strong></p><p>为此，本文设计了REMIX（Range-query-Efficient Multi-table Index）。传统的解决方案为了提高range query效率而在物理数据重写和昂贵的归并排序之间挣扎，而REMIX利用了节省空间的数据结构来记录跨多个table文件的全局排序视图。通过使用REMIXes，LSM-KVS可以在不牺牲查询性能的前提下，使用具有高写效率的压缩策略。</p><h2 id="0x10-Background"><a href="#0x10-Background" class="headerlink" title="0x10 Background"></a>0x10 Background</h2><p>LSM树是为了在持久化存储设备上实现高效的写速率而设计的。它将所有的更新缓存在内存中一个称为MemTable的数据结构中，以此来实现高效的写性能。</p><ul><li>minor compaction：当MemTable写满后，LSM树会通过minor compaction操作将缓存的所有key进行排序，并将其作为一个run刷新（flush）到持久化的存储设备上。此操作不需要对存储设备上的现有数据进行合并，只需要批量顺序写入，因此实现了高效写性能；</li><li>major compaction：有序的run之间可能会存在重叠的key范围，这时一个点查询（point query）就不得不去检查所有可能的run，这带来了较大的查询开销。为了限制存在重叠的run的数量，LSM树通过major compaction操作将几个存在重叠的run归并排序为一个run。</li></ul><p>压缩策略（compaction strategy）决定了如何选择table进行major compaction。最流行的两种压缩策略是leveled compaction和tiered compaction：</p><p><strong>leveled compaction</strong> ：</p><p>使用此方法的数据库具有多层的结构，每层都维持一个由一个或多个table组成的有序run。其中某一个Level $L_n$的容量是其前一个Level $L_{n-1}$的几倍（通常是10），这使得一个庞大的KV-store被组织为仅有几个Level组成（通常是5～7个）。Leveled Compaction带来了相对高效的读性能，但也会造成写性能较差。Leveled Compaction从相邻的Level（例如$L_n$和$L_{n+1}$）中选择重叠的table进行合并，并在较大的Level（例如$L_{n+1}$）中生成新的table。因为不同Level之间的容量呈指数级增长，因此一个table的键范围通常与下一个Level的多个table重叠。因此大多数写操作是在$L_{n+1}$中重写已有的数据，这在实践中导致了高达40倍的高「写放大比」（write amplification ratio， WA ratio，即实际写入磁盘的数据量与用户请求写入的数据量的比值）。</p><p>图1展示了一个Leveled Compaction的例子，每个table包含1～2个key。如果$L_1$中的第一个table被选择与$L_2$中的前两个table进行归并排序，那么$L_2$中的5个key将被重写（也即<code>table(4,21,38)</code>要与<code>table(6,26)</code>和<code>table(31,40,46)</code>进行归并排序，此时$L_2$两个table中的5个key都需要重写）。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_1.png" alt="image-20211213113120768"></p><p><strong>tired compaction</strong>:</p><p>如图2所示，在使用tired compaction的LSM树中，<strong>在一个level中可以缓存多个存在重叠的有序run</strong>。通常，一个level中run的数量会通过一个阈值$T$来限制（$T&gt;1$）。如果在一个level（例如$L_n$）中的有序run的数量超过阈值$T$，那么**$L_n$中的所有run会被归并排序为$L_{n+1}$中的一个新的run，$L_{n+1}$中的数据不会被重写**。因此，在使用tired compaction的LSM树中，写放大比为$O(L)$，其中$L$是level的数量。但是，由于在每个level中可能会有多个重叠的有序run，一个点查询（point query）可能会需要去检查$T\times L$个table，这也导致了更低的查询性能。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_2.png" alt="image-20211213143711989"></p><p>LevelDB和RocksDB中的范围查询是通过使用一个迭代器结构在多个table中导航实现的，就好像所有的key都在一个有序run中。一个范围查询首先会使用带有搜索键（seek key，也即目标key范围的下边界）的搜索操作（seek operation）来初始化迭代器。「查找操作」首先定位迭代器，使其指向存储中大于等于seek key的最小key，这表示范围查询的目标key。next操作会往前推进迭代器，使其指向有序run中的下一个key。因此，可以使用一系列next操作来检索目标范围内的key，直到满足某个条件（例如达到查询的数量或者到达查询范围的末尾）。由于有序run是按时间顺序生成的，因此一个目标key可能会在任何一个run中，相应的，迭代器必须追踪所有的有序run。</p><p>图1展示了一个使用leveled compaction的LSM树的查找示例。为了查找key 67，需要在每个run中使用二分查找来识别满足$key \geq seek,key$的最小key。每个识别的key都用一个光标（cursor）来标记。然后使用最小堆结果来对这些键进行归并排序，从而选择$L_2$中的key 67。随后，每个next操作都会比较光标标记下的key，返回其中最小的一个key，然后向前移动其对应的光标。如图1右上角所示，此过程会呈现key的全局排序视图。在图1的例子中，所有的3个level都会被访问以进行归并排序。图2使用的是tired compaction，但查询过程类似，不过在这个例子中有6个run需要被访问，其查找代价相对更大。</p><h2 id="0x20-REMIX"><a href="#0x20-REMIX" class="headerlink" title="0x20 REMIX"></a>0x20 REMIX</h2><p>对多个有序run的范围查询会动态构建底层table的排序视图，以便可以按照排序顺序来检索key。事实上，排序视图继承了table文件的不变性，并会在任何table被删除或替代前保持有效。然而现有的基于LSM的KV-Store并没有利用这种不变性的特点，排序视图会在查询时反复重建和丢弃，这会带来密集的计算和I/O操作并导致较差的查找性能。</p><p>REMIX的动机是利用table文件的不变性，保留底层table文件的排序视图，以在将来的查询操作中重用它们。</p><p>如果记录每个key及其位置来保留排序视图，则存储的元数据可能会显著膨胀，从而导致读写性能受损。因此，为了避免这个问题，REMIX的数据结构必须是空间高效的。</p><h3 id="0x21-The-REMIX-Data-Structure"><a href="#0x21-The-REMIX-Data-Structure" class="headerlink" title="0x21 The REMIX Data Structure"></a>0x21 The REMIX Data Structure</h3><p>图3上部展示了一个由三个run组成的排序视图的示例，排序视图用向量将15个key连接起来。</p><p>为了构建一个REMIX，首先将排序视图的key划分到多个segment中，每个segment都包含固定数量的key。</p><p>每个segment都与一个<code>anchor key</code>，一组<code>cursor offset</code>以及一组<code>run selectors</code>关联。其中：</p><ul><li>anchor key：表示segment中的最小key；</li><li>cursors offsets：所有cursor共同组成了排序视图上的稀疏索引，每个cursor offset都与一个run对应，并记录了此run中大于等于anchor key的最小key；</li><li>run selectors：segment中的每个key都有一个对应的run selector，run selector用来指示对应的key位于哪个run上；</li></ul><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_3.png" alt="image-20211213163458320"></p><p>REMIX的迭代器不使用最小堆。在REMIX中，一个迭代器包含「一组cursor」和「一个current pointer」。</p><ul><li>cursors：每个cursor都与一个run相关联，并指向该run中一个key的位置。</li><li>current pointer：选择并指向一个run selector，该run的cursor决定了此时到达的key；</li></ul><p>在REMIX中，使用一个迭代器来查找一个key需要三步：</p><ol><li>找到target segment。在anchor keys上执行二分查找，以确定包含seek key的target segment，也即找到满足anchor_key$\leq$seek_key的segment；</li><li>初始化迭代器。将迭代器初始化为指向anchor key。具体来说就是，用target segment的cursor offsets来初始化迭代器的cursors，并将迭代器的current pointer指向target segment的第一个run selector；</li><li>可以通过线性扫描有序视图来查找 target key。为了移动迭代器，将当前key的cursor前进以跳过当前key，同时，current pointer也需要前进以指向下一个run selector；</li></ol><p>来看一个例子。如图3所示，底部的四个方框代表编码了有序视图的REMIX元数据（需要注意的是括号中的key并不是元数据的一部分）。查找key 17的操作如下：</p><ol><li>查找target segment。通过二分查找，第二个segment被选中，其包含的key为<code>(11,17,23,29)</code>。</li><li>初始化迭代器。根据target segment的cursors offset，也即<code>(1,2,1)</code>，将迭代器的cursors放在$R_0$、$R_1$和$R_2$的键11、17和31上；与此同时，将迭代器的current pointer设置为指向target segment的第一个run selector（图中的第5个run selector，也就是第二个segment的第一个run selector，为0，指向的是第一个run），这意味着current key也即key 11在$R_0$的cursor所在的位置。</li><li>current key 11小于17，迭代器需要向前移动，以查找下一个满足$k\geq17$的最小key。为了向前移动迭代器，$R_0$的cursor向前移动跳过key 11，停在key 23上，此时迭代器的cursors offset为<code>(2,2,2)</code>；然后current pointer向前移动到target segment的第二个run selector（图中的第6个run selector，也就是第二个segment的第二个run selector，为1，指向的是第二个run）。重复此操作最终找到目标key。</li></ol><h3 id="0x22-Efficient-Search-in-a-Segment"><a href="#0x22-Efficient-Search-in-a-Segment" class="headerlink" title="0x22 Efficient Search in a Segment"></a>0x22 Efficient Search in a Segment</h3><p>seek操作通过在anchor keys上执行二分查找来定位target segment以初始化迭代器，然后再在有序视图上向前扫描来查找target key。显然，增加segment的大小能减少anchor key的数量，并进一步加速二分查找。但这也会降低查找target key的速度，因为需要在一个更大的target segment上访问更多的key来查找target key。</p><p>为了解决潜在的性能问题，REMIX在target segment中也使用二分查找来最小化查找开销。</p><p>目前为止，使用二分查找的地方有：</p><ul><li>anchor keys之间：在anchor keys上执行二分查找来定位target segment；</li><li>target segment内部：在target segment上执行二分查找来定位target key；</li></ul><p>但是，<strong>要在segment上使用二分查找则必须能随机访问segment中的每个key</strong>。</p><p>由上文可知，segment中的每个key属于一个run，并用run selector指示其所在的run。为了访问一个key，我们需要将run的cursor放在正确的位置上，可以通过计算在「该key之前」并「与其相同的run selector的出现次数」，然后将cursor移动相应的次数来将cursor放置到正确的位置上。通过这种类似数组的访问模式，我们可以实现segment中每个key的随机访问。</p><p>图4展示了一个有16个key的segment，所有的key位于不同的4个run上。Run Selectors下面的Occurrences表示该segment中某个key之前还有多少个key与它位于同一个run中。例如，key 41是该segment中位于$R_3$上的第3个key，也即在key 41之前还有2个key位于$R_3$上（key 5和key 23），所以其Occurrences值为2。要查找访问 key 41，我们只需要初始化$R_3$的cursor offset，然后向前移动两次跳过key 5和key 23即可，这便实现了key 41的随机访问。</p><p>简单记录一个segment中二分查找的过程，还是例如要查找key 41，过程如下：</p><ol><li>第一次执行二分查找。需要检索的是该segment中的第8个key（总共16个key，所以第一次检索第8个key），该key对应的run selector为3，occurrence值为3，然后初始化$R_3$的cursor offset，然后向前移动3次即可访问该key，该key为43。该key不是我们要找的key 41，且大于key 41；</li><li>第二次执行二分查找。由第一次可知，需要在segment中的第1～7个key进行二分查找，因此第二次二分查找需要检索第4个key，该key对应的run selector为2，occurrence为0，初始化$R_2$的cursor offset，向前移动0次即可访问该key，该key为31，仍不是要查找的key。</li><li>第三次执行二分查找。方法同上，本次检索第6个key，仍不是要查找的key。</li><li>第四次执行二分查找。方法同上，本次检索第7个key，是本次查找的target key，查找结束。</li></ol><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_4.png" alt="image-20211214102822250"></p><p>在segment中使用二分查找可以减少查找过程中key比较的次数，但是，查找路径中的key可能位于不同的run上，而若相应的block没有被缓存的话则必须通过独立的I/O请求来读取这些key。例如，我们上面的查找例子中，只需要进行4次二分查找也即需要比较4次，但是需要访问3个run（4次比较中的key位于3个不同的run上）。事实上，很有可能该segment中位于同一个run上的几个key可能在同一个block中，因此，在一次比较完成后，移动到下一个run之前，可以通过比较该run上位于同一个block中的key来进一步缩小查找区间。例如，假设$R_3$中的key 41和key 43位于同一个block中，且我们要查找的target key也是key 43，则第一次需要检索key 41进行比较，比较完成后，在移动到$R_0$上访问Key 71比较之前，可以顺便比较一下与它位于同一block中的key 43，而这个key正好是我们需要的target key，此次访问直接将查找区间缩小到了target key。</p><h3 id="0x23-Search-Efficiency"><a href="#0x23-Search-Efficiency" class="headerlink" title="0x23 Search Efficiency"></a>0x23 Search Efficiency</h3><p>REMIX在以下三个方面改进了范围查询：</p><ul><li>REMIX使用二分查找来定位target key。REMIX提供了一个由多个run组成的全局视图，只需要一个二分查找就可以在该全局视图中定位到target key。</li><li>REMIX移动迭代器时不需要key的比较。REMIX通过使用预先记录的run selector来更新迭代器的cursors和current pointer，可以直接切换到下一个KV对。此过程不需要任何的key比较。相比之下，传统LSM-KVS的迭代器会维护一个最小堆，以对来自多个重叠run的key进行归并排序，在这种情况下，一个next操作需要从多个run中读取key进行比较。</li><li>REMIX会跳过不在查找路径中的run。seek操作会在target segment中执行二分查找，而且在查询时仅会访问那些包含查找路径上的key的run。</li></ul><p>此外，显著降低的查询成本允许在不使用布隆过滤器的情况下对由REMIX索引的多个有序run进行高效的点查询。</p><h3 id="0x24-REMIX-Storage-Cost"><a href="#0x24-REMIX-Storage-Cost" class="headerlink" title="0x24 REMIX Storage Cost"></a>0x24 REMIX Storage Cost</h3><p>REMIX的元数据由三个组件组成：anchor keys、cursor offsets、run selectors。为了对其存储成本进行评估，现给出如下定义：</p><ul><li>$D$表示一个segment中最多能包含的key的数量，因为每个key都有一个对应的run selector，那么run selector的数量相应的也为D；</li><li>$S$表示cursor offset的大小，单位为字节；</li><li>$H$表示被REMIX索引的run的数量；</li><li>$\bar{L}$表示anchor key的平均大小，单位为字节；</li></ul><p>由上面的定义可得：</p><ul><li>$S \times H$ 表示一个segment中所有的cursor offset所占用的空间大小，单位为字节；</li><li>$\left \lceil log_2(H) \right \rceil/8$ 表示一个run selector所占用的空间大小，单位为字节；</li><li>$D \times \left \lceil log_2(H) \right \rceil/8$ 表示一个segment中所有run selector所占用的空间大小，单位为字节；</li></ul><p>那么由上面的定义和推理可得，REMIX中各个组件占用的空间大小为（单位为字节）：</p><ul><li>anchor keys ：$\bar{L}$个字节；</li><li>cursor offsets：$SH$个字节；</li><li>run selectors：$D \times \left \lceil log_2(H) \right \rceil/8$个字节</li></ul><p>将REMIX所占用的总空间大小摊分到每个key上（也即将占用总空间大小除D），则每个key所额外占用的空间大小为：<br>$$<br>(\bar{L}+SH)/D + \left \lceil log_2(H) \right \rceil/8<br>$$<br>表1展示了在不同工作负载（$D$，也即segment中的key数量不同）下的REMIX空间开销。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_T_1.png" alt="image-20211214203246297"></p><h2 id="0x30-RemixDB"><a href="#0x30-RemixDB" class="headerlink" title="0x30 RemixDB"></a>0x30 RemixDB</h2><p>为了评估REMIX的性能，本文设计实现了一个名为RemixDB的LSM-KVS。RemixDB为了实现最好的的读性能而采用了tiered compaction。现实世界中的工作负载通常表现出高空间局部性。最近的研究表明，分区存储布局可以有效降低实际工作负载下的压缩成本。RemixDB采用了这种方法，将key空间划分到多个不重叠的分区中。每个分区中的table文件由一个REMIX进行索引，以提供分区的排序视图。通过这种方式，RemixDB本质上是一个使用tiered compaction的单层LSM树。RemixDB不仅继承了tiered compaction的写效率，而且在REMIXes的帮助下实现了高效读性能。</p><p>图5显示了RemixDB的系统组件。分区中的压缩会创建一个新版本的分区，其中包含新旧table文件和新的REMIX文件，旧版本在压缩后会被垃圾回收。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_5.png" alt="image-20211214210216968"></p><p>在多层LSM树的设计中，一个MemTable的大小通常只有几十MB，接近SSTable的默认大小。而在分区存储布局中，更大的MemTable可以在触发压缩前吸收更多的更新，这能帮助降低WA（写放大，Write Amplification），且MemTable和WAL的空间成本几乎不变，考虑到现在数据中心的大内存和存储，这是适中的。在RemixDB中，MemTable的最大大小被设置为4GB。</p><h3 id="0x31-The-Structures-of-RemixDB-Files"><a href="#0x31-The-Structures-of-RemixDB-Files" class="headerlink" title="0x31 The Structures of RemixDB Files"></a>0x31 The Structures of RemixDB Files</h3><h4 id="Table-Files"><a href="#Table-Files" class="headerlink" title="Table Files"></a>Table Files</h4><p>图6显示了RemixDB中的table文件格式。</p><ul><li>data block的默认大小为4Kb；</li><li>无法存放在一个data block中的大KV对会存放在整数倍的data block中；</li><li>每个data block在其首部都有一个记录KV数据偏移量的数组，以随机访问它所存储的每个KV数据；</li><li>metadata block是由多个8-bit值所组成的数组，每个值记录了一个4KB的block中所存储的key的数量，因此一个block最多可以存储255个KV对；</li></ul><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_6.png" alt="image-20211214212026005"></p><h4 id="REMIX-Files"><a href="#REMIX-Files" class="headerlink" title="REMIX Files"></a>REMIX Files</h4><p>图7显示了RemixDB中的REMIX文件格式。</p><p>REMIX中的anchor keys被组织在一个类似B+树的不可变索引中，这有助于对anchor key进行二分查找。每个anchor key都与一个segment ID相关联，segment ID标识了该segment的cursor offsets和run selectors。cursor offset由16位的block index和8位的key index索引组成，如图7的blk-id和key-id所示。因为每个cursor offset都与一个run对应，所以图7中的每个segment的查找路径中都只有两个run。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_7.png" alt="image-20211214213100203"></p><p>一个key的多个版本可能存在于同一个分区的不同table文件中，范围查询必须跳过旧版本返回每个key的最新版本。因此，在REMIX中，一个key的多个版本在排序视图上从最新到最旧排序，并且每个run selector的最高位被保留以用来区分旧版本和新版本。在前向扫描过程中总是先遇到最新版本，通过检查run selector的最高位可以在不进行比较的情况下跳过旧版本。</p><h3 id="0x32-Compaction"><a href="#0x32-Compaction" class="headerlink" title="0x32 Compaction"></a>0x32 Compaction</h3><p>在每个分区中，压缩进程根据进入分区的「新数据的大小」和「现有table文件的布局」来估计压缩成本，然后根据该成本执行以下不同的操作：</p><ul><li>Abort：取消分区的压缩，并将新数据保留在MemTable和WAL中；</li><li>Minor Compaction：将新数据写入到一个或多个新的table中，而不重写现有的table文件；</li><li>Major Compaction：将新数据与部分或全部现有table文件合并；</li><li>Split Compaction：将新数据与所有现有数据合并，并将分区拆分为几个新分区；</li></ul><h4 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h4><p>compaction后，任何看到新table文件的分区都需要重建其REMIX。Minor Compaction后会在一个分区中创建一个小的table文件，这会导致REMIX的重建并带来高I/O开销。</p><p>为了减少I/O开销，如果预估的I/O开销大于阈值，RemixDB可以终止分区的压缩。在这种情况下新的KV数据会被继续保留在MemTable和WAL中，等待下一次压缩。</p><p>但是在极端的情况下，当RemixDB终止了大多数分区的压缩时，压缩过程将无法有效的将数据移动到分区中。为了避免这个问题，RemixDB进一步限制可以留在MemTable和WAL中的新数据的大小，如果超过MemTable大小的15%。因此，在达到此限制之前，RemixDB终止具有高I/O开销的压缩过程，达到上限之后不再继续终止，允许压缩。</p><h4 id="Minor-Compaction"><a href="#Minor-Compaction" class="headerlink" title="Minor Compaction"></a>Minor Compaction</h4><p>Minor Compaction将Immutable MemTable中的新KV数据写到分区的新table文件中，然后重建REMIX，这个过程不需要重写分区中现有的table文件。当压缩后的Table文件的数量（现有table加上新建table的数量）低于阈值T时，使用Minor Compaction，在RemixDB的实现中T为10。图8显示了一个minor compaction的例子。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_8.png" alt="image-20211215103811139"></p><h4 id="Major-Compaction"><a href="#Major-Compaction" class="headerlink" title="Major Compaction"></a>Major Compaction</h4><p>当分区中的table文件的预期数量超过阈值T时，进行Major Compaction，将现有的table文件归并排序为较少的table文件。随着table文件数量的减少，后面就可以执行minor compaction。Major Compaction的效率可以通过输入table文件的数量和输出table文件的数量之比来估计。</p><p>图9显示了一个Major Compaction的示例，新数据与现有的三个较小的table文件进行合并，合并后只创建了一个新的table文件，此时$ratio=3/1$。Major Compaction会选择可以产生最高输入输出比的方案进行压缩。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_9.png" alt="image-20211215105042707"></p><h4 id="Split-Compaction"><a href="#Split-Compaction" class="headerlink" title="Split Compaction"></a>Split Compaction</h4><p>当分区中充满了large table时，Major Compaction可能无法有效减少分区中的table数量，这可以通过较低的输入输出比来预测。在这种情况下，应该将分区拆分为多个分区，这样每个分区中的table文件数量都能大大减少。Split Compaction会将新数据与分区中的所有现有table文件进行合并，并生成新的table文件以形成多个新分区。图10显示了一个split compaction的例子。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/REMIX_F_10.png" alt="image-20211215105601167"></p><h3 id="0x33-Rebuilding-REMIXes"><a href="#0x33-Rebuilding-REMIXes" class="headerlink" title="0x33 Rebuilding REMIXes"></a>0x33 Rebuilding REMIXes</h3><p>在具有高空间局部性的现实世界工作负载下，分区存储布局可以有效的最小化压缩成本。具体来说，RemixDB可以在少数分区中吸收大部分更新，并且可以避免接受具有较少更新的分区中的压缩。但是，如果工作负载缺少空间局部性，则不可避免的会有大量分区在较少更新的情况下执行压缩。Tiered Compaction可以最大限度的减少这些分区中的写入，但是在分区中重建REMIX仍然需要读取现有的table。</p><p>在分区中重建REMIX时，现有table已经被现有的REMIX索引，并且可以将这些table视为一个有序run，因此，重建过程相当于对两个已排序的run进行归并排序，其中一个来自现有数据，另一个来自新数据。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++字符串输入的使用及混合数字读取可能出现的问题</title>
    <link href="/2021/12/10/C%E5%92%8CC++/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5/"/>
    <url>/2021/12/10/C%E5%92%8CC++/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-字符串输入"><a href="#0x00-字符串输入" class="headerlink" title="0x00 字符串输入"></a>0x00 字符串输入</h2><p><code>cin</code>使用空白来确定字符串的结束位置，这意味着<code>cin</code>在获取字符数组输入时只读取一个单词。读取该单词后，<code>cin</code>将该字符串放到数组中，并自动在结尾添加空字符<code>\0</code>。</p><p>注：C风格字符串以空字符结尾，空字符被写作<code>\0</code>，其ASCII码为0，用来标记字符串的结尾。</p><h2 id="0x10-每次读取一行字符串输入"><a href="#0x10-每次读取一行字符串输入" class="headerlink" title="0x10 每次读取一行字符串输入"></a>0x10 每次读取一行字符串输入</h2><p>大多时候，每次读取一个单词不是最好的选择。</p><p>头文件<code>istream</code>中的类（如<code>cin</code>）提供了一些面向「行」的类成员函数：<code>getline()</code>和<code>get()</code>。这两个函数都读取一行输入，直至到达换行符。然而，随后<code>getline()</code>将<strong>丢弃换行符</strong>，而<code>get()</code>将换行符<strong>保留在输入序列</strong>中。</p><h3 id="0x11-面向行的输入：getline"><a href="#0x11-面向行的输入：getline" class="headerlink" title="0x11 面向行的输入：getline()"></a>0x11 面向行的输入：<code>getline()</code></h3><p><code>getline()</code>函数读取整行，它使用通过<strong>回车键输入的换行符</strong>来确定输入结尾。要调用这个函数，可以使用<code>cin.getline()</code>。</p><p>该函数有两个参数：</p><ul><li>第一个参数是用来存储输入行的数组的名称；</li><li>第二个参数是要读取的字符数；</li></ul><p><code>getline()</code>成员函数在读取指定数目的字符或遇到换行符时停止读取。</p><p>例如，在使用该函数将姓名读取到一个包含20个元素的<code>name</code>数组时，可以这样使用: <code>cin.getline(name, 20);</code></p><h3 id="0x12-面向行的输入：get"><a href="#0x12-面向行的输入：get" class="headerlink" title="0x12 面向行的输入：get()"></a>0x12 面向行的输入：<code>get()</code></h3><p>cin类还有一个名为get()的成员函数，该函数有几种变体。</p><p>其中有一种变体的工作方式与getline()类似，它们接受的参数相同，解释参数的方式也一样，并且都读到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次使用get()：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">cin.<span class="hljs-built_in">get</span>(name1, len);<br>cin.<span class="hljs-built_in">get</span>(name2, len); <span class="hljs-comment">// 出现问题，上一个get将换行符留在了输入队列，导致此get看到的第一个字符就是换行符，不能继续读取想要读取的内容</span><br></code></pre></div></td></tr></table></figure><p>由于第一次调用后，将换行符留在了输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时，因为<code>get(name2，len)</code>并不能读取换行符，所以它会认为已经到达行尾了，并没有发现任何可以读取的内容。因此，如果不借助其他帮助，第二次调用将无法跨过换行符来读取内容。</p><p>而get()函数的另一种变体，使用不带任何参数的cin.get()调用可以读取下一字符（可以是换行符）。因此可以使用它来处理换行符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">cin.<span class="hljs-built_in">get</span>(name1, len);<br>cin.<span class="hljs-built_in">get</span>();  <span class="hljs-comment">// 读取换行符</span><br>cin.<span class="hljs-built_in">get</span>(name2, len); <br></code></pre></div></td></tr></table></figure><p>另一种方式是将两个类成员函数变体拼接起来，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">cin.<span class="hljs-built_in">get</span>(name1, len).cin.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 读取字符串后继续读取掉换行符</span><br>cin.<span class="hljs-built_in">get</span>(name2, len); <br></code></pre></div></td></tr></table></figure><p>之所以可以这样使用是因为<code>cin.get(name1, len)</code>返回一个<code>cin</code>对象，该对象可以用来继续调用<code>get()</code>函数。</p><h2 id="0x20-混合输入字符串和数字所带来的问题"><a href="#0x20-混合输入字符串和数字所带来的问题" class="headerlink" title="0x20 混合输入字符串和数字所带来的问题"></a>0x20 混合输入字符串和数字所带来的问题</h2><p>C++中混合输入<strong>面向行的字符串</strong>和<strong>数字</strong>会导致问题。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">char</span> name[<span class="hljs-number">30</span>];<br>cin&gt;&gt;age;<br>cin.<span class="hljs-built_in">getline</span>(name, <span class="hljs-number">30</span>);<br></code></pre></div></td></tr></table></figure><p>这样使用会导致<code>cin.getline()</code>读取到一个空字符串，原因在于当<code>cin</code>在读取<code>age</code>时会将回车键生成的换行符留在了输入队列，而后面的<code>cin.getline()</code>在看到换行符后，将认为这是一个空行，并将一个空字符串数组赋给<code>name</code>数组。</p><p>解决方法是：在使用<code>cin.getline(name, 30)</code>读取整行字符串之前，先使用<code>cin.get()</code>读取并丢弃换行符。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AC-Key:Adaptive Caching for LSM-based Key-Value Stores</title>
    <link href="/2021/12/10/%E8%AF%BB%E8%AE%BA%E6%96%87/AC-Key%E2%80%94%E2%80%94Adaptive%20Caching%20for%20LSM-based%20Key-Value%20Stores/"/>
    <url>/2021/12/10/%E8%AF%BB%E8%AE%BA%E6%96%87/AC-Key%E2%80%94%E2%80%94Adaptive%20Caching%20for%20LSM-based%20Key-Value%20Stores/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h2><p>大多数现有的KVS都采用了Log-Structured Merge(LSM) tree来提高写操作的性能，然而LSM的结构特性使得读操作的性能受到了很大的影响。当在多个Level中查找一个key时会引起多次磁盘的I/O操作，带来较大的性能开销。</p><p>而大部分工作负载都有访问局部性的特征，缓存便是利用这一特性来提高读操作性能的主要技术。针对企业级工作负载的研究发现，无论是「point lookup」还是「range query」都展现出了「hot spots」的现象。</p><p>因此，为基于LSM的KV-Store设计高性能的缓存方案主要有两个技术挑战：</p><ul><li>首先，LSM分层的设计使得缓存不同Level的KV数据所带来的收益不同，也即能够节省的磁盘I/O次数不同；</li><li>其次，两种读操作「point lookup」和「range query」对缓存的需求不一致。「Point lookup」更偏向于缓存一个「key-value pair」，这种方式相对节省空间；当value过大时，一种折中的方案是选择缓存「key- pointer pair」，也即缓存「key」和「value的磁盘指针」，指针相对value所占用的空间更小。而缓存单个零星的「key-value pair」无法为「range query」服务，因此只能通过缓存「block」来支持「range query」；</li></ul><p>因此，很难在缓存KV、KP和Block之间进行权衡，它们都有其各自适合的工作负载。此外，设计一种可以根据工作负载进行自适应的缓存方案是困难的。</p><p>现有的缓存方案通常只选择缓存KV、KP和Block中的一种或两种，而且为每种缓存类型都分配了固定大小的缓存空间。因此，这些缓存方案无法适应多样的工作负载，也不能根据工作负载的变化来调整缓存空间的大小。此外，目前还没有针对LSM中特有的异构缓存成本的解决方案。</p><p>本文全面分析研究了对缓存KV、KP和Block之间的权衡，并提出了「 AC-Key, Adaptive Caching for LSM-based Key-Value Stores」来结合它们在面临各种工作负载时的优势。AC-Key为每种类型的条目（KV、KP和Block）都使用专门设计的单独缓存组件。每个缓存组件的大小可以根据文章提出的「 <em>hierarchical adaptive caching</em> algorithm，分层自适应缓存算法」进行调整（使用「ghost cache」来指导其大小调整）。</p><p>此外，AC- Key利用一种新颖的缓存效率因子来评估不同的<strong>缓存成本</strong>和<strong>收益</strong>，以指导<strong>不同缓存组件之间的边界调整</strong>以及<strong>缓存组件内部的替换策略</strong>。</p><h2 id="0x10-Background-amp-Related-work"><a href="#0x10-Background-amp-Related-work" class="headerlink" title="0x10 Background &amp; Related work"></a>0x10 Background &amp; Related work</h2><h3 id="0x11-LSM-Tree-Based-Key-Value-Store"><a href="#0x11-LSM-Tree-Based-Key-Value-Store" class="headerlink" title="0x11 LSM-Tree-Based Key-Value Store"></a>0x11 LSM-Tree-Based Key-Value Store</h3><p>基于LSM tree的Key-Value store（LSM- KVS）的流行实现，例如LevelDB和RocksDB，都由两部分组成：</p><ul><li>Memory Component，或者说MemTable，通常使用原地排序（in-place sorted）的数据结构来实现，例如「skip-list」或「$B^+$ tree」；</li><li>Storage Component，通常被实现为存储有序run（压缩的Key-Value对组成）的多层文件；</li></ul><p>如图1所示，每个Level被划分为多个「sorted string table files」也即SSTs，每个SST都有配置的大小限制，通常为2MB～64MB。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_F_1.png" alt="image-20211210110007408"></p><p>除了$L_0$之外，每个Level都是一个单独的有序run，其中，SST之间具有不相交的key范围。在有序run中，一个SST的所有key-value对被划分到多个数据块（data block）中。SST中每两个相邻数据块之间的边界key存储在索引数据块（index block）中，索引数据块在SST中有相应的数据块偏移量（data block offset）。此外，每个SST还包含一个「bloom filter block」（BF block，布隆过滤块）来确定SST中是否存在某个key，以避免不必要的磁盘I/O操作。「Block」是LSM- KVS中的基本磁盘I/O单元。</p><p>在LSM-KVS中有两种类型的读操作，分别是「point-lookup」（也即<code>Get</code>）和「range query」（也即<code>Scan</code>）。<code>Get</code>按照下面的顺序来查找指定key的value：先是检查内存中的MemTable，然后是磁盘上$L_0$中从新到旧的每个SST，$L_0$中查找失败则继续查找$L_1$~$L_N$。</p><p>如果在内存MemTable中就找到了要找的key，则不需要任何的磁盘访问就可以返回相应的value。否则，则需要在磁盘组件中查询SST文件。查询SST时会先检查对应的布隆过滤器，如果布隆过滤器指示该SST不存在指定key的话则跳过此SST。反之，则读取索引块来定位key所在的具体数据块，最后读取相应数据块来查找此key。因此，在一个SST中查找一个key最多需要三次磁盘I/O操作：</p><ul><li>第一次读Bloom filter block；</li><li>第二次读Index block；</li><li>第三次读data block；</li></ul><h3 id="0x12-Related-Work"><a href="#0x12-Related-Work" class="headerlink" title="0x12 Related Work"></a>0x12 Related Work</h3><h4 id="a-Caching-Schemes-in-LSM-KVS-LSM-KVS中的缓存方案"><a href="#a-Caching-Schemes-in-LSM-KVS-LSM-KVS中的缓存方案" class="headerlink" title="a. Caching Schemes in LSM-KVS (LSM-KVS中的缓存方案)"></a>a. Caching Schemes in LSM-KVS (LSM-KVS中的缓存方案)</h4><p>如前文所述，在LSM-KVS中有三种类型的条目可以被缓存：KV，KP和Block（如图2所示）。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC.png" alt="image-20211209162834502"></p><p>LevelDB仅采用了「Block Cache」（如图2a所示），这里的「Block」可以是：data block，index block，以及Bloom Filter block。「Block Cache」中的「block」使用<code>SST file ID</code>和<code>block offset</code>（例如，<code>&lt;SstID | BlockOffset&gt;</code>）来索引。「Block Cache」可以同时服务「point lookup」和「range query」。虽然Block Cache也能够服务point lookup，但是空间成本太高，因为只有「Block」中的小部分「key-value」才会被频繁访问。</p><p>RocksDB同时支持<code>Block Cache</code>和<code>KV Cache</code>（如图2b所示）。<code>KV Cache</code>缓存的KV对可以服务于<code>point lookup</code>。但是RocksDB中<code>Block Cache</code>和<code>KV Cache</code>的缓存大小都是预定义好的，一旦配置完成就无法动态调整。</p><p>Cassandra支持<code>KV Cache</code>和<code>KP Cache</code>（如图2c所示），但是不支持<code>Block Cache</code>。在KP Cache中，<code>value</code>在磁盘中的位置作为指针被缓存到内存中。一旦命中了<code>KP Cache</code>，因为<code>KP Cache</code>中已经保存了<code>value</code>在磁盘中的位置，所以仅需要一次额外的磁盘I/O就可以完成「point lookup」。与<code>KV Cache</code>相比，在面临较大的<code>value</code>时，<code>KP Cache</code>以一次额外的磁盘I/O为代价带来了更低的内存空间成本（也即空间效率更高）。但是，与<code>KV Cache</code>相似，<code>KP Cache</code>也不支持「range query」。</p><h4 id="b-General-Caching-Algorithms-通用的缓存算法"><a href="#b-General-Caching-Algorithms-通用的缓存算法" class="headerlink" title="b. General Caching Algorithms (通用的缓存算法)"></a>b. General Caching Algorithms (通用的缓存算法)</h4><p>Adaptive Replacement Cache (ARC，自适应替换缓存)是为管理DRAM中的「页缓存」而设计的「动态页面替换算法」。如图3所示，ARC将缓存空间划分为两个部分：「recency cache」 和 「frequency cache」，它们每个都是一个LRU（Least Recently Used，最近最少使用）缓存。 在ARC中，当一个页面第一次被访问时，将会被放到「recency cache」中，如果此页面在被移出「recency cache」前（也即被替换前）得到了第二次访问，则此页面会被认为是一个「frequently accessed page」，然后会将其进一步迁移到「frequency cache」。</p><p>recency cache和frequency cache之间的空间分配是动态的。ARC使用两个ghost cache来分别存储从recency cache和frequency cache 中替换出来的页面的元数据。ghost cache中缓存的页面元数据将会作为将来调整各部分缓存空间的参考。与real cache（也即存储完整页面的cache）相比，ghost cache的空间大小几乎可以忽略不计，因为它们只存储页面编号。</p><p>recency ghost cache的命中意味着recency cache的缓存空间应该更大，如图3上部所示，目标边界应该向左移动，反之亦然。因此，相应的real cache会根据工作负载来增大或减小。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_F_3.png" alt="image-20211209175114565"></p><p>但是，像ARC这种基于页面的缓存算法都不很适合LSM- KVS，因为它们都基于「页面大小」和「缓存收益」一致的假设。而在LSM- KVS中，不同的key-values的「大小」以及「缓存它们所带来的收益」是不一样的，也即「缓存成本」和「缓存收益」不统一（缓存成本为缓存条目所占用的内存空间，缓存收益为缓存条目所能节省的磁盘I/O次数）。</p><p>因此，在LSM-KVS的缓存方案设计中，「缓存成本」和「缓存收益」应该和「访问频率」一块被考虑。</p><h2 id="0x20-Motivation"><a href="#0x20-Motivation" class="headerlink" title="0x20 Motivation"></a>0x20 Motivation</h2><h3 id="0x21-Unique-Challenges-in-Caching-for-LSM-面临的挑战"><a href="#0x21-Unique-Challenges-in-Caching-for-LSM-面临的挑战" class="headerlink" title="0x21 Unique Challenges in Caching for LSM (面临的挑战)"></a>0x21 Unique Challenges in Caching for LSM (面临的挑战)</h3><p>首先，与页面缓存替换问题相比，页面缓存替换问题中的页面大小是固定的，而LSM树中的key-values大小不是一致的。因此，在LSM中的缓存算法在设计替换算法时，应该将key-values大小的不一致性纳入考虑范围。</p><p>此外，LSM-KVS有两种截然不同的读取操作，也即point lookup和range query，对缓存的需求不一致，这也在设计LSM缓存算法时也带来了额外的挑战。</p><p>最后，LSM-KVS的Compaction和Flush操作会使缓存的条目失效，在设计缓存方案时也要进行特殊处理。</p><h3 id="0x22-What-to-Cache-in-LSM-KVS-缓存什么的问题"><a href="#0x22-What-to-Cache-in-LSM-KVS-缓存什么的问题" class="headerlink" title="0x22 What to Cache in LSM-KVS (缓存什么的问题)"></a>0x22 What to Cache in LSM-KVS (缓存什么的问题)</h3><p>将缓存KV和KP进行比较，命中KV能节省更多次数的磁盘I/O，因为命中KP仍然需要一次额外的磁盘I/O操作。但是，另一方面，当value过大时，缓存KP的成本更低，空间利用更高效。</p><p><strong>Lesson 1: 应该结合缓存KV和KP条目的优点，来更高效的服务「point lookup」。</strong></p><p>但是遗憾的是，缓存KV和KP都不能支持「range query」，因此LevelDB和RocksDB都选择缓存「data block」来为「range query」服务。</p><p><strong>Lesson 2: 缓存block或者KV/KP都有它们各自的优势来支持「range query」或「point lookup」。也即每种缓存条目都有其适用的工作负载。</strong></p><h3 id="0x23-How-to-Perform-Replacement-如何执行替换的问题"><a href="#0x23-How-to-Perform-Replacement-如何执行替换的问题" class="headerlink" title="0x23 How to Perform Replacement (如何执行替换的问题)"></a>0x23 How to Perform Replacement (如何执行替换的问题)</h3><p>从上文的讨论可知，每种缓存条目都有其适应的工作负载场景。表1列出了各种缓存条目的比较。但是设计一个由三种缓存条目组成的替换算法是极具挑战的。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_T_1.png" alt="image-20211209183758144"></p><p>现有的成本感知缓存方案（cost-aware caching schemes）并没有针对LSM-KVS的场景做缓存成本和收益的分析。</p><p><strong>Lesson 3: 缓存算法应该根据LSM-KVS独特的分层结构，考虑不同缓存条目所「占用DRAM空间大小的不同」，以及「节省的I/O次数的不同」。</strong></p><p>通常，现有缓存算法会为各种缓存条目设置固定大小的缓存空间，但这会带来一系列问题。首先，很难设置最优的缓存空间分配；其次，即使一开始设计好了最优的缓存空间分配，但随着工作负载发生变化，之前设置的缓存空间分配便不再适用。</p><p><strong>Lesson 4：缓存算法应该能够自适应工作负载的变化。</strong></p><h2 id="0x30-Technique-AC-Key-Design"><a href="#0x30-Technique-AC-Key-Design" class="headerlink" title="0x30 Technique: AC-Key Design"></a>0x30 Technique: AC-Key Design</h2><p>AC-Key同时支持缓存三种类型（KV，KP和Block）的条目，并为它们设计了单独的缓存组件。此外，各个缓存组件的空间大小会根据「分层自适应缓存算法」（<em>hierarchical adaptive caching</em> algorithm，HAC）来调整，该算法考虑了不同缓存条目的异构成本和收益，并使用一个「缓存效率因子」（<em>caching efficiency factor</em>）来指导缓存组件大小的调整。</p><h3 id="0x31-AC-Key-Caching-Components"><a href="#0x31-AC-Key-Caching-Components" class="headerlink" title="0x31 AC-Key Caching Components"></a>0x31 AC-Key Caching Components</h3><p>AC-Key的系统架构如图4所示。Block，KP和KV缓存，通过E-LRU进行管理，E-LRU是一种改进的LRU（基于缓存效率因子来选择缓存条目进行逐或者说是替换）。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_F_4.png" alt="image-20211209191340705"></p><p>在一个point lookup中，如果一个lookup-key是首次被访问，则会先将它存到KP Cache中。缓存到KP Cache中的key被称为「warm key」。如果KP Cache中的一个「warm key」被再次命中，我们会将其视为一个「hot key」。我们预计将来访问它的可能性更高。因此，我们会将其提升到KV Cache中，来为将来的访问减少潜在的磁盘I/O次数。</p><p>一种优化方式是，如果KV对比KP对还要小，我们会将key-value缓存到<strong>KP Cache</strong>中，而不是选择将KP缓存到KP Cache中，这样既能避免额外的磁盘I/O，还能节省缓存空间。不过这个KV对仍然需要再次命中后才会被移动到KV Cache中。</p><h4 id="a-Get-Handling"><a href="#a-Get-Handling" class="headerlink" title="a. Get Handling"></a>a. Get Handling</h4><p>查询一个Store中存在的Key时（也即point lookup操作）。首先会查询MemTable，因为MemTable中可能存在最新版本的Value。如果没有在MemTable中查询到，则会在KV和KP缓存中查询，将会发生以下情形：</p><ul><li>Case I：命中KV Cache。不需要磁盘I/O，直接返回相应Value值即可；</li><li>Case II：没有命中KV Cache，但是命中KP Cache。此时，先检查指针指向的数据块是否被缓存到Block Cache中，如果没有则将此数据块加载到Block Cache中，然后在该数据块中使用二分查找定位KV对。此外，还需要将此Key从KP Cache提升到KV Cache中；</li><li>Case III：既没有命中KV Cache，也没有命中KP Cache。将会一个Level一个Level的查询每个有序run，查找完成后将其缓存到KP Cache中（需要注意的是，在检索SST时会使用到BF block以及Index block，如果它们不在Block Cache中，也要将它们缓存到Block Cache）；</li></ul><h4 id="b-Flush-Handling"><a href="#b-Flush-Handling" class="headerlink" title="b. Flush Handling"></a>b. Flush Handling</h4><p>Flush会将包含最新KV数据的MemTable写入到磁盘组件$L_0$中。需要注意的是，MemTable中的某个Key的旧数据此前可能已经缓存到KV或KP Cache中。如果包含最新数据的MemTable还没有Flush到磁盘上，则在执行<code>Get</code>时会先检查MemTable，KV或KP Cache中的旧数据不会对<code>Get</code>造成影响，但是如果将MemTable Flush到磁盘上，则在执行<code>Get</code>操作时可能得到的是缓存中的旧版本的数据。因此，必须在Flush前完成MemTable和缓存中重叠Key的同步（只要有缓存就有可能存在缓存不一致的问题）。</p><p>有两个可以进行同步的时间点，一种是在<code>Put</code>期间同步，一种是在<code>Flush</code>期间同步。</p><p>如果在<code>Put</code>期间进行同步，则在每次<code>Put</code>操作时都需要检查缓存中的条目，会带来额外的开销；此外，在此期间无法更新KP Cache，因为MemTable还没写到SST中，无法获得指针。</p><p>因此，AC-Key选择仅在<code>Flush</code>时进行同步，这时只需要同步一次，并且可以在此时计算出指针地址来更新KP缓存。</p><h4 id="c-Compaction-Handling"><a href="#c-Compaction-Handling" class="headerlink" title="c. Compaction Handling"></a>c. Compaction Handling</h4><p>Compaction操作会影响KP和Block Cache。因为此操作会删除旧的SST，而旧的SST中的数据可能已经缓存到了KP或Block Cache中。需要注意的是此操作不会影响KV Cache，因为<code>Compaction</code>操作不会修改数据，只会进行重排和合并。</p><p>AC-Key会更新受到到<code>Compaction</code>影响的KP或Block Cache。</p><h3 id="0x32-Caching-Efficiency-Factor"><a href="#0x32-Caching-Efficiency-Factor" class="headerlink" title="0x32 Caching Efficiency Factor"></a>0x32 Caching Efficiency Factor</h3><p>为了对缓存条目的成本和收益进行定量分析和权衡，本文根据LSM-KVS独特的分层结构提出了一个「缓存效率因子」。使用此缓存效率因子，AC-Key将LRU改进为E-LRU来管理每个缓存组件内部的替换操作。此外，AC-Key还通过这个缓存效率因子将ARC改进为E-ARC来调整各个缓存组件的大小。</p><p>本文将一个缓存条目的缓存效率因子$E$（$E$代表Efficiency）定义为如下等式：</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/image-20211209202701009.png" alt="image-20211209202701009"></p><p>其含义是每字节的DRAM空间所节省的I/O次数。</p><p>其中，$b$代表如果此条目被缓存，其潜在所能节省的I/O次数，它由如下等式给出：</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_E_2.png" alt="image-20211209203050655"></p><p>函数式$f(m)$依赖于LSM-KVS的实现，通常$f(m) = m+2$，也即需要读$m个BF + 1个index\ block + 1个data \ block$    。</p><p>传统的LRU仅考虑了访问模式，而没有考虑缓存条目的收益和成本不同。将LRU与缓存效率因子结合所得的E-LRU便是为了解决这一问题。E-LRU检查最少使用的a个缓存条目，并从中选出缓存效率因子最小的那个条目进行替换。$a$的值取决于缓存条目的缓存效率因子$E$的方差，它由$a= e^{v}$给出，其中$v$是缓存条目的缓存效率因子$E$的标准偏差。</p><p>当$v=0$时，所有缓存条目具有相同的缓存效率，此时$a=1$，E-LRU退化为LRU。此外，$a$有一个上限值，以避免在做出替换决定时需要检查过多的条目。</p><h3 id="0x33-HAC-Hierarchical-Adaptive-Caching"><a href="#0x33-HAC-Hierarchical-Adaptive-Caching" class="headerlink" title="0x33 HAC: Hierarchical Adaptive Caching"></a>0x33 HAC: Hierarchical Adaptive Caching</h3><p>Hierarchical Adaptive Caching (HAC)具有两级层次结构来管理不同的缓存（如图5所示）。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/AC-Key_F_5.png" alt="image-20211209211404375"></p><p>在上层，缓存被分为两个组件：<code>Point Cache</code>以及<code>Block Cache</code>，两个组件之间的边界可以动态调整。</p><p>在下层，<code>Point Cache</code>被进一步分为<code>KV Cache</code> 和<code>KP Cache</code>，同样也有一个动态调整的边界。</p><p>HAC通过维持<code>ghost caches</code>来保存从<code>KV Cache</code>、<code>KP Cache</code>和<code>Block Cache</code>中替换出来条目的记录。在上层和下层各有两个<code>ghost cache</code>。与<code>ghost cache</code>相对应，原始的<code>KV Cache</code>、<code>KP Cache</code>和<code>Block Cache</code>被称为<code>real cache</code>。在这里，<code>KV Real Cache</code>和<code>KP Real Cache</code>组成<code>Point Real Cache</code>。</p><p><code>ghost cache</code>并不保存真正的条目，只保存相关条目的元数据。一个<code>ghost cache</code>的命中意味着本应该命中对应的<code>real cache</code>的，如果<code>real cache</code>足够大的话。通过使用<code>ghost cache</code>和缓存效率因子，文章设计了E-ARC来调整相应的<code>real cache</code>的大小。</p><h4 id="a-Lower-Level-HAC"><a href="#a-Lower-Level-HAC" class="headerlink" title="a. Lower-Level HAC"></a>a. Lower-Level HAC</h4><p>在下层HAC，<code>Point Cache</code>被划分为<code>KV Real Cache</code>($R_{KV}$)和<code>KP Real Cache</code>（$R_{KP}$），这里有<br>$$<br>\left | R_{KV} \right |+\left | R_{KP} \right | = \left | S_{point} \right |<br>$$<br>其中$\left | S_{point} \right |$表示<code>Point Cache</code>的大小。AC-Key维护<code>KV Ghost Cache</code>，就好像$R_{KV}$ 加上$G_{KV}$的缓存大小就等于整个<code>Point Cache</code>的大小（这是用于暗示$R_{KV}$最大可以扩展到整个<code>Point Cache</code>的大小，而此时相应的$R_{KP}$的大小为0）。因此，在这个前提下，下面的等式成立：<br>$$<br>\left | S_{point} \right |=\left | R_{KV} \right |+\left | R_{KP} \right | = \left | R_{KV} \right |+\left | G_{KV} \right |=\left | R_{KP} \right |+\left | G_{KP} \right | \ \ \ Eqn.4<br>$$<br>下面展示E- ARC处理缓存命中和未命中的几种情况：</p><ul><li>Case I：命中<code>Real Cache</code>。缓存命中$R_{KV}$或$R_{KP}$，将该条目移动到$R_{KV}$的MRU端。特殊的，如果命中发生在$R_{KP}$则需要一次额外的磁盘I/O来获取<code>Value</code>，然后将该<code>key-value</code>对提升到$R_{KP}$中。</li><li>Case II：命中<code>KV Ghost Cache</code>。这意味着$R_{KV}$应该更大，因此向<code>KP Cache</code>方向调整目标边界，调整步幅为$\delta = kE$，$E$代表$G_{KV}$中命中条目的缓存效率因子，$k$是配置的学习率。从磁盘中读完数据后将其插入到$R_{KV}$的MRU端。为了给该条目腾出空间，如果目标边界在$R_{KV}$内部的话，这意味着<code>KV Cache</code>的目标大小比当前大小还要小，不能扩充，只能在<code>KV Cache</code>内部通过E-LRU算法进行替换。</li><li>Case III：命中<code>KP Ghost Cache</code>。这意味着$R_{KP}$应该更大，因此调整目标边界，同Case II类似。</li><li>Case III：未命中缓存。此时需要检索磁盘，然后将读取的数据缓按照KP的格式存到$R_{KP}$中。此外，$R_{KP}$同样需要为该条目腾空子，需要根据目标边界的实际情况来确定是调整$R_{KP}$的大小来腾空子还是通过缓存替换来腾空子。</li></ul><p>$R_{KV}$和$R_{KP}$之间的目标边界指示着实际边界应该移动的方向，但是需要注意的是，实际边界总是滞后于目标边界的。</p><p>高层的操作顺序如下：</p><ol><li>命中<code>ghost cache</code>则调整目标边界；</li><li>需要缓存的条目的插入或提升（从<code>KP Cache</code>提升到<code>KV Cache</code>）使得实际边界向目标边界方向调整，相应的，$R_{KV}$和$R_{KP}$的大小得到更新；</li><li>基于新的<code>Real Cache</code>的大小和Eqn.4（上文的等式4）来调整对应的<code>Ghost Cache</code>的大小；</li><li><code>Real Cache</code>和<code>Ghost Cache</code>在需要适配更新后的大小时通过E-LRU算法来执行替换；</li></ol><h4 id="b-Upper-Level-HAC"><a href="#b-Upper-Level-HAC" class="headerlink" title="b. Upper-Level HAC"></a>b. Upper-Level HAC</h4><p>在HAC的上层，我们重新应用E-ARC来调整<code>Point Cache</code>和<code>Block Cache</code>之间的边界。<code>Block Cache</code>和<code>Point Cache</code>各自都有一个 <code>Real Cache</code>和一个<code>Ghost Cache</code>。需要注意的是，从$R_{point}$中替换出来的条目不光要插入到$G_{point}$还要插入到下层的$G_{KV}$或$G_{KP}$中。与下层相似，上层的Cache空间也存在类似的等价关系：<br>$$<br>\left | S_{total} \right |=\left | R_{point} \right |+\left | R_{block} \right | = \left | R_{block} \right |+\left | G_{block} \right |=\left | R_{point} \right |+\left | G_{point} \right | \ \ Eqn.5<br>$$<br><strong>目标边界的调整：</strong></p><p>命中$G_{block}$需要将目标边界从$R_{block}$移向$R_{point}$，移动步幅$\Delta = kE$。相应的，$R_{point}$的目标大小将会减少$\Delta$。在下层，调整量将按照$R_{KV}$和$R_{KP}$的当前目标大小的比率按比例分配。例如，当前$R_{KV}$和$R_{KP}$的目标大小分别为$\left | R_{KV}^* \right |$和$\left | R_{KP}^* \right |$，则它们将按照如下方式进行更新：<br>$$<br>\begin{matrix}<br>\left | R_{KV}^* \right | \leftarrow \left | R_{KV}^* \right | - \Delta \frac{\left | R_{KV}^* \right |}{\left | R_{KV}^* \right | + \left | R_{KP}^* \right |}<br>\\<br>\left | R_{KP}^* \right | \leftarrow \left | R_{KP}^* \right | - \Delta \frac{\left | R_{KP}^* \right |}{\left | R_{KV}^* \right | + \left | R_{KP}^* \right |}<br>\end{matrix}<br>$$<br>另一方面，如果命中的是$G_{point}$，则需要将目标边界向$R_{block}$方向移动，移动步幅同样为$\Delta = kE$。需要注意的是，这里的$E$会比命中$G_{block}$时的缓存效率因子更大，因为与缓存Block相比，缓存KV和KP在占用相同空间的情况能节省更多的I/O次数。此外，在HAC的上层命中$G_{point}$则意味着会在下层命中$G_{KV}$或$G_{KP}$，在这种情况下会先调整下层的目标边界，再调整上层的目标边界。</p><p><strong>实际边界的调整：</strong></p><p>当一个block需要插入到<code>Block Cache</code>中（也即<code>Block Cache</code>潜在需要更大的空间时），而<code>Block Cache</code>的实际大小加上此block的大小比其目标大小要大时，<code>Block Cache</code>不会扩容，只能通过E-LRU算法从<code>Block Cache</code>中选择一个block进行替换。而如果<code>Block Cache</code>的实际大小加上此block的大小要比其目标大小要小时，此时就可以对<code>Block Cache</code>进行扩容了（相对应的<code>Point Cache</code>会收缩缓存空间），扩容后就可以将此block插入到<code>Block Cache</code>。</p><p>另一方面，如果<code>Point Cache</code>需要更大的容量，HAC会估计其进行扩容后的大小，然后将该大小与其目标大小进行比较，如果小于其目标大小的话，则可以对其进行扩容，相应的，<code>Block Cache</code>需要通过逐出block来收缩缓存空间以给Point Cache提供空间；如果预估的新的<code>Point Cache</code>的大小要大于其目标大小的话，则不能对其进行扩容，只能通过E-LRU算法在<code>Point Cache</code>内部通过替换来为新的缓存条目腾出空间。</p><h4 id="c-Reduce-Ghost-Cache-Size"><a href="#c-Reduce-Ghost-Cache-Size" class="headerlink" title="c. Reduce Ghost Cache Size"></a>c. Reduce Ghost Cache Size</h4><p>在ARC算法的设计中，从<code>Real Cache</code>中逐出的页面，其内容会被丢弃，仅需要将<code>page number</code>保存在<code>Ghost Cache</code>中。这里，<code>page number</code>的大小与<code>page content</code>相比是可以忽略不计的。</p><p>类似的，在AC-Key中<code>Ghost Block  Cache</code>的大小与<code>Real Block Cache</code>的大小相比也是可以忽略的，因为<code>Ghost Block Cache</code>中以<code>&lt;SstID | BlockOffset&gt;</code>形式存储的<code>block handle</code>与<code>Real Block Cache</code>中存储的Block相比也是可以忽略的。但是<code>Ghost KV Cache</code>、<code>Ghost KP Cache</code>以及<code>Ghost Point Cache</code>的大小与其对应的<code>Real Cache</code>相比是无法忽略的，这会带来较大的空间开销。  </p><p>AC-Key通过两种方式来减少<code>Ghost Cache</code>的空间开销：</p><ul><li>首先，AC- Key不使用从<code>KV Cache</code>和<code>KP Cache</code>中逐出来的条目的原始Key，而是使用原始Key的哈希值；</li><li>其次，可以在自适应缓存方案已经成功建立了一个在<code>KV Cache</code>、<code>KP Cache</code>和<code>Block Cache</code>之间比较有利的空间分配时关闭掉<code>Ghost Cache</code>，来消除其带来的开销。此外，还可以根据当前缓存组件的命中率来判断是否需要打开<code>Ghost Cache</code>以重新指导空间分配；</li></ul>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TRIAD:Creating Synergies Between Memory, Disk and Log in Log Structured Key-Value Stores</title>
    <link href="/2021/12/09/%E8%AF%BB%E8%AE%BA%E6%96%87/TRIAD%EF%BC%9ACreating%20Synergies%20Between%20Memory,%20Disk%20and%20Log%20in%20Log%20Structured%20Key-Value%20Stores/"/>
    <url>/2021/12/09/%E8%AF%BB%E8%AE%BA%E6%96%87/TRIAD%EF%BC%9ACreating%20Synergies%20Between%20Memory,%20Disk%20and%20Log%20in%20Log%20Structured%20Key-Value%20Stores/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-Introduction-amp-Background"><a href="#0x00-Introduction-amp-Background" class="headerlink" title="0x00 Introduction &amp; Background"></a>0x00 Introduction &amp; Background</h2><p>LSM通常由两部分组件组成：</p><ul><li>内存组件（Memory Component）：主要用来absorb update（在内存组件中absorb update的同时会将数据写入到磁盘日志中，以用于数据恢复）；</li><li>磁盘组件（Disk Component）：用于持久化数据，内存组件中的数据超过上限后会flush到磁盘，磁盘组件按照Level的形式进行组织，接近内存组件的Level保存着更新的数据，当某个$L_i$超过上限时会与$L_{i+1}$进行归并压缩，也即在后台执行$Compaction$操作；</li></ul><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_1.png" alt="image-20211208161344551"></p><p>$Compaction$和$Flush$是非常关键的操作，负责维护$LSM$的结构和属性，同时这也会占用大量的可用资源。</p><p>作者在$Nutanix$的生产环境负载测试中，顶峰时$Compaction$操作对$CPU$的占用率会达到45%。此外，单个集群平均每天要花费两个小时在$Compaction$操作上，以维护元数据存储映射。</p><p>文章提出了三种新的互补技术来弥补这些不足。这些技术同时减少了$Compaction$和$Flush$操作所占用的时间和空间资源，并带来了吞吐量的提升。</p><ol><li>第一项技术减少了倾斜工作负载（skewed workload）下的$Compaction$开销。将频繁更新的$KV$对（也即hot entries）保留在内存组件中，仅对cold entries执行$Flush$操作。这个分离操作减少了hot entry所触发的频繁Compaction操作。</li><li>第二项技术的主要思想是推迟对文件的Compaction操作，只有当文件的重叠部分足够大时才进行Compaction。</li><li>第三项技术主要是改变提交日志（commit log）在LSM中的角色，以类似SSTable的形式来使用它们，来避免双写（第一次写到日志，第二次是flush操作所引起的第二次写操作）；</li></ol><h2 id="0x10-Motivation"><a href="#0x10-Motivation" class="headerlink" title="0x10 Motivation"></a>0x10 Motivation</h2><p>尽管I/O操作不在面向用户操作的关键路径中，但是Flush、Compaction、Log等操作仍然会占用大量的计算资源。CPU协调这些操作会占用大量的处理能力，而这些处理能力本来是可以用于为用户提供更好性能体验的。因此I/O操作的频率和长度会对用户感知的最终性能有较大的影响。</p><p>为证明I/O操作会导致性能下降，本文设计了相关实验进行验证。选择了两个方面具有负载倾斜的工作负载：</p><ul><li>数据流行度：skewed和uniform</li><li>读写混合：write dominated 和 balanced</li></ul><p>将上述工作负载运行在普通RocksDB和关闭了后台I/O的RocksDB（例如，可以关闭$Flush$和$Compaction$）中，实验结果绘图如下：</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_2.png" alt="image-20211208171104923"></p><p>可以看到在各个负载下，关闭了后台I/O的RocksDB都表现出了更优的性能。在此结果的驱动下，本文确定了触发频繁和密集I/O的三个主要原因：</p><ul><li> data-skew unawareness, at the memory component level，也即在内存组件层面上的无意识的数据倾斜（存在冷热键）;</li><li> premature and iterative compaction, at the LSM tree level，也即在LSM树层面过早的迭代$Compaction$操作;</li><li>duplicated writes at the logging level，也即在日志层面的双写操作； </li></ul><h3 id="0x11-Data-skew-unawareness-（数据倾斜）"><a href="#0x11-Data-skew-unawareness-（数据倾斜）" class="headerlink" title="0x11 Data skew unawareness （数据倾斜）"></a>0x11 Data skew unawareness （数据倾斜）</h3><p>很多KV Store的工作负载都表现出数据倾斜的特征，其中hot key的更新频率要远远高于cold key。</p><p>数据倾斜导致commit log的增长速度远远大于$C_m$（也即内存中的MemTable和Immutable Memtable）。因为对相同key的更新，日志是以追加的方式存储的，而$C_m$采取的是就地吸收（absorbed in-place）的方式。这会导致$C_m$在达到其上限之前触发$Flush$操作，因为commit log过大会导致在数据恢复时所耗费的时间更长，所以MemTable必须频繁的$Flush$，从而使commit log可以被及时清理掉，通过减小commit log的大小来缩短数据恢复的时间。这不仅会增加$C_m$的$Flush$频率，而且由于其大小是小于其能达到的最大值的，导致$L_0$中打开和存储文件的固定成本并没有被实际写入数据更好的摊分。</p><h3 id="0x12-Premature-and-iterative-compaction-（过早Compaction）"><a href="#0x12-Premature-and-iterative-compaction-（过早Compaction）" class="headerlink" title="0x12 Premature and iterative compaction （过早Compaction）"></a>0x12 Premature and iterative compaction （过早Compaction）</h3><p>现有的基于LSM的KV-Store在Compaction过程中表现出了两方面的限制。</p><p>一些KV-store在$L_0$中仅保留一个SSTable，以加快读速率。但这样会导致每次内存组件的Flush操作都会触发一次$L_0$和底层Level的Compaction操作，也即导致了频繁的Compaction操作。这便是第一种限制。</p><p>另外一些LSM的方案是在$L_0$保存多个SSTable，这会导致第二种限制。主要表现在，当$L_0$中有多个SSTable时，LSM如何将$L_0$ Compaction到$L_1$。事实上，$L_0$中的多个文件是一次性Compaction到更高的Level的，这从而也会导致多个连续的Compaction操作。也即如果$L_0$中的两个SSTable都有一个相同的key，那么这个key将会在底层的LSM树中执行两次Compaction操作。而数据倾斜会加剧这个问题，因为它增加了$L_0$中多个SSTable拥有共同key的概率。显然，当系统的负载越高时，这种事件发生的概率也会越高。</p><h3 id="0x13-Duplicate-writes（双写）"><a href="#0x13-Duplicate-writes（双写）" class="headerlink" title="0x13 Duplicate writes（双写）"></a>0x13 Duplicate writes（双写）</h3><p>当$C_m$被Flush到$L_0$中后，相应的commit log便会被删除掉，因为$Flush$操作已经能够保证数据的持久化。Flush到$L_0$的每个KV对都是最新的版本，都对应了一个commit log，因此$Flush$操作不过是重放了在追加commit log时已经执行过的I/O操作。</p><h2 id="0x20-Technique——TRIAD"><a href="#0x20-Technique——TRIAD" class="headerlink" title="0x20 Technique——TRIAD"></a>0x20 Technique——TRIAD</h2><p>文章用来解决I/O开销的方法体现在三个方面，每个解决方案都对应了前面提到的一个挑战：</p><ul><li> TRIAD-MEM 通过冷热键分离来解决内存组件中的data skew问题；</li><li>TRIAD- DISK 通过推迟和批量Compaction来解决磁盘组件中的premature and iterative compaction问题；</li><li>TRIAD- LOG 通过绕过$Flush$过程中创建新SSTable来解决日志层面中的duplicate write问题；</li></ul><h3 id="0x21-TRIAD-MEM"><a href="#0x21-TRIAD-MEM" class="headerlink" title="0x21 TRIAD-MEM"></a>0x21 TRIAD-MEM</h3><p>TRIAD-MEM的目标是利用大多数工作负载所表现出的数据倾斜的特点来减少Flush，并进一步减少Compaction的频率。为了做到这一点，TRIAD-MEM仅将cold key flush到磁盘上，而将hot key保留在内存中（但也要写commit log）。这能避免触发大量的Compaction操作，从而降低磁盘中重叠Key的数量。</p><p>将hot key保留在内存中，便可以在内存中完成更新操作，这可以避免在磁盘上触发大量的Compaction操作。</p><p>图3展示了Flush期间冷热键分离的过程，图4展示了Flush完成后的状态。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_3_4.png" alt="image-20211208204615405"></p><p>算法2展示了冷热键是如何分离的。旧$C_m$中的前K个条目被选中，其中K是系统的参数。理想情况下，K的取值应该既能保存尽量多的hot key，还能避免引起较高的内存开销。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_A_2.png" alt="image-20211208205815580"></p><p>保留在内存中的hot key 不需要Flush到磁盘上，但在更新时仍然需要写commit log（如图3所示），以保证在宕机时能完成数据恢复。</p><p>当$C_m$的大小不超过某个阈值（算法1中的<code>FLUSH_TH</code>）时，分离冷热键时不会进行$Flush$。因为在工作负载不均衡时，$Flush$ 可能是因为commit log满了而不是$C_m$满了所触发的（commit log太多会造成数据恢复时间过长，所以commit log过多时也会触发$Flush$）。所以，为了避免$Flush$小的$C_m$文件，算法会将所有条目都保存在内存中，并根据这些条目创建新的commit log，丢弃旧的commit log。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_A_1.png" alt="image-20211208211005386"></p><h3 id="0x22-TRIAD-DISK"><a href="#0x22-TRIAD-DISK" class="headerlink" title="0x22 TRIAD-DISK"></a>0x22 TRIAD-DISK</h3><p>TRIAD-DISK会推迟Compaction操作，直到需要Compaction的文件有足够多的key重叠。为了估计文件之间的key重叠，文章使用了HyperLogLog (HLL)概率基数估计器。</p><p>为了计算一组文件之间的重叠，文章定义了一个重叠率（overlap ratio），假设在$L_0$中有$n$个文件，则重叠率可以定义为：<br>$$<br>1-\frac{ UniqueKeys(file_1, file_2,… ,file_n))}{sum(Keys(file_i))}<br>$$<br>其中：</p><ul><li>$Keys(file_i)$表示第$i$个SSTable中的key数量；</li><li>$UniqueKeys(file_1, file_2,… ,file_n))$表示合并$n$个文件后的唯一key的数量；</li></ul><p>图5展示了overlap ratio 是如何来推迟Compaction的。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_F_5.png" alt="image-20211208212910135"></p><p>在$L_0$中执行每次Compaction之前，我们会先计算出$L_0$中所有文件的overlap ratio，如果overlap ratio小于阈值，则推迟Compaction（除非$L_0$中文件的数量超过允许的最大值，如果超过，那么不再考虑overlap ratio，强制允许Compaction）。</p><h3 id="0x23-TRIAD-LOG"><a href="#0x23-TRIAD-LOG" class="headerlink" title="0x23 TRIAD-LOG"></a>0x23 TRIAD-LOG</h3><p>TRIAD-LOG的主要思路是，内存中需要Flush到磁盘中的数据已经在commit log中了，可以对commit log进行利用而不必通过Flush操作再重写一次。主要思想就是将CL转为$L_0$中一种特殊的SSTable，也即CL-SSTable，这种方式可以避免完整的Flush操作。</p><p>TRIAD-LOG增强了commit log角色的能力。当向$C_m$写入数据时，commit log就扮演其普通WAL的角色。当触发Flush操作时，将commit log转为CL-SSTable而不是将$C_m$重写到$L_0$。</p><p>将commit log作为$L_0$中的SSTable可以避免Flush操作所带来的I/O开销，但SSTable是有序的，而commit log是追加生成的、是无序的。SSTable有序的特性可以加速Compaction操作和检索操作。</p><p>为了避免在$L_0$中查找某个条目时需要扫描整个CL-SSTable，TRIAD-LOG在$C_m$中保存每个KV对应的最近更新的commit log文件的偏移量，以帮助构建有序的CL-SSTable。一旦Flush操作被触发，只需要将与最新的commit log偏移量相关联的索引写到磁盘上（索引也即index的大小与整个KV相比是很小的，所以仅刷新index的开销很小，文章并没有对index有明确说明，我觉的这里的index可以是<code>(key, CL name, offset)</code>的组合，通过这个index再加上CL就可以组成有序的CL-SSTable了）。</p><p>TRIAD-LOG并没有改变写操作的流程，不同之处仅在于，在$C_m$中执行更新时会把对应的commit log的偏移量和文件名也写入到$C_m$中（例如，<code>(key, value, offset, CL name)</code>）。其流程入下图所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/TRIAD_F_6.png" alt="image-20211209093221560"></p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Key-Value Store</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务实现算法</title>
    <link href="/2021/10/20/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/20/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="私有工作空间"><a href="#私有工作空间" class="headerlink" title="私有工作空间"></a>私有工作空间</h2><p>在概念上，当一个<strong>进程</strong>开始一个事务时，它被分配一个私有工作空间，该工作空间包含所有它有权访问的文件。在事务提交或中止前，它的所有读写操作都在私有空间内进行，而不是直接对文件系统进行操作。这就直接导致了第一种实现方法的产生；在进程开始一个事务的时刻，实际上为该进程分配了一个私有工作空间。</p><p>此技术带来的问题是把所有的东西都<strong>复制到私有工作空间的开销</strong>是十分大的，但是各种各样的优化方法使这种方法可行。</p><p>第一种优化方法是基于这样的认识，即<strong>当一个进程只读取一个文件而不对它做修改时，就不需要私有拷贝</strong>。该进程可以直接使用真正的文件（除非自事务开始以来文件已被改动）。因此，当进程开始一个事务时，就为它创建一个私有的工作空间，该空间是空的，除非当一个指针回指到它的父辈工作空间。当<strong>进程为了读取而打开文件时，指针将回指，直到可以在父辈（或者更老的祖先）工作空间中找到文件为止。</strong></p><p>第二种优化方法可以大大减少复制工作量。因为它不是复制整个文件，而是<strong>只将索引复制到私有工作空间</strong>。索引是与判断文件所在磁盘块位置有关的数据块。在UNIX系统中，索引是$i$节点（index node，即索引节点）。通过<strong>私有索引</strong>，文件可以按通常方式读取，这是因为索引中所包含的地址指向的是文件所在的原始磁盘块。然而，<strong>当一个文件块第一次被修改时，将生成该块的副本，其地址也被插入索引中</strong>（如下图所示）。然后就可以在不影响原始块的情况下更新这个块。添加块也是用这种方法解决。新块有时会被称为影像块。（这是一种写时复制技术，即copy-on- write）</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.drawio.png" alt="写时复制.drawio"></p><p>在上图中，运行事务的进程看到了修改的文件，但是其他所有进程看到的仍是原始的文件。在更复杂的事务中，私有工作空间可能包含大量的文件而不仅仅是一个。<strong>如果事务中止，私有工作空间就被简单的删除，它所指向的私有块也将被释放回自由列表（free list）中。如果事务被提交了，那么私有索引被移到父辈工作空间中。</strong></p><h2 id="写前日志"><a href="#写前日志" class="headerlink" title="写前日志"></a>写前日志</h2><p>另一个实现事务的常用方法是写前日志（write ahead log，WAL）。使用这种方法时，<strong>文件将真正被修改，但是在任何一个数据块被修改前，一条记录被写到了日志中以说明哪个事务正在对文件进行修改，哪个文件和哪个数据块被改动了，旧值和新值是什么。只有当日志被写入成功后，此改动才可以被写入文件。</strong></p><p>如果事务执行成功并被提交，那么一条提交记录被写进日志，但是数据结构不需要变动，这是因为它们已经被更新了。如果事务中止，那么可以使用日志来回退到原来的状态。<strong>从日志的末尾开始向前读取每条记录，同时将在每条记录中描述的改动撤销</strong>（这也被称为「回退」或「回滚」，也即rollback）。</p><p>注：本文内容摘自「分布式系统原理与范型」，供本人学习回顾使用。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>事务</tag>
      
      <tag>分布式系统原理与范型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发控制</title>
    <link href="/2021/10/20/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/10/20/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>并发控制算法通常根据<strong>读写操作同步的方式</strong>来分类。同步可以通过<strong>共享数据上的互斥机制</strong>（例如，锁🔒），或者通过显式地使用<strong>时间戳排序</strong>来实现。</p><p>并发控制算法可以进一步区分为<strong>悲观算法</strong>和<strong>乐观算法</strong>。</p><p>悲观算法（pessimistic approaches）的基本原则是Murphy定律（墨菲定律）：<strong>如果某事物可以出错，那么它就会出错。在悲观算法中，操作时在它们被执行前同步的，这意味着冲突在允许发生之前就解决了</strong>。</p><p>相反，乐观算法（optimistic approachs）是<strong>基于错误一般不会发生的观点</strong>。所以操作被简单地执行，在事务结束的时候再进行同步。如果那是确实发生了冲突，一个或更多的事务将被迫终止。</p><p>下面将讨论两个悲观算法和一个乐观算法。</p><h2 id="两阶段锁定"><a href="#两阶段锁定" class="headerlink" title="两阶段锁定"></a>两阶段锁定</h2><p>最古老最简单也是最广泛使用的并发控制算法是锁定（locking🔒）。</p><p>当一个进程要作为事务的一部分来读或写一个数据项时，它请求调度管理器允许它给该数据项加锁。同样，当它不再需要一个数据项时，就请求调度管理器释放该锁。</p><p><strong>调度管理器的任务</strong>是以一种可以得到正确调度结果的方式来允许加锁和释放锁，即需要使用一种<strong>可以提供串行调度的算法</strong>。这样一个算法是两阶段锁定算法。</p><p>如下图所示的两阶段锁定（two-phase locking，2PL）中，调度管理器先在增长阶段（growing phase）获得它所需要的所有锁，然后在收缩阶段（shrinking phase）释放它们。尤其要遵守下面三个规则：</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/2PL.png" alt="17105307_MZJc" style="zoom: 50%;" /><ol><li>当调度管理器收到来自事务管理器的<code>open(T,x)</code>操作时，它检测该操作是否跟它已经允许锁定的另一个进程冲突。如果存在冲突，操作<code>open(T,x)</code>被延迟（这样事务$T$也被延迟）。如果没有冲突，调度管理器就允许对数据项$x$加锁，并将这个操作传递给数据管理器。</li><li>直到数据管理器通知它已经完成了对锁定数据项x的操作，调度管理器才会释放数据项x的锁。</li><li>一旦调度管理器为事务$T$释放了锁，那么无论事务T请求为哪个数据项加锁，调度管理器都不会允许T加另外一把锁（即只能一次获取到所需的所有锁）。$T$获取另外一把锁的任何企图都是一个程序错误，都会终止事务$T$。</li></ol><p>在许多系统中，收缩阶段是在事务运行结束之后，要么提交、要么终止时出现，它导致锁的释放（<strong>同时释放</strong>），如下图所示。这种策略被称为严格的两阶段锁定。</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/strict-2PL.png" alt="17105326_2MZl" style="zoom:50%;" /><p>严格的两阶段锁定有两个主要的优点：</p><ul><li>事务总是读提交事务写入的值，所以我们从来都不会因为事务的计算是基于一个它不应该看到的数据项而终止它。</li><li>所有锁的获得和释放都可以由系统来处理而无需事务关心。要访问一个数据项就要获得锁，当事务完成时就释放锁。这种策略消除了瀑布型终止（cascaded aborts），即不得不撤销一个已经提交的事务，因为它看到了它不该看见的数据项。</li></ul><h2 id="悲观的时间戳排序"><a href="#悲观的时间戳排序" class="headerlink" title="悲观的时间戳排序"></a>悲观的时间戳排序</h2><p>一个完全不同的并发控制方法是在<strong>每个事务$T$开始时给它分配一个时间戳$ts(T)$。</strong></p><p>使用Lamport算法，我们可以保证时间戳是惟一的。<strong>事务$T$的每个操作都被盖上时间戳$ts(T)$，并且系统中的每个数据项$x$都有一个相关的读时间戳$ts_{RD}(x)$和写时间戳$ts_{WR}(x)$。</strong>读时间戳被设置为<strong>最近</strong>读$x$的事务的时间戳，而写时间戳是<strong>最近</strong>修改$x$的事务的时间戳。使用时间戳排序，如果两个操作冲突，则数据管理器先处理时间戳最早的操作。</p><p>现在假设调度管理器从具有时间戳$ts$的事务$T$收到一个操作，<code>read(T,x)</code>。但是$ts&lt;ts_{WR}(x)$。**换句话说，调度管理器发现一个对$x$的写操作在事务开始后已经完成（也即，在事务$T$启动到开始读之间，调度管理器发现一个对x的写操作在此期间完成了）。在这种情况下，事务$T$简单的被终止。**相反，如果$ts&gt;ts_{WR}(x)$，那么让读操作发生（即上一个对$x$的写操作是在事务$T$之前完成的）。此外，$ts_{RD}(x)$被设置为$max{ts, ts_{RD}(x)}$。</p><p>同样，假设调度管理器收到一个具有时间戳$ts$并包含写操作<code>write(T, x)</code>的事务$T$。**如果$ts&lt;ts_{RD}(x)$，那么它只能取消事务$T$，这是因为$x$的当前值已经被更晚的事务读过**（也即，在事务$T$启动到开始写之前完成了一个事物对$x$的读操作，实际上应该事务$T$先来的，但是被别人插队了，为了大局，事务$T$只能取消）。另一方面，如果$ts&gt;ts_{RD}(x)$，那么它改变$x$的值，因为没有更晚的事务读过它。$ts_{WR}$也被设置为$max{ts, ts_{WR}(x)}$。</p><p>时间戳具有与锁定不同的特性。当事务遇到一个更大（或更晚）的时间戳时，它中止，而在同样的情况下，如果使用锁定方法，事务将等待或立即执行（也即，要是被人插了队自己就中止退出）。另一方面，它不会造成死锁，这是一个很大的优点。</p><h2 id="乐观的时间戳排序"><a href="#乐观的时间戳排序" class="headerlink" title="乐观的时间戳排序"></a>乐观的时间戳排序</h2><p>第三种处理多个事务同时执行的方法是乐观的并发控制（optimistic concurrency）。此技术的思想是：不关心别人在干什么，继续做自己要做的事情。如果有问题，等到后面再考虑（许多政客也使用这个算法，注：个人认为西方政客会这样做，咱们中国的政客都是特别怕出事情担责任的）。实际上，相对来讲冲突是很少的，所以系统大部分时间都运行正常。</p><p>尽管冲突可能很少发生，但也不是不会发生，因此仍需要某种方法来处理冲突。乐观的并发控制所做的事情是跟踪哪些数据项被改写了。<strong>在某个事务被提交的时候，它检查其他所有事务，看看是否有某些数据项从这个事务开始后被改变了（即在某个事务提交的时候检查其数据项是否被其他事务改变了）。如果被改变了，该事务被终止；如果没有被改变，则该事务提交。</strong></p><p>乐观的并发控制算法最适合基于<strong>私有工作空间</strong>的实现。在这种方式下，每个事务私下改变自己的数据，不受别的事务的干涉。最终，新数据要么被提交、要么被释放，这是一个相对简单直接的方法。</p><p>乐观的并发控制的最大优点是它不会发生死锁，允许最大的并行性。这是因为没有进程需要等待一个锁。缺点是有时它可能会失败，那时事务将不得不再次执行。在负载较重的情况下，失败的可能性比较大，使得乐观的并发控制成为了一个较差的选择。</p><p>此外，对乐观的并发控制的研究主要集中在非分布式系统中。</p><p>注：本文内容摘自「分布式系统原理与范型」，供本人学习回顾使用。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>分布式系统原理与范型</tag>
      
      <tag>并发控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式快照捕获算法</title>
    <link href="/2021/10/14/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81/"/>
    <url>/2021/10/14/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在许多情况下，知道分布式系统所处的全局状态是很有用的。<strong>分布式系统的全局状态（Global State）包括每个进程的本地状态和当前正在传输中的消息，所谓正在传输中的消息即该消息已经被发送但还没有被交付。</strong></p><p>有很多原因表明，知道分布式系统的状态是很有用的。例如，当已知本地计算已经停止并且也没有消息在传输时，系统显然进入了一个不能继续前进的状态。此时，通过分析全局状态我们就能得知系统是进入了死锁还是分布式计算已经正确的结束了。</p><p>注：本文内容主要摘自「分布式系统原理与范型」，主要用于本人学习回顾。</p><h2 id="关于全局状态和分布式快照"><a href="#关于全局状态和分布式快照" class="headerlink" title="关于全局状态和分布式快照"></a>关于全局状态和分布式快照</h2><p>Chandy和Lamport在其1985年发表的论文<a href="https://lamport.azurewebsites.net/pubs/chandy.pdf">Distributed Snapshots：Determining Global States of Distributed Systems </a>中提出了一个简单直接的<strong>记录分布式系统全局状态</strong>的方法，该方法引入了<strong>分布式快照</strong>（Distribute Snapshot）的概念。</p><p><strong>分布式快照反映了该分布式系统可能处于的状态，且重要的是，该记录的状态是全局一致的。</strong>这意味着，如果快照已经记录了进程P收到了来自进程Q的一条信息，那么应该也记录了进程Q确实发送了这个消息。否则，快照将会记录一个已经被接受但从未被发送的消息。需要注意的是，相反的情况是可以接受的，也即快照可以记录一个已经被发送但还尚未被接受的消息。</p><p>全局状态的概念可以用一个被称为切口（cut）的示意图来表达。如下图所示，穿越进程P1、P2和P3时间轴的虚线表示的是一个一致的切口。该切口表示了「为每个进程记录的最后事件」，记录了事件$m_1$的发送和接受，以及事件$m_2$的发送。</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/IMG_6746735F12FC-1.jpeg" alt="IMG_6746735F12FC-1" style="zoom: 50%;" /><p>作为对比，下图是一个不一致的切口，快照中记录了事件$m_1$的发送和接受，但是仅记录了事件$m_3$的接受而未记录其发送。</p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/IMG_CC2C77FC7968-1.jpeg" alt="IMG_CC2C77FC7968-1" style="zoom:50%;" /><h2 id="分布式快照捕获算法的描述"><a href="#分布式快照捕获算法的描述" class="headerlink" title="分布式快照捕获算法的描述"></a>分布式快照捕获算法的描述</h2><p>为了简化对分布式快照捕获算法的解释，我们假设分布式系统可用一个彼此通过<strong>单向点对点通信通道</strong>相连的进程集合来表示。例如，进程可能在任何进一步通信发生前首先建立TCP连接。</p><p>任何进程都可以启动该算法来捕获一个分布式快照。启动算法的<strong>进程P</strong>通过记录它自己的本地状态而启动。然后，它可以通过每个<strong>流出通道</strong>发送一个<strong>标记</strong>，表明接受者应该参与记录全局状态。</p><p>当<strong>进程Q</strong>通过一个<strong>进入通道C</strong>接收到一个<strong>标记</strong>，该进程根据它是否已经保存了本地状态来决定下一步动作。</p><ul><li>如果进程Q尚未保存其本地状态，它就先记录本地状态，然后也通过它自己的每个流出通道发送一个标记。</li><li>如果进程Q已经保存了其本地状态，则通道C上的标记表明Q应该记录该通道的状态。该状态是从进程Q上次记录了它自己的本地状态开始，到它接受了该标记为止，Q所接受到的消息序列组成。</li></ul><p>当一个进程接受并处理了它的所有进入通道的标记时，就认为该进程已经完成了算法中与它有关的部分。此时可以将它记录的本地状态和它为每个进入通道记录的状态收集起来，发送给发起此快照的进程P。后者随后分析当前状态。需要注意的是，与此同时，分布式系统可以作为一个整体继续正常运行，也即分布式快照算法不会影响分布式系统的正常运行。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/cut.drawio.png" alt="cut.drawio"></p><p>还有一个需要注意的地方是，因为任何进程都能发起该算法，所以可能同时存在几个快照。为此，标记上附有发起该快照的进程的标识符（可能还有一个版本号）。只有在进程已经通过它的每个进入通道接收到了某个标记后，它才能完成与该标记相关的快照的创建。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>分布式系统原理与范型</tag>
      
      <tag>全局状态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑时钟（Logical Clock）</title>
    <link href="/2021/10/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F/"/>
    <url>/2021/10/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%80%BB%E8%BE%91%E6%97%B6%E9%92%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容主要摘自《分布式系统原理与范型》，主要用于本人后续回顾学习用，建议阅读原书。</p><h2 id="关于时钟"><a href="#关于时钟" class="headerlink" title="关于时钟"></a>关于时钟</h2><p>几乎所有的计算机都有一个计时电路，我们一般会称这个计时电路为「时钟」（但它们并不是通常意义上的时钟，我们将其称为「计时器」可能会更恰当一些）。「时钟」与进程之间的协作和同步有密切的关系，多个进程之间是通过「事件」发生的「时间」来就「事件」的发生顺序达成一致的。在单机单时钟的情况下，如果这个时钟存在少许偏差是不会出现问题的，因为这台机器上的所有进程都使用同一个时钟，所以它们的内部仍然会保持一致。</p><h2 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h2><p>在许多应用中，只要所有的机器能维持一个全局统一的时间就够了，这个时间并不需要与真实时间一致。对于某类算法而言，重要的是时钟的内部一致性，而不是它们是否与真实时间接近。这类算法通常将时钟称为「逻辑时钟」（logical clock）。</p><p>Lamport在其著名的论文<a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf">「Time, Clocks, and the Ordering of Events in a Distributed System 」</a>中阐明了「尽管时钟同步是可能的，但它不是绝对必要」的观点。如果两个进程不进行交互，那么他们的时钟也无须同步，这是因为即使没有进行同步也察觉不出来，并且也不会产生问题。他指出，<strong>通常重要的不是所有的进程在时间上完全一致，而是它们在事件的发生顺序上要达成一致</strong>。</p><h2 id="Lamport时间戳"><a href="#Lamport时间戳" class="headerlink" title="Lamport时间戳"></a>Lamport时间戳</h2><p>为了同步逻辑时钟，Lamport定义了一个称为「先发生」（happens-before）的关系。表达式$a \rightarrow b$读作「a在b之前发生」，意思是所有进程一致认为事件a先发生，然后事件b才发生。这种「先发生」关系有两种情况：</p><ul><li>如果a和b是同一个进程中的两个事件，且a在b之前发生，则$a \rightarrow b$为真；</li><li>如果a是一个进程发送消息的事件，而b为另一个进程接受该消息的事件，则$a \rightarrow b$也为真。消息不可能在发送之前就被接受，也不可能在发送的同时被接受，这是因为消息需要一定时间才能到达接收端。</li></ul><p>「先发生」关系是一种传递关系，所以如果$a \rightarrow b$且$b \rightarrow c$，则有$a \rightarrow c$。如果事件x和y发生在两个互不交换消息的进程中（也不通过第三方间接交换消息），那么无论是$x \rightarrow y$还是$y \rightarrow x$都不为真。这两个事件被称为「并发的」（concurrent），这意味着无法说或者不必说这两个事件什么时候发生，哪个事件先发生。</p><p>我们需要一种测量事件的方法，使得对于每个事件a，我们都能为它分配一个所有进程都认可的时间值$C(a)$。同时这些时间值必须具有如下性质：</p><ul><li><p>如果$a \rightarrow b$，那么$C(a) &lt; C(b)$；</p></li><li><p>时钟时间值$C$必须总是前进（增加），不能倒退（减少），校正时间的方法是给时间加上一个正值而不是减去一个正值；</p></li></ul><p>如下图所示，三个进程运行在不同的机器上，每个机器以各自的速率工作。当进程A的时钟「滴答」了6次时，进程B的时钟「滴答」了8次，进程C的时钟「滴答」了10次。我们下面描述一个从进程A到B再到C的消息传递及响应过程：</p><ol><li><p>在0时刻，进程A将消息a发送给进程B，消息的传输时间取决于信任哪个时钟。不管怎样，当它到达进程B时，进程B的时钟为16。如果消息a上携带了其在进程A上打包的时钟值0，则进程B会推算其传输时间为$16 - 0 = 16$个时钟值。</p></li><li><p>进程B在其时钟值为24时，将消息b发送给进程C，在进程C的时钟值为40时到达进程C。</p></li><li><p>进程C在其时钟值为50时，将响应消息c发送给进程B，在进程B的时钟值为48时到达进程B。</p></li><li><p>进程B在其时钟值为56时，将响应消息d发送给进程A，在进程A的时钟值为54时到达进程A。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/logical_clock2.png" alt="logical_clock"></p></li></ol><p>分析以上过程，我们可以发现一个有意思的现象，响应消息从进程C时钟值为50时刻出发，却在进程B时钟值为48时刻到达进程B，响应消息d也有类似的现象——<strong>消息的到达时刻竟然比消息的发送时刻还要早</strong>，这显然是不合理的，必须避免这种情况发生。</p><p>Lamport给出的解决方案是直接遵循「先发生关系」。消息c在时钟值为50时离开，那么它只能在时钟值为51或更晚时到达。所以每个消息都应该携带发送者时钟的「发送时间」。<strong>当消息到达，并且接受者时钟显示的时间值比消息的发送时间早时，接受者就把它的时钟调到一个比发送时间大1的值</strong>。调整后的过程图如下所示。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/lamport_logical_clock.png" alt="lamport_logical_clock"></p><p>对这个算法稍作补充就可以满足全局时间的需要，即在每两个事件之间，时钟必须至少「滴答」一次。如果一个进程以相当快的速度连续发送或接收两个消息，那么它的时钟必须在这之间至少「滴答」一次。</p><p><strong>在某些情况下还需要一个附加条件，即两个事件不会精确的同时发生。为了达到这个目标，我们可以将事件发生的进程号附加在时间的低位后，并用小数点分隔开。</strong>使用这种方法，如果进程1和进程2同时在40时刻发生了一个事件，那么前者可以标记为「40.1」，后者可以标记为「40.2」。</p><p>通过使用这种方法，我们现在有了一个为分布式系统中的所有事件分配时间的方法，这遵循下面的规则：</p><ol><li>若在同一进程中a在b之前发生，则$C(a)&lt;C(b)$；</li><li>若a和b分别代表发送一个消息和接受该消息的事件，则C(a)&lt;C(b)；</li><li>对于所有不同的事件a和b，$C(a) \neq C(b)$；</li></ol><p>这个算法为我们提供了一种对系统中所有的事件进行完全排序的方法。许多其他的分布式算法都需要这种排序以避免混淆，所以此算法在各种文献被广泛引用。</p><h2 id="向量时间戳"><a href="#向量时间戳" class="headerlink" title="向量时间戳"></a>向量时间戳</h2><p>Lamport时间戳导致分布式系统中的所有事件都要经过排序以具有这样的性质：如果事件a发生在事件b之前，那么a也应该排在b之前，即$C(a) &lt; C(b)$。</p><p>然而，使用Lamport时间戳后，只通过比较事件a和b各自的时间值$C(a)$和$C(b)$，无法说明它们之间的关系。换句话说，$C(a) &lt; C(b)$不能说明事件a就是在事件b之前发生的。问题在于Lamport时间戳不能捕获因果关系（causality）。</p><p>因果关系可以通过向量时间戳（Vector Timestamp）来捕获。分配给<strong>事件a</strong>的**向量时间戳 $VT(a)$**具有下列性质：如果对于某一事件b，有 $VT(a) &lt; VT(b)$，那么认为事件a在因果关系上处于事件b之前。</p><p>向量时间戳的创建是通过让**每个进程$P_n$维护一个向量$V_n$**来实现的，该向量具有下面两个性质：</p><ul><li>$V_i[i]$是到目前为止<strong>进程</strong>$P_i$发生的事件的数量；</li><li>如果$V_i[j] = k$，那么<strong>进程</strong>$P_i$知道<strong>进程</strong>$P_j$中已经发生了$k$个事件；</li></ul><p>第一个性质是通过在**进程$P_i$中的新事件发生时递增$V_i[i]$**来维护的。</p><p>第二个性质是通过在所发送的消息中携带向量时间戳来维护的，<strong>当进程$P_i$发送消息$m$时，它将自己的当前向量作为时间戳$vt(m)$一起发送。</strong></p><p>通过使用这种方式，接受者可以得知进程$P_i$中已经发生的事件数。更重要的是，接受者可以得知在进程$P_i$发送消息$m$之前其他进程已经发生了多少个事件。<strong>换句话说，消息$m$的时间戳$vt(m)$告诉接受者其他进程中有多少事件发生在消息$m$之前，并且$m$可能在因果关系上依赖于这些事件。</strong></p><p>进程$P_j$依赖于其接收到的消息来调整自己所维护的向量。<strong>当进程$P_j$在接收到消息$m$时，它调整自己的向量，将每项$V_j[k]$设置为$max{V_j[k], vt(m)[k]}$。该向量现在反映了进程$P_j$所必须接受到消息数目，该消息数目至少是在发送$m$之前见到的消息。此后将$V_j[i]$增1，这表示接受消息$m$的事件是来自于进程$P_i$的下一个事件。</strong></p><p>只在不违背因果关系限制时，才能使用向量时间戳来传递消息。</p><p><strong>示例：</strong></p><p>我们来考虑一个电子公告板的例子。当进程$P_i$张贴一篇文章时，它将改文章作为消息$a$广播出去，并且在该消息上附加一个时间戳$vt(a)$，其值等于$V_i$。当另一个进程$P_j$接收到消息$a$时，它将根据其携带的时间戳$vt(a)$来调整自己的向量，以使$V_j[i] &gt; vt(a)[i]$。</p><p>假设进程$P_j$在收到消息$a$后广播了一个该文章的回复消息$r$，消息$r$携带值等于$V_j$的时间戳$vt(r)$。需要注意的是$vt(r)[i] &gt; vt(a)[i]$。假设通信是可靠的，包含文章的消息$a$和包含回复的消息$r$最终都到达了另一个进程$P_k$。</p><p>因为我们没有对消息的顺序关系做出假设，所以消息$r$可能在消息$a$之前到达进程$P_k$。进程$P_k$接受到消息$r$时检查其时间戳，并决定推迟提交消息$r$，直到因果关系上位于$r$之前的消息都接受到了才提交$r$。消息$r$ 只有在满足下列条件时才得到交付：</p><ol><li>$vt(r)[j] = V_k[j] + 1$；</li><li>对于所有满足$i \neq j$的$i$和$j$，$vt(r)[i] &lt; V_k[i]$；</li></ol><p>第一个条件说明$r$是进程$P_k$正在等待的下一条来自进程$P_j$的消息；</p><p>第二个条件说明当进程$P_j$发送消息$r$时，进程$P_k$只看到被进程$P_j$看到的消息。这意味着进程$P_k$已经看到了消息$a$。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/because.drawio.png" alt="because.drawio"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>分布式系统原理与范型</tag>
      
      <tag>时钟同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Google File System</title>
    <link href="/2021/10/05/%E8%AF%BB%E8%AE%BA%E6%96%87/The%20Google%20File%20System/"/>
    <url>/2021/10/05/%E8%AF%BB%E8%AE%BA%E6%96%87/The%20Google%20File%20System/</url>
    
    <content type="html"><![CDATA[<h1 id="论文介绍"><a href="#论文介绍" class="headerlink" title="论文介绍"></a>论文介绍</h1><h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><h3 id="论文名"><a href="#论文名" class="headerlink" title="论文名"></a>论文名</h3><p>The Google File System</p><h3 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h3><p>Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung</p><h3 id="期刊-会议"><a href="#期刊-会议" class="headerlink" title="期刊/会议"></a>期刊/会议</h3><p> SOSP’03, October 19–22, 2003, Bolton Landing, New York, USA. </p><h2 id="论文摘要"><a href="#论文摘要" class="headerlink" title="论文摘要"></a>论文摘要</h2><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">「The Google File System」</a></p><h3 id="阅读参考"><a href="#阅读参考" class="headerlink" title="阅读参考"></a>阅读参考</h3><p><a href="http://duanple.com/?p=202">「google论文二Google文件系统(上)」</a></p><h1 id="阅读摘要-amp-笔记"><a href="#阅读摘要-amp-笔记" class="headerlink" title="阅读摘要&amp;笔记"></a>阅读摘要&amp;笔记</h1><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>We have designed and implemented the Google File System, a scalable distributed file system for large distributed data-intensive applications. It provides fault tolerance while running on inexpensive commodity hardware, and it delivers high aggregate performance to a large number of clients.</p><p>我们设计实现了Google文件系统，一个应用于大型分布式数据密集型应用程序的可扩展分布式文件系统。它在运行于廉价硬件设备的同时提供容错性，并为大量的客户端提供高聚合性能。</p><p>While sharing many of the same goals as previous distributed file systems, our design has been driven by observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system assumptions. This has led us to reexamine traditional choices and explore radically different design points.</p><p>虽然于很多之前的分布式文件系统有相同的目标，但是我们的设计是基于对我们的应用程序负载和技术环境的观察所驱动的，这反映了与早先的分布式文件系统的设计思想的明显背离。这促使我们重新审视传统的选择，并探索根本不同的设计要点。</p><p>The file system has successfully met our storage needs. It is widely deployed within Google as the storage platform for the generation and processing of data used by our service as well as research and development efforts that require large data sets. The largest cluster to date provides hundreds of terabytes of storage across thousands of disks on over a thousand machines, and it is concurrently accessed by hundreds of clients.</p><p>此文件系统成功的满足了我们的存储需要。它被广泛的部署在Google内部，并且作为产生和处理我们的服务所需要的数据，以及需要大型数据集的研究和开发工作的存储平台。迄今为止最大的集群在超过一千台机器上的数千个磁盘上提供数百 TB 的存储，并且它被数百个客户端同时访问。</p><p>In this paper, we present file system interface extensions designed to support distributed applications, discuss many aspects of our design, and report measurements from both micro-benchmarks and real world use.</p><p>在本文中，我们介绍了旨在支持分布式应用程序的文件系统接口扩展，讨论了我们设计的许多方面，并报告了来自微基准测试和现实世界使用的测试结果。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>GFS shares many of the same goals as previous distributed file systems such as performance, scalability, reliability, and availability.</p><p>GFS和之前的大多数分布式系统一样，其主要设计目标是：性能、可扩展性、可靠性和可用性。</p><p>However, its design has been driven by key observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system design assumptions.</p><p>与早先的分布式系统的区别在于，它的设计是由我们当前和预期的应用负载和技术环境所驱动的。</p><p>We have reexamined traditional choices and explored radically different points in the design space.</p><p>我们重新审视了传统设计的选择，并在设计空间上探索了根本不同的设计要点。</p><ul><li>First, component failures are the norm rather than the exception.Therefore, constant monitoring, error detection, fault tolerance, and automatic recovery must be integral to the system.</li><li>Second, files are huge by traditional standards. Multi-GB files are common.As a result, design assumptions and parameters such as I/O operation and block sizes have to be revisited.</li><li>Third, most files are mutated by appending new data rather than overwriting existing data.Random writes within a file are practically non-existent. Once written, the files are only read, and often only sequentially.Given this access pattern on huge files, appending becomes the focus of performance optimization and atomicity guarantees, while caching data blocks in the client loses its appeal.</li><li>Fourth, co-designing the applications and the file system API benefits the overall system by increasing our flexibility.For example, we have relaxed GFS’s consistency model to vastly simplify the file system without imposing an onerous burden on the applications. We have also introduced an atomic append operation so that multiple clients can append concurrently to a file without extra synchronization between them.</li><li>我们将设备故障视为常态而不是意外。因此，持续监控、错误检测、容错性和自动恢复性必须作为系统不可或缺的一部分。</li><li>按照传统的标准，文件是巨大的。GB大小的文件是常态。因此必须重新考虑设计假设和参数，例如I/O操作和块大小。</li><li>大多数文件是通过追加操作而不是覆盖写来改变的。随机写操作很少出现，一旦写入后，大多数文件通常是只读的，并且是顺序读取。鉴于这种大文件的访问模式，追加操作成为性能优化和原子性保证的重点，而客户端的数据块缓存则失去了吸引力。</li><li>结合应用程序和文件系统一块设计API，能通过提高灵活性来使整个系统收益。例如，我们通过放松对GFS的一致性模型来简化文件系统，而不会对应用程序带来较大的负担。我们还通过引入原子性的追加操作来使多个客户端可以并发行的对同一个文件进行追加操作，而无需在它们之间进行额外的同步。</li></ul><h1 id="2-Design-Overview"><a href="#2-Design-Overview" class="headerlink" title="2 Design Overview"></a>2 Design Overview</h1><h2 id="2-1-Assumptions"><a href="#2-1-Assumptions" class="headerlink" title="2.1 Assumptions"></a>2.1 Assumptions</h2><p>We alluded to some key observations earlier and now lay out our assumptions in more details.</p><p>我们之前提到了一些关键性的观察结果，现在我们对它们进行更详细的描述。</p><ul><li>The system is built from many inexpensive commodity components that often fail. It must constantly monitor itself and detect, tolerate, and recover promptly from component failures on a routine basis.</li><li>The system stores a modest number of large files.Multi-GB files are the common case<br>and should be managed efficiently. Small files must be supported, but we need not optimize for them.</li><li>The workloads primarily consist of two kinds of reads: large streaming reads and small random reads.<ul><li>In large streaming reads, individual operations typically read hundreds of KBs, more commonly 1 MB or more.Successive operations from the same client often read through a contiguous region of a file.</li><li>A small random read typically reads a few KBs at some arbitrary offset. Performance-conscious applications often batch and sort their small reads to advance steadily through<br>the file rather than go back and forth.</li></ul></li><li>The workloads also have many large, sequential writes that append data to files. Typical operation sizes are similar to those for reads. Once written, files are seldom modified again. Small writes at arbitrary positions in a file are supported but do not have to be efficient.</li><li>The system must efficiently implement well-defined semantics for multiple clients that concurrently append to the same file.</li><li>High sustained bandwidth is more important than low latency. Most of our target applications place a premium on processing data in bulk at a high rate, while few have stringent response time requirements for an individual read or write.</li><li>系统由很多经常出问题的廉价设备组成。它们必须持续自我监视，并定期检测、容错并迅速从组件故障中恢复。</li><li>系统中存储着大量的大文件数据。GB大小的文件是作为常态存在的，并且必须进行高效的管理。同时，系统也必须支持小型文件，但不必对此进行优化。</li><li>工作负载主要由两种读操作组成：大规模的流读取和小规模的随机读取。<ul><li>在大规模的流读取中，每次操作通常读取几百KB，更常见的是1MB或更多。来自同一客户端连续读操作通常会读取文件的连续区域。</li><li>一个小的随机读操作通常会以任意偏移量读取几KB。注重性能的应用程序通常会对这些小的读取操作进行批处理和排序，以持续稳定推进文件的读操作，而不是来回读取。</li></ul></li><li>工作负载中也会有很多大的连续写操作追加数据到文件。一般数据大小和读操作类似。一旦写入后文件很少被修改。小的任意写操作必须支持，但不必支持高效性。</li><li>系统必须实现高效的、良好定义的语义，以支持大量客户端对同一文件的并发追加写操作。</li><li>高持续带宽比低延迟更重要。我们的大多数目标应用程序都非常重视以高速率批量处理数据，而对单个读或写操作的响应时间并没有严格的要求。</li></ul><h2 id="2-2-Interface"><a href="#2-2-Interface" class="headerlink" title="2.2 Interface"></a>2.2 Interface</h2><p>GFS provides a familiar file system interface, though it does not implement a standard API such as POSIX. Files are organized hierarchically in directories and identified by pathnames. We support the usual operations to <code>create</code>, <code>delete</code>, <code>open</code>, <code>close</code>, <code>read</code>, and <code>write</code> files.</p><p>GFS提供了一个熟悉的文件系统接口，虽然它并没有实现像POSIX标准那样的标准API接口。文件在目录中分层组织，并由路径名标识。我们还支持文件的一些常见操作，如<code>create</code>、<code>delete</code>、<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>。</p><p>Moreover, GFS has <code>snapshot</code> and <code>record append</code> operations. Snapshot creates a copy of a file or a directory tree at low cost. Record append allows multiple clients to append data to the same file concurrently while guaranteeing the atomicity of each individual client’s append. It is useful for implementing multi-way merge results and producer-consumer queues that many clients can simultaneously append to without additional locking. We have found these types of files to be invaluable in building large distributed applications. Snapshot and record append are discussed further in Sections 3.4 and 3.3 respectively.</p><p>此外，GFS支持<strong>快照</strong>和<strong>追加</strong>写操作。快照会以低开销创建一个文件或目录树的拷贝。追加写操作允许大量客户端并发向同一个文件追加写，并且保证每个客户端的追加写都是原子性的。这对实现多路合并操作和生产者-消费者队列非常有用，许多客户端可以同时进行追加操作而不需要额外的加锁处理。我们发现这些类型的文件对构建大型分布式应用非常宝贵。快照和追加写操作将在3.4节和3.3节中进一步讨论。</p><h2 id="2-3-Architecture"><a href="#2-3-Architecture" class="headerlink" title="2.3 Architecture"></a>2.3 Architecture</h2><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/GFS_Figure1.png" alt="Untitled"></p><p>A GFS cluster consists of a single master and multiple chunk-servers and is accessed by multiple clients, as shown in Figure 1.</p><p>如图1所示，一个GFS集群由一个Master和大量的被很多Client访问的Chunk Server组成。</p><p>Files are divided into fixed-size chunks. Each chunks identified by an immutable and globally unique 64 bit chunk handle assigned by the master at the time of chunk creation.Chunk servers store chunks on local disks as Linux files and read or write chunk data specified by a chunk handle and byte range. For reliability, each chunks replicated on multiple chunk servers. By default, we store three replicas, though users can designate different replication levels for different regions of the file namespace.</p><p>文件被划分为固定大小的Chunk。每个Chunk在创建时由Master分配一个不可变的，并且全局唯一的64位Chunk Handle标识。Chunk Server将Chunks作为Linux文件存储在本地磁盘上，读写操作都由Chunk Handle和字节边界来明确。为了可靠性，每个Chunk被复制存储到多个Chunk Server上。虽然用户可以为文件命名空间的不同区域指定不同的备份级别，但通常默认为三个备份。</p><p>The master maintains all file system metadata. This includes the namespace, access control information, the mapping from files to chunks, and the current locations of chunks. It also controls system-wide activities such as chunk lease management, garbage collection of orphaned chunks, and chunk migration between chunk servers. The master periodically communicates with each chunk server in HeartBeat messages to give it instructions and collect its state.</p><p>集群Master保存了文件系统的所有元数据。这包括，命名空间、访问控制信息、文件和Chunk的映射关系，以及Chunk的当前保存位置。它也控制系统范围内的一些活动，比如Chunk租约管理、孤立块的垃圾回收，以及Chunk在Chunk Server之间的迁移。 Master还会周期性的和Chunk Server进行交流，通过心跳信息下发指令和收集Chunk Server状态。</p><p>GFS client code linked into each application implements the file system API and communicates with the master and chunk servers to read or write data on behalf of the application. Clients interact with the master for metadata operations, but all data-bearing communication goes directly to the chunk servers.</p><p>链接到应用程序的客户端代码实现了文件系统API，并且代表应用程序与Master和Chunk Server通信以读写数据。客户端与主机交互以进行元数据操作，但所有的数据通信都是直接发送到Chunk Server。</p><p>Neither the client nor the chunk server caches file data. Client caches offer little benefit because most applications stream through huge files or have working sets too large to be cached. Not having them simplifies the client and the overall system by eliminating cache coherence issues. (Clients do cache metadata, however.) Chunk servers need not cache file data because chunks are stored as local files and so Linux’s buffer cache already keeps frequently accessed data in memory.</p><p>客户端和Chunk Server都不需要缓存文件数据。客户端缓存并不会带来明显的好处，因为大多数应用程序通过数据流与大型文件传输数据，或者因为数据量太大而无法缓存。去掉缓存可以简化客户端，以及整个系统（没有因缓存一致性而带来的问题）。Chunk Server不需要缓存文件数据，因为Chunk是作为本地文件存储的，所以Linux的Cache缓存已经将经常访问的数据保存在了内存中。（利用了操作系统的缓存）</p><h2 id="2-4-Single-Master"><a href="#2-4-Single-Master" class="headerlink" title="2.4 Single Master"></a>2.4 Single Master</h2><p>Having a single master vastly simplifies our design and enables the master to make sophisticated chunk placement and replication decisions using global knowledge.However, we must minimize its involvement in reads and writes so that it does not become a bottleneck. Clients never read and write file data through the master. Instead, a client asks the master which chunk servers it should contact. It caches this information for a limited time and interacts with the chunk servers directly for many subsequent operations.</p><p>仅有一个Master大大简化了我们的设计，并且使其能够利用全局知识做出复杂的决策以确定Chunk的放置位置和复制。但是，我们必须减少其所参与的读写操作，以保证它不会成为整个系统的瓶颈。客户端只是通过向Master询问它应该联系的Chunk Server信息，而不是通过Master直接读写数据，并且客户端会将其请求得到的信息缓存一段时间，在此时间段内它可以与Chunk Server直接交互而不需要向Master询问信息。</p><p>Let us explain the interactions for a simple read with reference to Figure 1.</p><ul><li>First, using the fixed chunk size, the client translates the file name and byte offset specified by the application into a chunk index within the file.</li><li>Then, it sends the master a request containing the file name and chunk index.</li><li>The master replies with the corresponding chunk handle and locations of the replicas. The client caches this information using the file name and chunk index as the key.</li><li>The client then sends a request to one of the replicas, most likely the closest one. The request specifies the chunk handle and a byte range within that chunk. Further reads of the same chunk require no more client-master interaction until the cached information expires or the file is reopened.</li></ul><p>In fact, the client typically asks for multiple chunks in the same request and the master can also include the information for chunks immediately following those requested. This extra information sidesteps several future client-master interactions at practically no extra cost.</p><p>我们根据图1来解释一个读操作的交互过程：</p><ul><li>首先，根据Chunk的固定大小，客户端通过应用程序中标识的文件名和字节偏移量转换为Chunk索引。</li><li>然后，客户端将包含文件名和Chunk索引的请求信息发送给Master。</li><li>Master向客户端响应Chunk Handle和一个Chunk副本的位置信息，客户端使用Chunk索引作为键值对中的键来缓存该信息。</li><li>客户端随后会向一个Chunk副本发送请求信息，通常是距离较近的副本。请求会标识Chunk Handle和字节边界。直到缓存信息到期或重新打开该文件前，客户端请求同一Chunk都不再需要和Master交互。</li></ul><p>实际上，会在一个查询请求信息中包含多个Chunk请求，Master也会将多个Chunk的信息封装在一个响应包中发回给客户端。这些额外的信息不需要其他成本就可以减少客户端和Master的几次交互操作。</p><h2 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h2><p>Chunk size is one of the key design parameters. We have chosen 64 MB, which is much larger than typical file system block sizes. Each chunk replica is stored as a plain Linux file on a chunk server and is extended only as needed. Lazy space allocation avoids wasting space due to internal fragmentation, perhaps the greatest objection against such a large chunk size.</p><p>Chunk的大小是设计中的关键参数。我们选择的64MB大小，远远大于典型的文件系统的块大小。每个Chunk副本都作为普通的Linux文件存储在Chunk Server中，并且只有在需要时才会进行扩展。懒空间分配避免了由于内部碎片所导致的空间浪费，可能产生的最大的碎片有一个Chunk那么大。</p><blockquote><p>惰性空间分配：使用惰性空间分配时，空间的物理分配会尽可能延迟，直到累积了块大小大小的数据(在GFS的默认情况为下为64 MB)。</p></blockquote><p>A large chunk size offers several important advantages.</p><ul><li>First, it reduces clients’ need to interact with the master because reads and writes on the same chunk require only one initial request to the master for chunk location information.</li><li>Second, since on a large chunk, a client is more likely to perform many operations on a given chunk, it can reduce network overhead by keeping a persistent TCP connection to the chunk server over an extended period of time.</li><li>Third, it reduces the size of the metadata stored on the master. This allows us to keep the metadata in memory, which in turn brings other advantages that we will discuss in Section 2.6.1.</li></ul><p>大的Chunk大小带来了以下重要的优势：</p><ul><li>首先，这减少了Client与Master多次交互的需要，因为Client可以将Chunk的位置信息缓存到本地，所以对于同一个Chunk的读写操作，Client只需要与Master进行一次请求。</li><li>其次，对于一个较大的Chunk，客户端可能在此块上进行更多的操作，这样就可以通过延长TCP连接时间来减少网络开销。</li><li>最后，这减少了存储在Master上的元数据大小。这就可以使master在内存保存更多的元数据，反过来这就带来了我们在2.6.1节中讨论的其他优势。</li></ul><p>On the other hand, a large chunk size, even with lazy space allocation, has its disadvantages. A small file consists of a small number of chunks, perhaps just one. The chunk servers storing those chunks may become hot spots if many clients are accessing the same file. In practice, hot spots have not been a major issue because our applications mostly read large multi-chunk files sequentially.</p><p>另一方面，使用大的Chunk，即使利用了惰性空间分配，也存在它的缺点。一个小型文件只有几个Chunk组成，甚至可能只有一个。存储这些Chunk的Chunk Server可能因为会被大量客户端访问同一个文件而成为访问热点。实际上，访问热点并不是一个主要的问题，因为我们的应用主要是顺序读取那些由很多Chunk组成的大文件。</p><h2 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h2><p>The master stores three major types of metadata: the file and chunk namespaces, the mapping from files to chunks, and the locations of each chunk’s replicas. </p><p>Master存储三种类型的元数据：文件和Chunk命名空间、文件到Chunk的映射关系、每个Chunk副本的位置信息。</p><p>All metadata is kept in the master’s memory. The first two types (namespaces and file-to-chunk mapping) are also kept persistent by logging mutations to an operation log stored on the master’s local disk and replicated on remote machines. Using a log allows us to update the master state simply, reliably, and without risking inconsistencies in the event of a master crash. The master does not store chunk location information persistently. Instead, it asks each chunk server about its chunks at master startup and whenever a chunk server joins the cluster.</p><p>所有的元数据信息都被Master保存在它的内存中。前两种类型的元数据（命名空间和文件到Chunk的映射）还通过操作日志更新到本地磁盘以及备份到远程的机器来保证数据持久化。使用日志可以使我们简单、可靠的更新Master的状态，而不用担心在Master故障时造成不一致性的危险。Master不会持久化的存储Chunk的位置信息，因为，它会在启动的时候，以及Chunk Server加入集群的时候询问每个Chunk Server的Chunk信息。</p><h3 id="2-6-1-In-Memory-Data-Structures"><a href="#2-6-1-In-Memory-Data-Structures" class="headerlink" title="2.6.1 In-Memory Data Structures"></a>2.6.1 In-Memory Data Structures</h3><p>Since metadata is stored in memory, master operations are fast. Furthermore, it is easy and efficient for the master to periodically scan through its entire state in the background. This periodic scanning is used to implement chunk garbage collection, re-replication in the presence of chunk server failures, and chunk migration to balance load and disk space usage across chunk servers. Sections 4.3 and 4.4 will discuss these activities further.</p><p>元数据被存储到Master的内存中后，Master对元数据的操作会非常快。此外，Master能在后台简单有效的完成对整体状态的周期性扫描。这个周期性的扫描主要用于：Chunk的垃圾回收，Chunk Server出现问题时的重新复制，Chunk迁移以平衡负载，以及Chunk Server的磁盘空间利用。4.3节和4.4节将会进一步讨论这些活动。</p><p>One potential concern for this memory-only approach is that the number of chunks and hence the capacity of the whole system is limited by how much memory the master has. This is not a serious limitation in practice. The master maintains less than 64 bytes of metadata for each 64 MB chunk. Most chunks are full because most files contain many chunks, only the last of which may be partially filled. Similarly, the file namespace data typically requires less than 64 bytes per file because it stores file names compactly using prefix compression.</p><p>这种使用内存的方法潜存的一种担心是，这些Chunk的数量以及整个系统的容量会受到Master内存空间的限制。实际上，这并不是一个严重的问题。Master对于每个64MB大小的Chunk保存少于64字节的元数据。因为大多数文件包含大量的Chunk，因此大多数Chunk都是满的，可能只有最后一个Chunk是部分填充后的。类似的，文件命名空间通常对于每个文件也只需要少于64字节的，因为它们存储的文件名是使用前缀紧凑压缩后的。</p><p>If necessary to support even larger file systems, the cost of adding extra memory to the master is a small price to pay for the simplicity, reliability, performance, and flexibility we gain by storing the metadata in memory.</p><p>即使需要支持更大的文件系统，为Master增加内存来将元数据存储在内存中，以获得简单型、可靠性、性能以及灵活性而花费的额外的钱也是很小的代价。</p><h3 id="2-6-2-Chunk-Locations"><a href="#2-6-2-Chunk-Locations" class="headerlink" title="2.6.2 Chunk Locations"></a>2.6.2 Chunk Locations</h3><p>The master does not keep a persistent record of which chunk servers have a replica of a given chunk. It simply polls chunk servers for that information at startup. The master can keep itself up-to-date thereafter because it controls all chunk placement and monitors chunk server status with regular HeartBeat messages.<br>Master并不会持久化那些拥有Chunk副本的Chunk Server给定的每个Chunk记录。它只是会在启动时轮询每个Chunk Server来获得这些信息。Master可以在此之后保证自己持有最新的信息，因为它控制Chunk的放置位置，以及通过与Chunk Server交换心跳信息来监听Chunk Server 状态。</p><p>We initially attempted to keep chunk location information persistently at the master, but we decided that it was much simpler to request the data from chunk servers at startup, and periodically thereafter. This eliminated the problem of keeping the master and chunk servers in sync as chunk servers join and leave the cluster, change names, fail, restart, and so on. In a cluster with hundreds of servers, these events happen all too often.</p><p>我们一开始也尝试过在Master中持久化Chunk的位置信息，但是后来我们发现，在启动时向每个Chunk Server来请求数据是更简单的方法。这消除了在Chunk Server加入和离开集群、更改名称、失败、重启等时，Master必须与Chunk Server保持同步的问题。而这些问题在具有几百台服务器的集群中是经常发生的。</p><p>Another way to understand this design decision is to realize that a chunk server has the final word over what chunks it does or does not have on its own disks. There is no point in trying to maintain a consistent view of this information on the master because errors on a chunk server may cause chunks to vanish spontaneously (e.g., a disk may go bad and be disabled) or an operator may rename a chunk server.</p><p>理解此设计决策的另一种方式是，意识到Chunk Server对它自己有没有某个Chunk拥有最终发言权（即只有Chunk Server才能确定他自己到底有没有某个Chunk）。试图在Master上维护此信息的一致性视图是没有意义的，因为在Chunk Server上发生的各种错误都可能会导致存储的Chunk自发性的消失（例如，磁盘可能会发生故障而无法使用），或者一个操作员可能会重命名一个Chunk Server。</p><h3 id="2-6-3-Operation-log"><a href="#2-6-3-Operation-log" class="headerlink" title="2.6.3 Operation log"></a>2.6.3 Operation log</h3><p>The operation log contains a historical record of critical metadata changes. It is central to GFS. Not only is it the only persistent record of metadata, but it also serves as a logical time line that defines the order of concurrent operations. Files and chunks, as well as their versions (see Section 4.5), are all uniquely and eternally identified by the logical times at which they were created.</p><p>操作日志包含了关键元数据改变的历史记录。它是GFS的核心。它不仅是元数据的唯一持久化数据，并且还充当定义并发操作顺序的时间线。文件和Chunk，以及它们的版本，都由它们创建时的逻辑时间唯一且永久标识。</p><p>Since the operation log is critical, we must store it reliably and not make changes visible to clients until metadata changes are made persistent. Otherwise, we effectively lose the whole file system or recent client operations even if the chunks themselves survive. Therefore, we replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely. The master batches several log records together before flushing thereby reducing the impact of flushing and replication on overall system throughput.</p><p>因为操作日志非常重要，因此我们必须可靠的存储它，并且在对元数据的更改持久化之前不能使这些改变对客户端可见。否则，我们很可能失去整个的文件系统或最近的客户端操作，即使Chunks保存下来。因此，我们将其复制到多台远程的机器上，并且仅在本地和远程的机器将相应的日志刷新到磁盘上之后才向客户端响应。Master在刷新前将操作记录进行批处理，以减少刷新和复制对整个系统吞吐量的影响。</p><p>The master recovers its file system state by replaying the operation log. To minimize startup time, we must keep the log small. The master checkpoints its state whenever the log grows beyond a certain size so that it can recover by loading the latest checkpoint from local disk and replaying only the limited number of log records after that. The checkpoint is in a compact B-tree like form that can be directly mapped into memory and used for namespace lookup without extra parsing. This further speeds up recovery and improves availability.</p><p>Master通过重放操作日志来恢复其文件系统状态。为了减少启动时间，我们必须使日志记录尽可能的小。每当日志记录超过指定的大小时，Master都会检查它自身的状态，以便它可以通过从本地磁盘加载最新的检查点，再通过重放有限数量的日志记录来恢复文件系统状态。检查点采用类似B树的紧凑形式，可以直接映射到内存中，在无需额外解析的下用于命名空间的查找。这加速了文件系统的恢复过程，并且提高了可用性。</p><p>Because building a checkpoint can take a while, the master’s internal state is structured in such a way that a new checkpoint can be created without delaying incoming mutations. The master switches to a new log file and creates the new checkpoint in a separate thread. The new checkpoint includes all mutations before the switch. It can be created in a minute or so for a cluster with a few million files. When completed, it is written to disk both locally and remotely.</p><p>由于构建检查点需要一定的时间，因此，Master的内部状态以这样的一种方式来构建检查点，即在不延迟传入新的突变的情况下构建新的检查点。Master切换到一个新的日志文件中，并且在一个单独的线程中创建一个新的检查点。新的检查点包含在切换之前的所有突变。它需要1分钟左右的时间来为具有几百个文件的集群来创建检查点。创建完成后，它会被写到本地和远程的磁盘中。</p><p>Recovery needs only the latest complete checkpoint and subsequent log files. Older checkpoints and log files can be freely deleted, though we keep a few around to guard against catastrophes. A failure during checkpointing does not affect correctness because the recovery code detects and skips incomplete checkpoints.</p><p>文件系统恢复只需要最新的完整检查点以及后续的日志文件。较旧的检查点和日志文件可以自由删除，但我们也保留了一些来为抵抗灾难做保证。检查点期间的错误不会影响正确性，因为恢复代码会检测并跳过不完整的检查点。</p><h2 id="2-7-Consistency-Model"><a href="#2-7-Consistency-Model" class="headerlink" title="2.7 Consistency Model"></a>2.7 Consistency Model</h2><p>GFS has a relaxed consistency model that supports our highly distributed applications well but remains relatively simple and efficient to implement. We now discuss GFS’s guarantees and what they mean to applications. We also highlight how GFS maintains these guarantees but leave the details to other parts of the paper.</p><p>GFS使用的相对宽松的一致性模型不但能很好的支持我们的高度分布式应用程序，而且保证了实现上的简单和高效。我们现在讨论GFS所提供的保证，以及它们对应用程序来说意味着什么。我们还会强调GFS如何维护这些保证，但会将具体的细节留给论文的其他部分来描述。</p><h3 id="2-7-1-Guarantees-by-GFS"><a href="#2-7-1-Guarantees-by-GFS" class="headerlink" title="2.7.1 Guarantees by GFS"></a>2.7.1 Guarantees by GFS</h3><p>File namespace mutations (e.g., file creation) are atomic.They are handled exclusively by the master: namespace locking guarantees atomicity and correctness (Section 4.1); the master’s operation log defines a global total order of these operations (Section 2.6.3).</p><p>文件命名空间的改变是原子性的。它们仅由Master来处理：命名空间锁来保证原子性和正确性；Master的操作日志定义了这些操作的全局总顺序。</p><p><img src="https://ap0l1o.oss-cn-qingdao.aliyuncs.com/img/GFS_Table1.png" alt="Untitled"></p><p>The state of a file region after a data mutation depends on the type of mutation, whether it succeeds or fails, and whether there are concurrent mutations. Table 1 summarizes the result. </p><p>数据变更后文件区域的状态依赖于变更的类型，数据变更成功还是失败，以及是否存在并发行变更。表1对这些结果进行了总结。</p><p>A file region is consistent if all clients will always see the same data, regardless of which replicas they read from. A region is defined after a file data mutation if it is consistent and clients will see what the mutation writes in its entirety. </p><ul><li>When a mutation succeeds without interference from concurrent writers, the affected region is defined (and by implication consistent): all clients will always see what the mutation has written.</li><li>Concurrent successful mutations leave the region undefined but consistent: all clients see the same data, but it may not reflect what any one mutation has written. Typically, it consists of mingled fragments from multiple mutations.</li><li>A failed mutation makes the region inconsistent (hence also undefined): different clients may see different data at different times.</li></ul><p>如果客户端无论从哪个副本都能看到一样的数据，则文件区域是一致性的。如果一个文件数据在变更后是一致性的，并且客户端能看到变更写入的内容，则该区域是定义良好的。</p><ul><li>当一个变更成功并且不受其他并发写入的干扰时，受影响的区域是定义良好的（同时意味着是一致性的）：所有客户端都能看到变更所写入的内容。</li><li>并发的成功变更所影响的区域是一致的，但不是定义良好的：所有的客户端都能看到相同的数据，但并不能反映出每个变更所写入的内容。通常，这由多个变更混合片段组成。</li><li>一个失败的变更会导致区域处于不一致的状态（因此也不是定义良好的）：不同的客户端在不同的时间段能看到不同的数据。</li></ul><p>We describe below how our applications can distinguish defined regions from undefined regions. The applications do not need to further distinguish between different kinds of undefined regions.</p><p>我们会在下面描述我们的应用程序如何区分定义良好的区域和非定义良好的区域。应用程序不需要进一步区分各种不同的非定义良好的区域。</p><p>Data mutations may be writes or record appends. A write causes data to be written at an application-specified file offset. A record append causes data (the “record”) to be appended atomically at least once even in the presence of concurrent mutations, but at an offset of GFS’s choosing (Section 3.3). (In contrast, a “regular” append is merely a write at an offset that the client believes to be the current end of file.) The offset is returned to the client and marks the beginning of a defined region that contains the record. In addition, GFS may insert padding or record duplicates in between. They occupy regions considered to be inconsistent and are typically dwarfed by the amount of user data.</p><p>数据变更可能是写入或者是记录追加。写入会将数据写入到应用程序指定的文件偏移位置。记录追加会使数据（也即记录record）至少原子性的追加一次，即使是在并发变更的情况下，但是偏移位置是由GFS决定的（相比之下，「常规」追加只是一次客户端认为的文件当前结尾偏移处的写入操作）。偏移量返回给客户端，并且标记包含追加记录的定义良好的区域的开始位置。此外，GFS可能会在它们之间插入填充或者是记录副本。这些插入的内容会占据被认为是不一致的区域，通常它们比用户数据小很多。</p><p>After a sequence of successful mutations, the mutated file region is guaranteed to be defined and contain the data written by the last mutation. GFS achieves this by </p><ul><li>(a) applying mutations to a chunk in the same order on all its replicas(Section 3.1),</li><li>and (b) using chunk version numbers to detect any replica that has become stale because it has missed mutations while its chunk server was down (Section 4.5). Stale replicas will never be involved in a mutation or given to clients asking the master for chunk locations. They are garbage collected at the earliest opportunity.</li></ul><p>在一系列成功的变更后，文件变更区域会被保证是定义良好的，并且包含最后一次变更写入的数据。GFS通过以下方式来实现：</p><ul><li>将对一个Chunk的变更以同样的顺序应用到该Chunk的所有副本中；</li><li>使用Chunk版本号来检测那些由于Chunk Server 宕机而错过变更数据的陈旧副本。陈旧的副本将不会在参与数据变更或者向客户端响应请求。它们会优先参与垃圾回收。</li></ul><p>Since clients cache chunk locations, they may read from a stale replica before that information is refreshed. This window is limited by the cache entry’s timeout and the next open of the file, which purges from the cache all chunk information for that file. Moreover, as most of our files are append-only, a stale replica usually returns a premature end of chunk rather than outdated data. When a reader retries and contacts the master, it will immediately get current chunk locations.</p><p>客户端会缓存Chunk的位置信息，因此在信息刷新前，它们可能会从那些陈旧的副本中读取数据。此时间窗口会被缓存条目的超时时间以及下次打开文件的限制，这种文件的打开会使缓存清除掉所有该文件的Chunk信息。此外，因为我们的文件通常只是会被追加数据的，所以一个陈旧的副本通常返回的是一个提前结束的Chunk，而不是一个过时的数据。当一个读取者重试并且联系Master时，它会立即得到该Chunk当前的位置信息。</p><p>Long after a successful mutation, component failures can of course still corrupt or destroy data. GFS identifies failed chunk servers by regular handshakes between master and all chunk servers and detects data corruption by checksumming (Section 5.2). Once a problem surfaces, the data is restored from valid replicas as soon as possible (Section 4.3). A chunk is lost irreversibly only if all its replicas are lost before GFS can react, typically within minutes. Even in this case, it becomes unavailable, not corrupted: applications receive clear errors rather than corrupt data.</p><p>在数据变更很久之后，组件的故障仍然可能会损害或破坏数据。GFS通过定期的Master和所有Chunk Server之间的「握手」，来识别发生故障的Chunk Server，并且通过「检验和」来检测数据的损坏。一旦发生问题，数据将会尽快从可用副本中恢复。只有在Master反应之前丢失掉所有的Chunk副本（通常是几分钟以内），Chunk才会出现不可逆的丢失。即使是在这种情况，也只会发生Chunk的不可用而不是数据的损坏：应用程序会收到错误信息，而不是损坏的数据。</p><h3 id="2-7-2-Implications-for-Applications"><a href="#2-7-2-Implications-for-Applications" class="headerlink" title="2.7.2 Implications for Applications"></a>2.7.2 Implications for Applications</h3><p>GFS applications can accommodate the relaxed consistency model with a few simple techniques already needed for other purposes: relying on appends rather than overwrites, checkpointing, and writing self-validating, self-identifying records.</p><p>GFS应用程序可以通过已经被其他目的所需要的简单技术来实现这种宽松的一致性模型，例如：依赖于追加而不是覆盖写操作，检查点，写入时自我验证，自我标识记录。</p><h1 id="3-System-Interactions"><a href="#3-System-Interactions" class="headerlink" title="3 System Interactions"></a>3 System Interactions</h1><p>We designed the system to minimize the master’s involvement in all operations. With that background, we now describe how the client, master, and chunk servers interact to implement data mutations, atomic record append, and snapshot.</p><p>我们以减少Master参与所有操作的目的来设计这个系统。在这个背景之下，我们现在来描述客户端、Master以及Chunk Server之间是如何交互的以实现：数据变更、原子性的记录追加和快照。</p><h2 id="3-1-Leases-and-Mutation-Order"><a href="#3-1-Leases-and-Mutation-Order" class="headerlink" title="3.1 Leases and Mutation Order"></a>3.1 Leases and Mutation Order</h2><p>A mutation is an operation that changes the contents or metadata of a chunk such as a write or an append operation. Each mutation is performed at all the chunk’s replicas. We use leases to maintain a consistent mutation order across replicas. The master grants a chunk lease to one of the replicas, which we call the primary. The primary picks a serial order for all mutations to the chunk. All replicas follow this order when applying mutations. Thus, the global mutation order is defined first by the lease grant order chosen by the master, and within a lease by the serial numbers assigned by the primary.</p><p>变更是一种改变Chunk内容或元数据的操作，例如写和追加操作。每一个变更都会应用到相应Chunk的所有副本之中。我们使用租约来保证所有副本之间变更顺序的一致性。Master向其中一个包含指定副本的Chunk Server授予Chunk租约，这时我们将其称为主副本。主副本会为Chunk的所有变更操作制定一个串型化的顺序。所有的副本都会按照这个顺序来应用变更操作。因此，全局的变更操作的顺序首先由Master选择的租约授予顺序所决定，而同一个租约内的变更顺序则是由选择的主副本定义的。</p><p>The lease mechanism is designed to minimize management overhead at the master. A lease has an initial timeout of 60 seconds. However, as long as the chunk is being mutated, the primary can request and typically receive extensions from the master indefinitely. These extension requests and grants are piggybacked on the HeartBeat messages regularly exchanged between the master and all chunk servers. The master may sometimes try to revoke a lease before it expires (e.g., when the master wants to disable mutations on a file that is being renamed). Even if the master loses communication with a primary, it can safely grant a new lease to another replica after the old lease expires.</p><p>租约机制旨在最大程度的减少Master的管理开销。租约的初始超时时间为60秒。然而，只要Chunk正在被变更，选择的主副本就可以一直向Master请求延长租约。这些延长租约的请求和响应授权通过Master和Chunk Server之间周期交换的心跳报文来传送。Master有时也会在租约到期之前撤销租约（例如，Master想要禁用一个正在重命名的文件上的变更时）。即使Master与主副本断联了，Master也可以在旧的租约到期之后安全的将租约授予给另一个副本。</p><p>In Figure 2, we illustrate this process by following the control flow of a write through these numbered steps.</p><ol><li>The client asks the master which chunk server holds the current lease for the chunk and the locations of the other replicas. If no one has a lease, the master grants one to a replica it chooses (not shown).</li><li>The master replies with the identity of the primary and the locations of the other (secondary) replicas. The client caches this data for future mutations. It needs to contact the master again only when the primary becomes unreachable or replies that it no longer holds a lease.</li><li>The client pushes the data to all the replicas. A client can do so in any order. Each chunk server will store the data in an internal LRU buffer cache until the data is used or aged out. By decoupling the data flow from the control flow, we can improve performance by scheduling the expensive data flow based on the network topology regardless of which chunk server is the primary. Section 3.2 discusses this further.</li><li>Once all the replicas have acknowledged receiving the data, the client sends a write request to the primary. The request identifies the data pushed earlier to all of the replicas. The primary assigns consecutive serial numbers to all the mutations it receives, possibly from multiple clients, which provides the necessary serialization. It applies the mutation to its own local state in serial number order.</li><li>The primary forwards the write request to all secondary replicas. Each secondary replica applies mutations in the same serial number order assigned by the primary.</li><li>The secondaries all reply to the primary indicating that they have completed the operation.</li><li>The primary replies to the client. Any errors encountered at any of the replicas are reported to the client. In case of errors, the write may have succeeded at the primary and an arbitrary subset of the secondary replicas. (If it had failed at the primary, it would not<br>have been assigned a serial number and forwarded.)The client request is considered to have failed, and the modified region is left in an inconsistent state. Our client code handles such errors by retrying the failed mutation. It will make a few attempts at steps (3)through (7) before falling back to a retry from the beginning of the write.</li></ol><p>在图2中我们将通过步骤的编号来表示一个写操作的控制流程：</p><ol><li>客户端会向Master询问哪个Chunk Server获取到了指定Chunk的当前租约，以及其他副本的位置信息。如果没有Chunk Server获取到租约，则Master会将租约授予到其选择的一个副本。</li><li>Master回复主副本的标识，以及其他副本的位置。客户端会缓存此数据，以在将来数据变更时使用。只有当主副本不可达或者回复不再持有租约时，客户端才会需要再次联系Master。</li><li>客户端会将数据推送到所有的副本。客户端可以按照任何顺序执行此操作。每个Chunk Server会将该数据存储到其LRU缓冲区缓存中，直到数据被使用或者超时。通过将数据流和控制流解耦，我们可以通过基于网络拓扑来调动昂贵的数据流，而不管哪个Chunk Server是主副本。3.2节将会进一步讨论这些。</li><li>一旦所有的副本都确认接收到数据，客户端就会向主副本发送写请求。该写请求会标识之前推送到所有副本的数据。主副本会将其接收到的所有变更安排一个连续的序列号来提供必要的串型化，这些变更操作可能来自多个客户端。它会将所有变更按照序列号应用到本地的副本上。</li><li>主副本会将写请求向前传递给所有的次副本。次副本将会按照主副本指定的同样的序列号顺序将所有变更应用到本地。</li><li>次副本会响应主副本以暗示它们已经完成这些操作。</li><li>主副本响应客户端。所有副本所遇到的错误信息都会向客户端报告。在出现错误时，写操作可能已经成功应用到主副本和一些次副本。（如果在主副本上已经出现错误，它将不会再把序列号信息发送给其他次副本）客户端请求将被认为是失败的，修改过的区域将会处于不一致的状态。我们的客户端代码将会通过重试这些变更来处理遇到的错误。他将会先在步骤3到7之间尝试几次后重试这个写操作。</li></ol><h2 id="3-2-Data-Flow"><a href="#3-2-Data-Flow" class="headerlink" title="3.2 Data Flow"></a>3.2 Data Flow</h2><p>We decouple the flow of data from the flow of control to use the network efficiently. While control flows from the client to the primary and then to all secondaries, data is pushed linearly along a carefully picked chain of chunk servers in a pipelined fashion. Our goals are to fully utilize each machine’s network bandwidth, avoid network bottlenecks and high-latency links, and minimize the latency to push through all the data.</p><p>我们将控制流与数据流分离，以高效的利用网络。当控制流从客户端流向主副本，然后会流向所有的次副本，数据流将会以流水线方式按照精心挑选的Chunk Server链线性推送。我们的目标是充分利用每个机器的网络带宽，避免网络瓶颈和高延迟链路，并最大程度的减少推送数据的延迟。</p><p>To fully utilize each machine’s network bandwidth, the data is pushed linearly along a chain of chunk servers rather than distributed in some other topology (e.g., tree). Thus, each machine’s full outbound bandwidth is used to transfer the data as fast as possible rather than divided among multiple recipients.</p><p>为了充分利用每个机器的带宽，数据晚照Chunk Server链线性推送，而不是其他分散的拓扑（例如：树）。因此，每个机器的带宽可以尽可能的全部用来传输数据而不是为多个接受者进行划分。</p><p>To avoid network bottlenecks and high-latency links (e.g., inter-switch links are often both) as much as possible, each machine forwards the data to the “closest” machine in the network topology that has not received it.</p><p>为了尽可能避免网络瓶颈以及高延迟链路，每个机器会将数据推送到在网络拓扑中没收到数据且离它最近的机器。</p><p>Finally, we minimize latency by pipelining the data transfer over TCP connections. Once a chunk server receives some data, it starts forwarding immediately. Pipelining is especially helpful to us because we use a switched network with full-duplex links. Sending the data immediately does not reduce the receive rate.</p><p>最后，我们通过流水线化TCP连接上的数据传输来最小化延迟。Chunk Server一旦接收到数据将会立即传送。流水线对我们特别有帮助，因为我们使用了全双工链路的交换网络。立即发送数据并不会降低接收速率。</p><h2 id="3-3-Atomic-Record-Appends"><a href="#3-3-Atomic-Record-Appends" class="headerlink" title="3.3 Atomic Record Appends"></a>3.3 Atomic Record Appends</h2><p>GFS provides an atomic append operation called record append. In a traditional write, the client specifies the offset at which data is to be written. Concurrent writes to the same region are not serializable: the region may end up containing data fragments from multiple clients. In a record append, however, the client specifies only the data. GFS appends it to the file at least once atomically (i.e., as one continuous sequence of bytes) at an offset of GFS’s choosing and returns that offset to the client.</p><p>GFS提供了一种被称为记录追加的原子追加操作。在传统的写入操作中，客户端要指定数据写入的偏移位置。对于同一区域的并发写操作是不能串型化的：区域的末尾可能包含来自多个客户端的数据碎片。然而在记录追加中，客户端只需要指定数据。GFS会将其至少原子性的追加到文件中一次，追加的位置是由GFS选定的。</p><p>Record append is heavily used by our distributed applications in which many clients on different machines append to the same file concurrently. Clients would need additional complicated and expensive synchronization, for example through a distributed lock manager, if they do so with traditional writes. In our workloads, such files often serve as multiple-producer/single-consumer queues or contain merged results from many different clients.</p><p>我们的分布式应用程序中会大量的使用追加操作，不同机器上的大量客户端会并发的追加到同一个文件。如果使用传统的写操作，客户端需要复杂而又昂贵的同步操作，例如通过一个分布式锁管理。在我们的工作负载中，此类文件通常作为多生产者/单消费者队列或包含来自不同客户端的合并结果。</p><p>Record append is a kind of mutation and follows the control flow in Section 3.1 with only a little extra logic at the primary. The client pushes the data to all replicas of the last chunk of the file Then, it sends its request to the primary. The primary checks to see if appending the record to the current chunk would cause the chunk to exceed the maximum size (64 MB). If so, it pads the chunk to the maximum size, tells secondaries to do the same, and replies to the client indicating that the operation should be retried on the next chunk. (Record append is restricted to be at most one-fourth of the maximum chunk size to keep worst-case fragmentation at an acceptable level.) If the record fits within the maximum size, which is the common case, the primary appends the data to its replica, tells the secondaries to write the data at the exact offset where it has, and finally replies success to the client.</p><p>记录追加是一种变更操作，遵循3.1节中提到的控制流，除了在主副本中只需要一点额外的逻辑。客户端将所有数据（直到文件的最后一个Chunk）推送到所有的副本后，它向主副本发送请求。客户端会检查将记录追加到当前Chunk后是否会超过Chunk的最大值（64MB）。如果超过的话，它会填充当前Chunk到最大值，并且告诉其他次副本做同样的操作，然后告诉客户端在下一个Chunk上重复此操作（译者注：也即将此操作转移到另一个满足大小的Chunk上进行操作）（记录追加被严格限制在Chunk最大值的四分之一，以保证产生的最严重的碎片化在可接受的范围内）。如果记录没有超过最大值，则按普通情况处理，主副本将记录追加到它的副本，并且告诉次副本将此数据写到其拥有的确切偏移处（译者注：即写到与主副本相同的位置），最后向客户端回复成功消息。</p><p>If a record append fails at any replica, the client retries the operation. As a result, replicas of the same chunk may contain different data possibly including duplicates of the same record in whole or in part. GFS does not guarantee that all replicas are byte wise identical. It only guarantees that the data is written at least once as an atomic unit.</p><p>如何任何副本追加失败，客户端将会重试此操作。因此，对于同一个Chunk，副本可能会有不同的数据，这些数据可能包含了相同记录的整个或者部分的重复值。GFS并不会保证所有的副本在位级别上保证一致性。它只保证数据在所有副本上至少原子性的写入一次。</p><h2 id="3-4-Snapshot"><a href="#3-4-Snapshot" class="headerlink" title="3.4 Snapshot"></a>3.4 Snapshot</h2><p>The snapshot operation makes a copy of a file or a directory tree (the “source”) almost instantaneously, while minimizing any interruptions of ongoing mutations. Our users use it to quickly create branch copies of huge data sets (and often copies of those copies, recursively), or to checkpoint the current state before experimenting with changes that can later be committed or rolled back easily.</p><p>快照可以快速的创建一个文件或目录树的拷贝，而且能够最小化对于正在执行的变更的中断。我们的用户用它来创建一个大型数据集的分支，或者创建当前状态的检查点以验证稍后将要提交的更改或者快速回滚。</p><p>Like AFS , we use standard copy-on-write techniques to implement snapshots. When the master receives a snapshot request, it first revokes any outstanding leases on the chunks in the files it is about to snapshot. This ensures that any subsequent writes to these chunks will require an interaction with the master to find the lease holder. This will give the master an opportunity to create a new copy of the chunk first.</p><p>像AFS一样，我们使用标准的写时复制技术来实现快照。当Master接收到快照请求，它首先撤销关于快照的文件的有关Chunk的租约。这就确保对于这些Chunk的后续写操作都要先与Master交互以获得租约持有者。这首先给了Master机会去创建对于Chunk的一个新的拷贝。</p><p>After the leases have been revoked or have expired, the master logs the operation to disk. It then applies this log record to its in-memory state by duplicating the metadata for the source file or directory tree. The newly created snapshot files point to the same chunks as the source files.</p><p>当租约被撤销或者到期后，Master将操作记录到磁盘。然后通过复制源文件或目录树的元数据，将日志记录应用到其内存状态。新创建的快照文件和源文件指向相同的块。</p><p>The first time a client wants to write to a chunk C after the snapshot operation, it sends a request to the master to find the current lease holder. The master notices that the reference count for chunk C is greater than one. It defers replying to the client request and instead picks a new chunk handle C’. It then asks each chunk server that has a current replica of C to create a new chunk called C’. By creating the new chunk on the same chunk servers as the original, we ensure that the data can be copied locally, not over the network(our disks are about three times as fast as our 100 Mb Ethernet links). From this point, request handling is no different from that for any chunk: the master grants one of the replicas a lease on the new chunk C’ and replies to the client, which can write the chunk normally, not knowing that it has just been created from an existing chunk.</p><p>客户端在快照操作后第一次想要写入Chunk C时，它向Master发送请求以查询当前合约的持有者。Master注意到Chunk C的引用计数大于1。它延迟向客户端回复请求，而且选择一个新的Chunk Handle C‘。然后它要求所有拥有Chunk C副本的Chunk Server创建一个新的叫做C‘的Chunk。通过在与原始Chunk Server相同的Chunk Server上创建新的Chunk，我们可以确保数据是在本地复制的，而不是通过网络（我们的磁盘速度大概是100MB以太网链路的三倍）。通过这一点，对于任何Chunk的请求处理都没什么不同：master将新创建的Chunk C‘的租约授予给一个副本Chunk Server，然后回复客户端可以正常写入这个Chunk了，客户端不会知道这是刚刚从现有的Chunk中创建出来的副本。</p><h1 id="4-Master-Operation"><a href="#4-Master-Operation" class="headerlink" title="4 Master Operation"></a>4 Master Operation</h1><p>The master executes all namespace operations. In addition, it manages chunk replicas throughout the system: it makes placement decisions, creates new chunks and hence replicas, and coordinates various system-wide activities to keep chunks fully replicated, to balance load across all the chunk servers, and to reclaim unused storage. We now discuss each of these topics.</p><p>Master执行所有的命名空间操作。此外，它还管理整个系统的Chunk副本：它做出放置决策，创建新的Chunk和副本，协调整个系统范围内的活动以保证Chunk被备份，平衡所有Chunk Server之间的负载，以及回收未使用的存储。我们现在将逐个讨论这些话题。</p><h2 id="4-1-Namespace-Management-and-Locking"><a href="#4-1-Namespace-Management-and-Locking" class="headerlink" title="4.1 Namespace Management and Locking"></a>4.1 Namespace Management and Locking</h2><p>Many master operations can take a long time: for example, a snapshot operation has to revoke chunk server leases on all chunks covered by the snapshot. We do not want to delay other master operations while they are running. Therefore, we allow multiple operations to be active and use locks over regions of the namespace to ensure proper serialization.</p><p>许多的Master操作需要花费很长的时间：比如，一个快照操作不得不使快照所覆盖的所有的块都撤销其租约。我们并不想延迟其他正在运行的Master操作。因此，我们允许多个操作处于活跃状态，并且在命名空间的区域上使用锁来保证正确的序列化。</p><p>Unlike many traditional file systems, GFS does not have a per-directory data structure that lists all the files in that directory. Nor does it support aliases for the same file or directory (i.e, hard or symbolic links in Unix terms). GFS logically represents its namespace as a lookup table mapping full pathnames to metadata. With prefix compression, this table can be efficiently represented in memory. Each node in the namespace tree (either an absolute file name or an absolute directory name) has an associated read-write lock.</p><p>与许多的传统文件系统不同，GFS并没有一个能列举出目录中所有文件的目录数据结构。此外，它也不支持对于同一个文件和目录的别名（例如Unix系统中的硬链接和符号链接）。GFS在逻辑上将其命名空间表示为将完整的目录名映射到元数据的查找表。通过前缀压缩能有效的在内存中展示该表。命名空间树中的每个节点（包括绝对文件名和绝对目录名）都有一个关联的读写锁。</p><p>Each master operation acquires a set of locks before it runs. Typically, if it involves <code>/d1/d2/.../dn/leaf,</code> it will acquire read-locks on the directory names <code>/d1, /d1/d2, ..., /d1/d2/.../dn</code>, and either a read lock or a write lock on the full pathname <code>/d1/d2/.../dn/leaf</code>.Note that leaf may be a file or directory depending on the operation.</p><p>每个Master的操作在它运行之前都需要获得一个锁的集合。典型的，如果它需要操作<code>/d1/d2/.../dn/leaf</code> ，那么它需要获得在目录<code>/d1,/d1/d2,.../d1/d2/.../dn</code> 上的读锁，以及一个在全路径<code>/d1/d2/..../dn/leaf</code>上的读锁或写锁。需要注意的是，leaf可能是个文件或目录，这取决于具体的操作。</p><p>We now illustrate how this locking mechanism can prevent a file <code>/home/user/foo</code> from being created while <code>/home/user</code> is being snapshotted to <code>/save/user</code>. The snapshot operation acquires read locks on <code>/home</code> and <code>/save</code>, and write locks on <code>/home/user</code> and <code>/save/user</code>. The file creation acquires read locks on <code>/home</code> and <code>/home/user</code>, and a write lock on <code>/home/user/foo</code>. The two operations will be serialized properly because they try to obtain conflicting locks on <code>/home/user</code>. File creation does not require a write lock on the parent directory because there is no “directory”, or <em><code>inode-like</code></em>, data structure to be protected from modification. The read lock on the name is sufficient to protect the parent directory from deletion.</p><p>我们现在来列举锁机制是如何避免<code>/home/user/foo</code>被创建的，当在创建<code>/home/user</code>的快照<code>/save/user</code>时。快照操作需要获得<code>/home</code>和<code>/save</code>的读锁，以及<code>/home/user</code>和<code>/save/user</code>的写锁。文件创建需要获得<code>/home</code>和<code>/home/user</code>的读锁，以及<code>/home/user/foo</code>的写锁。这两个操作将被正确的序列化，因为它们试图获得在<code>/home/user</code>上的冲突锁。文件创建不需要获得副目录的写锁，因为这里并没有目录或者类似<code>inode</code>的数据结构需要被保护以防止修改。读锁已经足够用来保护副目录被删除。</p><p>One nice property of this locking scheme is that it allows concurrent mutations in the same directory. For example, multiple file creations can be executed concurrently in the same directory: each acquires a read lock on the directory name and a write lock on the file name. The read lock on the directory name suffices to prevent the directory from being deleted, renamed, or snapshotted. The write locks on file names serialize attempts to create a file with the same name twice.</p><p>这种锁机制的一个好处是允许同一个目录内的并发变更操作。例如，可以在同一个目录内同时执行多个文件的创建操作：每个创建操作需要一个对于目录名的读锁，以及对于文件名的写锁。目录名的写锁用于放置目录被删除、重命名或被执行快照操作。在文件名上的写锁用于序列化对于同一个文件名的创建操作。</p><p>Since the namespace can have many nodes, read-write lock objects are allocated lazily and deleted once they are not in use. Also, locks are acquired in a consistent total order to prevent deadlock: they are first ordered by level in the namespace tree and lexicographically within the same level.</p><p>由于命名空间可以有多个节点，所以读写锁对象会被惰性分配，一旦不使用就被删除。 此外，以一致的总顺序获取锁以防止死锁：它们首先在命名空间树中按级别排序，并在同一级别内按字典顺序排列。</p><h2 id="4-2-Replica-Placement"><a href="#4-2-Replica-Placement" class="headerlink" title="4.2 Replica Placement"></a>4.2 Replica Placement</h2><p>A GFS cluster is highly distributed at more levels than one. It typically has hundreds of chunk servers spread across many machine racks. These chunk servers in turn may be accessed from hundreds of clients from the same or different racks. Communication between two machines on different racks may cross one or more network switches. Additionally, bandwidth into or out of a rack may be less than the aggregate bandwidth of all the machines within the rack. Multi-level distribution presents a unique challenge to distribute data for scalability, reliability, and availability.</p><p>GFS在各个层级上都实现了高度的分布式。它通常由几百个分布在多个机架上的Chunk Server组成。这些Chunk Server又可能被几百个来自相同或不同机架上的客户端访问。来自不同机架上的两个机器之间的通信可能或跨一个或多个交换机。此外，进出一个机架的带宽可能会小于一个机架上所有机器的总带宽。多层级的分布式也面临着独一无二的挑战：分布式数据的扩展性、可靠性和可用性。</p><p>The chunk replica placement policy serves two purposes: maximize data reliability and availability, and maximize network bandwidth utilization. For both, it is not enough to spread replicas across machines, which only guards against disk or machine failures and fully utilizes each machine’s network bandwidth. We must also spread chunk replicas across racks. This ensures that some replicas of a chunk will survive and remain available even if an entire rack is damaged or offline (for example, due to failure of a shared resource like a network switch or power circuit). It also means that traffic, especially reads, for a chunk can exploit the aggregate bandwidth of multiple racks. On the other hand, write traffic has to flow through multiple racks, a trade off we make willingly.</p><p>Chunk副本的放置策略主要服务于两个目的：最大化数据的可靠性和可用性，最大化利用网络带宽。对于两者来说，仅仅实现跨机器的副本是不够的，这只能保证抵抗磁盘或机器的错误，以及最大化利用每个机器的网络带宽。我们必须实现Chunk副本的跨机架。这能保证一个Chunk的副本是可用的，即使一整个机架都被破坏或者下线（例如，网络交换机和电源电路等共享资源的故障）。这也意味着，对于一个Chunk的流量特别是读操作，可以充分利用多个机架的总带宽。另一方面，写流量需要在多个机架之间进行，这也是我们自愿做出的权衡。</p><h2 id="4-3-Creation-Replication-Rebalancing"><a href="#4-3-Creation-Replication-Rebalancing" class="headerlink" title="4.3 Creation, Replication, Rebalancing"></a>4.3 Creation, Replication, Rebalancing</h2><p>Chunk replicas are created for three reasons: chunk creation, re-replication, and rebalancing.</p><p>Chunk副本的创建有三种原因：Chunk的创建，重备份，重平衡。</p><p>When the master creates a chunk, it chooses where to place the initially empty replicas. It considers several factors. (1) We want to place new replicas on chunk servers with below-average disk space utilization. Over time this will equalize disk utilization across chunk servers. (2) We want to limit the number of “recent” creations on each chunk server. Although creation itself is cheap, it reliably predicts imminent heavy write traffic because chunks are created when demanded by writes, and in our append-once-read-many workload they typically become practically read-only once they have been completely written. (3) As discussed above, we want to spread replicas of a chunk across racks.</p><p>当Master创建一个Chunk的时候，它会选择在何处放置初始化为空的副本。它会考虑以下几个因素：</p><ol><li>我们会希望将新的副本放置在低于平均磁盘利用率的Chunk Serve上。随着时间的推移，这将会平衡各个Chunk Server的磁盘利用率。</li><li>我们希望能限制在每个Chunk Server 上的「最近」创建Chunk的数量。尽管创建本身是比较廉价的，但是这能可靠的预测即将到来的大量的写流量，因为Chunk是为了写操作而创建的，并且在我们的一次写入多次读的负载模型中，一旦写入完成它们通常都是只读的。</li><li>正如我们在上面讨论的那样，我们希望实现Chunk副本的跨机架放置。</li></ol><p>The master re-replicates a chunk as soon as the number of available replicas falls below a user-specified goal. This could happen for various reasons: a chunk server becomes unavailable, it reports that  it‘s replica may be corrupted, one of its disks is disabled because of errors, or the replication goal is increased. Each chunk that needs to be re-replicated is prioritized based on several factors. One is how far it is from its replication goal. For example, we give higher priority to a chunk that has lost two replicas than to a chunk that has lost only one. In addition, we prefer to first re-replicate chunks for live files as opposed to chunks that belong to recently deleted files (see Section 4.4). Finally, to minimize the impact of failures on running applications, we boost the priority of any chunk that is blocking client progress.</p><p>Master会在当Chunk副本的数量少于用户预定义的数量时进行重备份。这可能发生在以下情况：一个Chunk Server变得不可达，它报告自己的副本可能被污染了，它的一个磁盘由于错误变得不可用了，或者预设的副本数量增加了。需要重新备份的Chunk的优先级主要有以下几个因素来确定。一个是它与备份的目标数量差了多少。例如，我们将更高的优先级给丢失了两个副本的Chunk而不是只丢失了一个副本的Chunk。</p><p>The master picks the highest priority chunk and “clones” it by instructing some chunk server to copy the chunk data directly from an existing valid replica. The new replica is placed with goals similar to those for creation: equalizing disk space utilization, limiting active clone operations on any single chunk server, and spreading replicas across racks. To keep cloning traffic from overwhelming client traffic, the master limits the numbers of active clone operations both for the cluster and for each chunk server. Additionally, each chunk server limits the amount of bandwidth it spends on each clone operation by throttling its read requests to the source chunk server.</p><p>Master挑选具有最高优先级的Chunk，并且通过命令其他Chunk Server直接通过其他可用的副本来复制Chunk数据来进行Chunk的克隆操作。这个新的副本的放置目标类似创建操作：平衡磁盘空间利用率，限制对于单个Chunk Server上的活跃克隆操作数量，实现副本的跨机架放置。为了防止克隆流量超过客户端流量，Master 限制了集群和每个Chunk服务器的活跃克隆操作的数量。 此外，每个Chunk服务器通过限制对源Chunk服务器的读取请求来限制它在每个克隆操作上花费的带宽量。</p><p>Finally, the master rebalances replicas periodically: it examines the current replica distribution and moves replicas for better disk space and load balancing. Also through this process, the master gradually fills up a new chunk server rather than instantly swamps it with new chunks and the heavy write traffic that comes with them. The placement criteria for the new replica are similar to those discussed above. In addition, the master must also choose which existing replica to remove. In general, it prefers to remove those on chunk servers with below-average free space so as to equalize disk space usage.</p><p>最后，Master会周期性的重平衡副本：它会检验当前副本的分布，移动副本以实现更好的磁盘空间和负载的平衡。通过这个过程，Master会逐渐填满一个新的Chunk Server，而不是将大量的新Chunk和随之而来的写流量来淹没它。新副本的放置标准和我们之前讨论的类似。此外，Master还必须要选择删除哪个现有的副本。通常，它更偏向于删除那些位于低于平均空闲空间Chunk Server上的副本，以平衡磁盘上的可用空间。</p><h2 id="4-4-Garbage-Collection"><a href="#4-4-Garbage-Collection" class="headerlink" title="4.4 Garbage Collection"></a>4.4 Garbage Collection</h2><p>After a file is deleted, GFS does not immediately reclaim the available physical storage. It does so only lazily during regular garbage collection at both the file and chunk levels. We find that this approach makes the system much simpler and more reliable.</p><p>文件被删除后，GFS并不会立即回收可用的物理存储。它只会在文件和Chunk级别上的常规垃圾回收期间惰性的执行这样的操作。我们发现这样可以使系统更简单和可靠。</p><h3 id="4-4-1-Mechanism"><a href="#4-4-1-Mechanism" class="headerlink" title="4.4.1 Mechanism"></a>4.4.1 Mechanism</h3><p>When a file is deleted by the application, the master logs the deletion immediately just like other changes. However instead of reclaiming resources immediately, the file is just renamed to a hidden name that includes the deletion times-tamp. During the master’s regular scan of the file system namespace, it removes any such hidden files if they have existed for more than three days (the interval is configurable). Until then, the file can still be read under the new, special name and can be undeleted by renaming it back to normal. When the hidden file is removed from the namespace, its in-memory metadata is erased. This effectively severs its links to all its chunks.</p><p>当一个文件被应用程序删除后，Master会像记录其他更改一样立刻记录删除操作。然而，文件只是被重命名为一个包含了删除时间戳的隐藏名称，而不是立刻回收资源。在Master定期扫描系统命名空间时，它会删除那些存在超过三天的隐藏文件（时间间隔是可配置的）。在此之前，仍可以使用新的特殊名称读取该文件，并且可以通过将其重命名为正常名称来取消删除该文件。 当隐藏文件从命名空间中移除时，其内存中的元数据将被擦除。 这有效地切断了它与所有块的链接。</p><p>In a similar regular scan of the chunk namespace, the master identifies orphaned chunks (i.e., those not reachable from any file) and erases the metadata for those chunks. In a HeartBeat message regularly exchanged with the master, each chunk server reports a subset of the chunks it has, and the master replies with the identity of all chunks that are no longer present in the master’s metadata. The chunk server is free to delete its replicas of such chunks. </p><p>在类似的Chunk命名空间的定期扫描中，Master会识别孤儿Chunk（例如那些不被任何文件可达的Chunk）并且擦除这些Chunk的元数据。在定期与Master交换的心跳报文中，每个Chunk Server都会报告它所拥有的Chunk的子集，Master会回复它已经没有其元数据的所有Chunk的标识。Chunk Server可以自由的删除这些块的副本。</p><h3 id="4-4-2-Discussion"><a href="#4-4-2-Discussion" class="headerlink" title="4.4.2 Discussion"></a>4.4.2 Discussion</h3><p>Although distributed garbage collection is a hard problem that demands complicated solutions in the context of programming languages, it is quite simple in our case. We can easily identify all references to chunks: they are in the file-to-chunk mappings maintained exclusively by the master. We can also easily identify all the chunk replicas: they are Linux files under designated directories on each chunk server. Any such replica not known to the master is “garbage.”</p><p>尽管分布式垃圾回收在编程语言的上下文中是一个需要复杂解决方案的难题，但在我们的案例中却非常简单。 我们可以很容易地识别出所有对Chunk的引用：它们位于由Master专门维护的文件到块的映射中。 我们还可以轻松识别所有Chunk副本：它们是每个Chunk Server上指定目录下的 Linux 文件。 Master不知道的任何此类副本都是“垃圾”。</p><p>The garbage collection approach to storage reclamation offers several advantages over eager deletion. First, it is simple and reliable in a large-scale distributed system where component failures are common. Chunk creation may succeed on some chunk servers but not others, leaving replicas that the master does not know exist. Replica deletion messages may be lost, and the master has to remember to resend them across failures, both its own and the chunk server’s. Garbage collection provides a uniform and dependable way to clean up any replicas not known to be useful. Second, it merges storage reclamation into the regular background activities of the master, such as the regular scans of namespaces and handshakes with chunk servers. Thus, it is done in batches and the cost is amortized. Moreover, it is done only when the master is relatively free. The master can respond more promptly to client requests that demand timely attention. Third, the delay in reclaiming storage provides a safety net against accidental, irreversible deletion.</p><p>与立刻删除相比，存储回收的垃圾回收方法提供了几个优点。首先，它在组件故障常见的大型分布式系统中简单可靠。Chunk创建可能在某些Chunk Server上成功但在其他Chunk Server上不会成功，从而留下Master不知道存在的副本。副本删除消息可能会丢失，并且 Master 必须记住在失败时重新发送它们，包括它自己的和Chunk Server的。垃圾收集提供了一种统一且可靠的方法来清理任何已知无用的副本。其次，它将存储回收合并到 Master 的常规后台活动中，例如命名空间的常规扫描和与Chunk Server的握手。因此，它是分批完成的，成本被摊销。而且，只有在Master比较空闲的时候才做。 Master 可以更迅速地响应需要及时关注的客户端请求。第三，回收存储的延迟提供了防止意外、不可逆删除的安全网。</p><h2 id="4-5-Stale-Replica-Detection"><a href="#4-5-Stale-Replica-Detection" class="headerlink" title="4.5 Stale Replica Detection"></a>4.5 Stale Replica Detection</h2><p>Chunk replicas may become stale if a chunk server fails and misses mutations to the chunk while it is down. For each chunk, the master maintains a chunk version number to distinguish between up-to-date and stale replicas.</p><p>如果Chunk Server发生故障并且在它关闭时错过了对Chunk的变更，则Chunk副本可能会变得过时。 对于每个Chunk，Master都会维护一个Chunk版本号以区分最新和陈旧的副本。</p><p>Whenever the master grants a new lease on a chunk, it increases the chunk version number and informs the up-to-date replicas. The master and these replicas all record the new version number in their persistent state. This occurs before any client is notified and therefore before it can start writing to the chunk. If another replica is currently unavailable, its chunk version number will not be advanced. The master will detect that this chunk server has a stale replica when the chunk server restarts and reports its set of chunks and their associated version numbers. If the master sees a version number greater than the one in its records, the master assumes that it failed when granting the lease and so takes the higher version to be up-to-date.</p><p>每当Master授予一个Chunk新的租约时，它就会增加Chunk版本号并通知最新的副本。 Master 和这些副本都在它们的持久状态中记录了新的版本号。 这发生在任何客户端被通知之前，因此在它可以开始写入Chunk之前。 如果另一个副本当前不可用，则其Chunk版本号不会继续增加。 当Chunk Server重新启动并报告其Chunk集合及其相关联的版本号时，Master将检测到该Chunk Server具有过时的副本。 如果 Master 看到版本号大于其记录中的版本号，则 Master 假定它在授予租约时失败，因此将更高的版本更新为最新版本。</p><h1 id="5-Fault-Tolerance-And-Diagnosis"><a href="#5-Fault-Tolerance-And-Diagnosis" class="headerlink" title="5 Fault Tolerance And Diagnosis"></a>5 Fault Tolerance And Diagnosis</h1><p>One of our greatest challenges in designing the system is dealing with frequent component failures. The quality and quantity of components together make these problems more the norm than the exception: we cannot completely trust the machines, nor can we completely trust the disks. Component failures can result in an unavailable system or, worse, corrupted data. We discuss how we meet these challenges and the tools we have built into the system to diagnose problems when they inevitably occur.</p><p>我们在设计系统时遇到的最大的挑战之一是处理频繁的组件故障。组件的质量和数量共同导致这些问题成为常态而不是意外：我们既不能完全信任这些机器，也不能完全信任这些磁盘。组件故障会导致系统不可用，甚至更严重的是会导致数据的损坏。我们讨论了我们是如何应对这些挑战的，以及我们在系统中内置的工具，以便在问题不可避免地发生时进行诊断。</p><h2 id="5-1-High-Availability"><a href="#5-1-High-Availability" class="headerlink" title="5.1 High Availability"></a>5.1 High Availability</h2><p>Among hundreds of servers in a GFS cluster, some are bound to be unavailable at any given time. We keep the overall system highly available with two simple yet effective strategies: fast recovery and replication.</p><p>在GFS的数百台机器中，在任何给定的时间总有些机器是不可用的。我们通过两个简单却有效的策略来保证整个系统的高可用性：快速恢复和备份。</p><h3 id="5-1-1-Fast-Recovery"><a href="#5-1-1-Fast-Recovery" class="headerlink" title="5.1.1 Fast Recovery"></a>5.1.1 Fast Recovery</h3><p>Both the master and the chunk server are designed to restore their state and start in seconds no matter how they terminated. In fact, we do not distinguish between normal and abnormal termination; servers are routinely shut down just by killing the process. Clients and other servers experience a minor hiccup as they time out on their outstanding requests, reconnect to the restarted server, and retry. Section 6.2.2 reports observed startup times.</p><p>Master和Chunk Server都被设计为恢复它们的状态和在几秒后重启而不管他们是如何被终止的。实际上，我们并不会区分正常和异常终止。服务器会例行的通过杀死进程来关闭。客户端和其他服务器在处理未完成的请求时会遇到小问题，重新连接到重新启动的服务器并重试。 第 6.2.2 节报告观察到的启动时间。</p><h3 id="5-1-2-Chunk-Replication"><a href="#5-1-2-Chunk-Replication" class="headerlink" title="5.1.2 Chunk Replication"></a>5.1.2 Chunk Replication</h3><p>As discussed earlier, each chunk is replicated on multiple chunk servers on different racks. Users can specify different replication levels for different parts of the file namespace. The default is three. The master clones existing replicas as needed to keep each chunk fully replicated as chunk servers go offline or detect corrupted replicas through checksum verification (see Section 5.2). Although replication has served us well, we are exploring other forms of cross-server redundancy such as parity or erasure codes for our increasing read- only storage requirements. We expect that it is challenging but manageable to implement these more complicated redundancy schemes in our very loosely coupled system be- cause our traffic is dominated by appends and reads rather than small random writes.</p><p>正如前面讨论的那样，每个Chunk被复制到多个位于不同机架上的Chunk Server上。用户可以为文件命名空间的不同部分设置不同的备份级别。默认为3。</p><h3 id="5-1-3-Master-Replication"><a href="#5-1-3-Master-Replication" class="headerlink" title="5.1.3 Master Replication"></a>5.1.3 Master Replication</h3><p>The master state is replicated for reliability. Its operation log and checkpoints are replicated on multiple machines. A mutation to the state is considered committed only after its log record has been flushed to disk locally and on all master replicas. For simplicity, one master process remains in charge of all mutations as well as background activities such as garbage collection that change the system internally. When it fails, it can restart almost instantly. If its machine or disk fails, monitoring infrastructure outside GFS starts a new master process elsewhere with the replicated operation log. Clients use only the canonical name of the master (e.g. gfs-test), which is a DNS alias that can be changed if the master is relocated to another machine.</p><p>Master的状态被备份以保证可靠性。它的操作日志和检查点被复制到多台机器上。对于状态的变更只有当它的日志记录被刷新到本地磁盘和所有的Master副本上后才会被确认提交。为了简单起见，一个Master进程负责处理所有的变更和后台活动，就像更改内部系统的垃圾回收那样。当出现故障时，它几乎可以立即重启。如果它的机器或者磁盘出现故障，GFS之外的监控基础设施会在其他地方重新启动一个带有复制的操作日志的新的Master进程。客户端仅使用Master 的规范名称（例如 gfs-test），这是一个 DNS 别名，如果 master 重新定位到另一台机器，则可以更改该别名。</p><p>Moreover, “shadow” masters provide read-only access to the file system even when the primary master is down. They are shadows, not mirrors, in that they may lag the primary slightly, typically fractions of a second. They enhance read availability for files that are not being actively mutated or applications that do not mind getting slightly stale results. In fact, since file content is read from chunk servers, applications do not observe stale file content. What could be stale within short windows is file metadata, like directory contents or access control information.</p><p>此外，「影子」Master提供对文件系统的只读访问，即使主Master宕掉。它们是影子，而不是镜子，因为它们可能稍微滞后于主Master，通常是几分之一秒。 它们增强了未主动变更的文件或不介意获得稍微过时的结果的应用程序的读取可用性。 事实上，由于文件内容是从Chunk Server读取的，应用程序不会观察到陈旧的文件内容。 在短窗口中可能过时的是文件元数据，如目录内容或访问控制信息。</p><p>To keep itself informed, a shadow master reads a replica of the growing operation log and applies the same sequence of changes to its data structures exactly as the primary does. Like the primary, it polls chunk servers at startup (and infrequently thereafter) to locate chunk replicas and exchanges frequent handshake messages with them to monitor their status. It depends on the primary master only for replica location updates resulting from the primary’s decisions to create and delete replicas.</p><p>为了保证它被通知，影子Master读取不断增长的操作日志的副本，并且按照和主Master同样的更改序列应用到它的数据结构。与主Master一样，它在启动时（之后很少）轮询Chunk Server以定位Chunk副本并与它们交换频繁的握手消息以监控它们的状态。 它仅依赖于主Master来更新由主Master创建和删除副本的决定所导致的副本位置更新。</p><h2 id="5-2-Data-Integrity"><a href="#5-2-Data-Integrity" class="headerlink" title="5.2 Data Integrity"></a>5.2 Data Integrity</h2><p>Each chunk server uses checksumming to detect corruption of stored data. Given that a GFS cluster often has thousands of disks on hundreds of machines, it regularly experiences disk failures that cause data corruption or loss on both the read and write paths. (See Section 7 for one cause.) We can recover from corruption using other chunk replicas, but it would be impractical to detect corruption by comparing replicas across chunk servers. Moreover, divergent replicas may be legal: the semantics of GFS mutations, in particular atomic record append as discussed earlier, does not guarantee identical replicas. Therefore, each chunk server must independently verify the integrity of its own copy by maintaining checksums.</p><p>每个Chunk Server使用检验和来检测存储数据的损坏。因为每个GFS集群通常在几百台机器上有几千个磁盘，这会经常遇到磁盘故障，并导致在读或写路径上的数据损坏和丢失。我们可以使用其他的Chunk副本来从损坏中恢复数据，但通过跨Chunk Server的方式来比较副本以检验数据损坏是不切实际的。此外，不同的副本可能是合法的：GFS变更的语义，特别是在我们之前讨论过的原子追加记录上，并不会保证一致的副本。因此，每个Chunk Server必须通过维护独立检验和的方式来保证它自己副本数据的完整性。</p><p>A chunk is broken up into 64 KB blocks. Each has a corresponding 32 bit checksum. Like other metadata, checksums are kept in memory and stored persistently with logging, separate from user data.</p><p>每个Chunk被划分为64KB大小的块。每个块都有对应的32位的检验和。像元数据一样，检验和被保存在内存中，并通过日志的方式持久化，独立于用户数据。</p><p>For reads, the chunk server verifies the checksum of data blocks that overlap the read range before returning any data to the requester, whether a client or another chunk server. Therefore chunk servers will not propagate corruptions to other machines. If a block does not match the recorded checksum, the chunk server returns an error to the requestor and reports the mismatch to the master. In response, the requestor will read from other replicas, while the master will clone the chunk from another replica. After a valid new replica is in place, the master instructs the chunk server that reported the mismatch to delete its replica.</p><p>对于读操作，Chunk Server在将数据返回给请求者之前（无论是客户端还是其他的Chunk Server），都会验证读操作范围内的数据块的检验和。因此，Chunk Server不会将损坏的数据传播到其他机器。如果一个块不匹配记录的检验和，Chunk Server将会向请求者返回一个错误信息，并且向Master报告不匹配信息。作为响应，请求者将会从其他的副本读取数据，并且Master将会从其他的副本克隆Chunk。在有效的新副本就位后，Master会指示报告不匹配的Chunk Server删除其副本。</p><p>Checksumming has little effect on read performance for several reasons. Since most of our reads span at least a few blocks, we need to read and checksum only a relatively small amount of extra data for verification. GFS client code further reduces this overhead by trying to align reads at checksum block boundaries. Moreover, checksum lookups and comparison on the chunk server are done without any I/O, and checksum calculation can often be overlapped with I/Os.</p><p>出于多个原因，检验和对读操作的性能机会没有影响。因为我们的读操作至少跨越几个块，我们只需要读取和检验相对很少的额外数据进行验证。GFS客户端代码尝试通过在检验和的块边界对齐读取以进一步减少该开销。此外，Chunk Server上的检验和查找和比较是在没有任何IO的情况下完成的，并且检验和的计算通常会与IO重叠。</p><p>Checksum computation is heavily optimized for writes that append to the end of a chunk(as opposed to writes that overwrite existing data) because they are dominant in our workloads. We just incrementally update the checksum for the last partial checksum block, and compute new checksums for any brand new checksum blocks filled by the append. Even if the last partial checksum block is already corrupted and we fail to detect it now, the new checksum value will not match the stored data, and the corruption will be detected as usual when the block is next read.</p><p>检验和计算针对附加到块的末尾的写入（而不是覆盖现有数据的写入）因为在我们的工作负载中它们占主导地位。我们只会增量更新最后部分检验和块的检验和，并为由追加填充得到的新的检验和块计算新的检验和。即使最后的部分检验和块已经损坏了，而且我们现在没法检测到它，新的检验和值也不会匹配到存储的数据，并且会在下次读取块时检测到损坏。</p><p>In contrast, if a write overwrites an existing range of the chunk, we must read and verify the first and last blocks of the range being overwritten, then perform the write, and finally compute and record the new checksums. If we do not verify the first and last blocks before overwriting them partially, the new checksums may hide corruption that exists in the regions not being overwritten.</p><p>相反，如果写入操作覆盖写了Chunk的现有范围，我们必须读取和检测覆盖写范围内的第一个和最后一个块，然后执行写入，最后计算并记录新的检验和。如果我们不对部分覆盖写范围内的第一个和最后一个块进行验证，新的检验和可能会隐藏存在于覆盖写范围之外的损坏。</p><p>During idle periods, chunk servers can scan and verify the contents of inactive chunks. This allows us to detect corruption in chunks that are rarely read. Once the corruption is detected, the master can create a new uncorrupted replica and delete the corrupted replica. This prevents an inactive but corrupted chunk replica from fooling the master into thinking that it has enough valid replicas of a chunk.</p><p>在空闲时期，Chunk Server会扫描和验证非活动Chunk的内容。这使我们可以检测到那些很少读取的Chunk中的损坏。一旦检测到损坏，Master就可以创建一个新的未损坏的副本并删除已损坏的副本。这避免了不活跃但已损坏的Chunk副本欺骗Master，使其以为我们已经拥有了足够的可用Chunk副本。</p><h2 id="5-3-Diagnostic-Tools"><a href="#5-3-Diagnostic-Tools" class="headerlink" title="5.3 Diagnostic Tools"></a>5.3 Diagnostic Tools</h2><p>Extensive and detailed diagnostic logging has helped immeasurably in problem isolation, debugging, and performance analysis, while incurring only a minimal cost. Without logs, it is hard to understand transient, non-repeatable interactions between machines. GFS servers generate diagnostic logs that record many significant events (such as chunk servers going up and down) and all RPC requests and replies. These diagnostic logs can be freely deleted without affecting the correctness of the system. However, we try to keep these logs around as far as space permits.</p><p>广泛而详细的诊断日志在问题隔离、调试和性能分析方面起到了不可估量的作用，同时只产生了最低限度的成本。 没有日志，就很难理解机器之间短暂的、不可重复的交互。 GFS 服务器生成诊断日志，来记录许多重要事件（例如Chunk Server启动和关闭）以及所有 RPC 请求和回复。 这些诊断日志可以随意删除，不影响系统的正确性。 但是，我们会尽量在空间允许的范围内保留这些日志。</p><p>The RPC logs include the exact requests and responses sent on the wire, except for the file data being read or written. By matching requests with replies and collating RPC records on different machines, we can reconstruct the entire interaction history to diagnose a problem. The logs also serve as traces for load testing and performance analysis.</p><p>RPC 日志包括在线路上发送的确切请求和响应，但正在读取或写入的文件数据除外。 通过将请求与回复匹配并整理不同机器上的 RPC 记录，我们可以重建整个交互历史以诊断问题。 日志还用作负载测试和性能分析的跟踪。</p><p>The performance impact of logging is minimal (and far outweighed by the benefits) because these logs are written sequentially and asynchronously. The most recent events are also kept in memory and available for continuous online monitoring.</p><p>日志记录对性能的影响很小（并且远远超过好处），因为这些日志是按顺序和异步写入的。 最近的事件也保存在内存中，可用于持续在线监控。</p><h1 id="6-Measurements"><a href="#6-Measurements" class="headerlink" title="6 Measurements"></a>6 Measurements</h1><p>以下内容略。</p><h2 id="6-1-Micro-benchmarks"><a href="#6-1-Micro-benchmarks" class="headerlink" title="6.1 Micro-benchmarks"></a>6.1 Micro-benchmarks</h2><h3 id="6-1-1-Reads"><a href="#6-1-1-Reads" class="headerlink" title="6.1.1 Reads"></a>6.1.1 Reads</h3><h3 id="6-1-2-Writes"><a href="#6-1-2-Writes" class="headerlink" title="6.1.2 Writes"></a>6.1.2 Writes</h3><h3 id="6-1-3-Record-Appends"><a href="#6-1-3-Record-Appends" class="headerlink" title="6.1.3 Record Appends"></a>6.1.3 Record Appends</h3><h2 id="6-2-Real-World-Cluster"><a href="#6-2-Real-World-Cluster" class="headerlink" title="6.2 Real World Cluster"></a>6.2 Real World Cluster</h2><h3 id="6-2-1-Storage"><a href="#6-2-1-Storage" class="headerlink" title="6.2.1 Storage"></a>6.2.1 Storage</h3><h3 id="6-2-2-Metadata"><a href="#6-2-2-Metadata" class="headerlink" title="6.2.2 Metadata"></a>6.2.2 Metadata</h3><h3 id="6-2-3-Read-and-Write-Rates"><a href="#6-2-3-Read-and-Write-Rates" class="headerlink" title="6.2.3 Read and Write Rates"></a>6.2.3 Read and Write Rates</h3><h3 id="6-2-4-Master-Load"><a href="#6-2-4-Master-Load" class="headerlink" title="6.2.4 Master Load"></a>6.2.4 Master Load</h3><h3 id="6-2-5-Recovery-Time"><a href="#6-2-5-Recovery-Time" class="headerlink" title="6.2.5 Recovery Time"></a>6.2.5 Recovery Time</h3><h2 id="6-3-Workload-Breakdown"><a href="#6-3-Workload-Breakdown" class="headerlink" title="6.3 Workload Breakdown"></a>6.3 Workload Breakdown</h2><h3 id="6-3-1-Methodology-and-Caveats"><a href="#6-3-1-Methodology-and-Caveats" class="headerlink" title="6.3.1 Methodology and Caveats"></a>6.3.1 Methodology and Caveats</h3><h3 id="6-3-2-Chunk-server-Workload"><a href="#6-3-2-Chunk-server-Workload" class="headerlink" title="6.3.2 Chunk-server Workload"></a>6.3.2 Chunk-server Workload</h3><h3 id="6-3-3-Appends-versus-Writes"><a href="#6-3-3-Appends-versus-Writes" class="headerlink" title="6.3.3 Appends versus Writes"></a>6.3.3 Appends versus Writes</h3><h3 id="6-3-4-Master-Workload"><a href="#6-3-4-Master-Workload" class="headerlink" title="6.3.4 Master Workload"></a>6.3.4 Master Workload</h3><h1 id="7-Experiences"><a href="#7-Experiences" class="headerlink" title="7 Experiences"></a>7 Experiences</h1><h1 id="8-Related-Work"><a href="#8-Related-Work" class="headerlink" title="8 Related Work"></a>8 Related Work</h1><h1 id="9-Conclusions"><a href="#9-Conclusions" class="headerlink" title="9 Conclusions"></a>9 Conclusions</h1>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>分布式文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态内存分配</title>
    <link href="/2021/09/24/C%E5%92%8CC++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2021/09/24/C%E5%92%8CC++/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="C-语言的动态内存分配"><a href="#C-语言的动态内存分配" class="headerlink" title="C 语言的动态内存分配"></a>C 语言的动态内存分配</h2><p>C语言使用<code>malloc</code>和<code>free</code>两个库函数完成动态内存的分配和释放，头文件为<code>stdlib.h</code>。其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">malloc</span><span class="hljs-params">(size_t_ size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span></span>;<br></code></pre></div></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * name;<br>    name = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">strcpy</span>(name, <span class="hljs-string">&quot;Ap0l1o&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, name);<br>    <span class="hljs-built_in">free</span>(name);<br>    name = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要注意的地方(C语言内存分配的不足之处)：</p><ul><li><code>malloc</code>函数的参数是要分配的字节数目，这个需要我们自己来计算。比如，上面的实例中，我们先使用<code>sizeof</code>函数计算了<code>char</code>类型的内存大小，然后分配了20个<code>char</code>类型内存大小；</li><li><code>malloc</code>函数的返回值是无类型指针<code>void *</code>，需要我们在程序中强制将其转为指定的类型。所以在上面的实例中，我们使用<code>(char *)</code>将其转为<code>char</code>类型的指针变量；</li><li>特别需要注意的是<code>free</code>函数只是释放了<code>malloc</code>所申请的内存，但并没有改变指针的值，因此，在释放内存后应该将指针指向<code>NULL</code>，否则该指针将指向一个无法控制的内存区域，成为野指针；</li></ul><h2 id="C-动态内存分配"><a href="#C-动态内存分配" class="headerlink" title="C++动态内存分配"></a>C++动态内存分配</h2><p>为了弥补C语言动态内存分配的缺点，C++提供了新的运算符<code>new</code>和<code>delete</code>来完成动态内存的分配和释放。</p><p>使用运算符<code>new</code>和<code>delete</code>的优点为：</p><ul><li><code>new</code>的参数为待分配单元的数目，它自动计算要分配的变量类型的大小；</li><li>它自动返回正确的指针类型，不必对返回的指针进行类型转换；</li><li>可以用<code>new</code>将分配的存储空间进行初始化；</li></ul><p>使用方法为：</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-number">1.</span>  指针变量名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>指针基类型名(指针基类型表达式);<br>圆括号里的「指针基类型表达式」意思是用这个表达式的值来初始化指针指向的单元。<br>例如，p = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>(<span class="hljs-number">1.0</span>)，将指针p指向地址的值初始化为<span class="hljs-number">1.0</span><br><span class="hljs-number">2.</span>  指针变量名 = <span class="hljs-keyword">new</span> <span class="hljs-type"></span>指针基类型名[整型表达式];<br>方括号里的「整型表达式」是要分配一个数组，表达式的值是分配的数组的长度。<br>例如，p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>]，指针p指向长度为<span class="hljs-number">10</span>的数组的第一个元素。<br></code></pre></div></td></tr></table></figure><p>注意事项如下：</p><ul><li>使用<code>new</code>申请的存储空间是没有名字的，只能通过指针间接访问它们；</li><li><code>delete</code> 的操作数必须是一个<code>new</code>返回的指针；</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web运作原理简介</title>
    <link href="/2021/04/18/Web%E7%9B%B8%E5%85%B3/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/18/Web%E7%9B%B8%E5%85%B3/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-Web的概念"><a href="#0x00-Web的概念" class="headerlink" title="0x00 Web的概念"></a>0x00 Web的概念</h2><p>Web是一种分布式应用架构，旨在共享分布在网络上的各个Web服务器中的所有互相链接的信息。Web采用客户/服务器模式，客户与服务器之间用HTTP协议通信。Web使用超文本标记语言 （HTML）来链接网络上的信息。信息存放在服务器端，客户机通过浏览器就可以查找网络中的各个Web服务器上的信息。</p><p>Web的特征：</p><ul><li>信息的表达：用超级文本技术HTML来表达信息，以及建立信息与信息的链接。</li><li>信息的定位：用统一资源定位技术URL来实现网络上信息的精确定位。</li><li>信息的传输：用网络应用层协议HTTP来规范浏览器与Web服务器之间的通信过程。</li></ul><blockquote><p>注：<strong>Web服务器</strong>是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会高速浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，因此也常被称为<strong>HTTP服务器</strong>。</p></blockquote><h2 id="0x10-HTML简介"><a href="#0x10-HTML简介" class="headerlink" title="0x10 HTML简介"></a>0x10 HTML简介</h2><p>HTML（Hyper Text Markup Language）即超文本标记语言。用HTML语言编写的文档，即HTML文档，它不仅可以直接包含文本内容，还可以把其他形式的信息包含进来。其特点如下：</p><ul><li>允许直接包含纯文本形式的信息。</li><li>利用<code>&lt;img&gt;</code>和<code>&lt;embed&gt;</code>等标记来包含图片和声音等多媒体形式的信息。</li><li>利用<code>&lt;p&gt;</code>、<code>&lt;br&gt;</code> 、<code>&lt;font&gt;</code>等标记来设定信息在浏览器中的展示格式。</li><li>利用超级链接<code>&lt;a&lt;</code>来链接到其他信息。</li></ul><p>浏览器能够解析HTML文档中的标记，并且可以在浏览器窗口中直观的展示HTML文档。人们通常所说的网页或者Web页面，就是指HTML文档在浏览器中的展示页面。</p><h2 id="0x20-URL简介"><a href="#0x20-URL简介" class="headerlink" title="0x20 URL简介"></a>0x20 URL简介</h2><p><code>URL</code>是<code>Uniform Resource Locator</code>的缩写，表示统一资源定位器，它是专门为标识网络上的资源位置而设的一种编址方式。<code>URL</code>一般由三个部分组成：</p><ul><li>应用层协议</li><li>主机IP地址或域名</li><li>资源所在路径/文件名</li></ul><p><code>URL</code> 的格式：<code>应用层协议://主机IP地址或域名/路径/文件名</code></p><h2 id="0x30-HTTP协议简介"><a href="#0x30-HTTP协议简介" class="headerlink" title="0x30 HTTP协议简介"></a>0x30 HTTP协议简介</h2><p>略。</p><h2 id="0x40-用Java套接字创建HTTP客户与服务器程序"><a href="#0x40-用Java套接字创建HTTP客户与服务器程序" class="headerlink" title="0x40 用Java套接字创建HTTP客户与服务器程序"></a>0x40 用Java套接字创建HTTP客户与服务器程序</h2><p>当用户在浏览器中输入一个指向特定网页的URL时，浏览器会通过DNS解析域名，根据域名解析出服务器的IP地址后，浏览器会向这个IP地址发送请求，建立与远程服务器的TCP连接，然后浏览器将生成的HTTP请求发送给远程服务器，服务器再返回包含响应网页数据的HTTP响应，最后浏览器会把这个网页显示出来。</p><p>浏览器应该具备的功能：</p><ul><li>请求与Web服务器建立TCP连接</li><li>创建并发送HTTP请求</li><li>接收并解析HTTP响应</li><li>在窗口展示HTTP文档</li></ul><p>Web服务器应该具备的功能：</p><ul><li>接收来自浏览器的TCP连接请求</li><li>接收并解析HTTP请求</li><li>创建并发送HTTP响应</li></ul><p>HTTP客户程序和HTTP服务器分别由不同的软件开发商开发，目前最常用的HTTP客户程序包括Firefox、Chrome等，在Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache和Nginx服务器，而Windows平台使用IIS服务器。HTTP客户程序和服务器程序都可以用任意的编程语言编写，并且可以运行在不同的平台上，其顺利通信归功于HTTP协议。HTTP协议严格规定了HTTP请求和HTTP响应的数据格式，只要HTTP服务器与客户程序之间的交换数据都遵守HTTP协议，双方就能看得懂对方发送的数据，从而顺利交流。</p><p>HTTP服务器的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8090</span>;<br>        ServerSocket serverSocket;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                服务器监听端口</span><br><span class="hljs-comment">             */</span><br>            serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>            System.out.println(<span class="hljs-string">&quot;服务器正在监听端口：&quot;</span> + serverSocket.getLocalPort());<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><br>                Socket socket = serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;与客户端建立了一个TCP连接，客户端地址为：&quot;</span> + socket.getInetAddress());<br>                <span class="hljs-comment">// 调用service 方法解析HTTP请求</span><br>                service(socket);<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">// 获取来自客户端(浏览器)的输入流</span><br>        InputStream socketIs = socket.getInputStream();<br><br>        <span class="hljs-comment">// 睡眠500毫秒来等待HTTP请求</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                从输入流中读取HTTP请求</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">int</span> sizeIs = socketIs.available();<br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[sizeIs];<br>            socketIs.read(buffer);<br>            String request = <span class="hljs-keyword">new</span> String(buffer);<br>            <span class="hljs-comment">// 打印HTTP请求信息</span><br>            System.out.println(request);<br><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                解析HTTP请求</span><br><span class="hljs-comment">            */</span><br><br>            <span class="hljs-comment">// 获得Http请求的第一行</span><br>            String firstLineOfRequest = request.substring(<span class="hljs-number">0</span>, request.indexOf(<span class="hljs-string">&quot;\r\n&quot;</span>));<br>            <span class="hljs-comment">// 解析HTTP请求的第一行</span><br>            String[] parts = firstLineOfRequest.split(<span class="hljs-string">&quot; &quot;</span>);<br>            String uri = parts[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获得请求URI</span><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                决定HTTP响应正文的类型;</span><br><span class="hljs-comment">                这里做简化处理，仅考虑两种类型;</span><br><span class="hljs-comment">            */</span><br>            String contentType;<br>            <span class="hljs-keyword">if</span>(uri.indexOf(<span class="hljs-string">&quot;html&quot;</span>) != -<span class="hljs-number">1</span> || uri.indexOf(<span class="hljs-string">&quot;htm&quot;</span>) != -<span class="hljs-number">1</span>)<br>                contentType = <span class="hljs-string">&quot;text/html&quot;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(uri.indexOf(<span class="hljs-string">&quot;jpg&quot;</span>) != -<span class="hljs-number">1</span> || uri.indexOf(<span class="hljs-string">&quot;jpeg&quot;</span>) != -<span class="hljs-number">1</span>)<br>                contentType = <span class="hljs-string">&quot;image/jpeg&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                contentType = <span class="hljs-string">&quot;application/octet-stream&quot;</span>; <span class="hljs-comment">// 字节流类型</span><br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                创建响应HTTP响应结果</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// HTTP响应的第一行</span><br>            String responseFirstLine = <span class="hljs-string">&quot;HTTP1.1 200 OK\r\n&quot;</span>;<br>            <span class="hljs-comment">// HTTP响应头</span><br>            String responseHeader = <span class="hljs-string">&quot;Content-Type:&quot;</span> + contentType + <span class="hljs-string">&quot;\r\n\r\n&quot;</span>; <span class="hljs-comment">// 注意响应头和正文之间有一个空行</span><br>            <span class="hljs-comment">// 根据请求URI获取响应正文数据的输入流</span><br>            System.out.println(uri);<br>            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;JavaWeb/WEB-INFO/&quot;</span> + uri);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                发送HTTP响应结果</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 获得套接字的输出流</span><br>            OutputStream socketOs = socket.getOutputStream();<br>            <span class="hljs-comment">// 发送HTTP响应的第一行</span><br>            socketOs.write(responseFirstLine.getBytes());<br>            <span class="hljs-comment">// 发送HTTP响应头</span><br>            socketOs.write(responseHeader.getBytes());<br>            <span class="hljs-comment">// 发送HTTP响应正文</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>            buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">128</span>];<br>            <span class="hljs-keyword">while</span>( (len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                socketOs.write(buffer, <span class="hljs-number">0</span>, len);<br>                System.out.println(<span class="hljs-keyword">new</span> String(buffer));<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;发送完成&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            socket.close();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>HTTP客户端的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String uri = <span class="hljs-string">&quot;index.html&quot;</span>;<br>        doGet(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8090</span>, uri);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port, String uri)</span></span>&#123;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 与HTTP服务器建立TCP连接</span><br>            socket = <span class="hljs-keyword">new</span> Socket(host, port);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br><br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                构造HTTP请求头</span><br><span class="hljs-comment">             */</span><br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;GET &quot;</span> + uri + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;Accept: */*\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;Accept-Language: zh-cn\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;Accept-Encoding: gzip, deflate\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;User-Agent: HttpClient\r\n&quot;</span>);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                发送HTTP请求</span><br><span class="hljs-comment">             */</span><br>            OutputStream socketOs = socket.getOutputStream();<br>            socketOs.write(sb.toString().getBytes());<br><br>            <span class="hljs-comment">// 睡眠2秒，等待HTTP响应</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                接收HTTP响应并打印出响应结果</span><br><span class="hljs-comment">             */</span><br>            InputStream socketIs = socket.getInputStream(); <span class="hljs-comment">// 获得输入流</span><br>            <span class="hljs-keyword">int</span> size = socketIs.available();<br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>            socketIs.read(buffer);<br>            System.out.println(<span class="hljs-keyword">new</span> String(buffer)); <span class="hljs-comment">// 打印响应结果</span><br><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                socket.close(); <span class="hljs-comment">// 断开TCP连接</span><br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="0x41-用HttpClient客户程序访问HttpServer程序"><a href="#0x41-用HttpClient客户程序访问HttpServer程序" class="headerlink" title="0x41 用HttpClient客户程序访问HttpServer程序"></a>0x41 用HttpClient客户程序访问HttpServer程序</h3><ol><li><p>运行HttpServer程序，监听8090端口</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-1.png" alt="image.png" style="zoom:80%;" /></li><li><p>运行HttpClient程序，与HttpServer的8090端口建立TCP连接，发送一个HTTP请求，收到一个HTTP响应</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-2.png" alt="image.png" style="zoom: 50%;" /></li><li><p>查看HttpServer的响应，HttpServer与HttpClient成功建立TCP连接，接收并解析来自HttpClient的HTTP请求并返回一个HTTP响应</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-3.png" alt="image.png" style="zoom: 50%;" /></li></ol><h3 id="0x42-浏览器访问HttpServer程序"><a href="#0x42-浏览器访问HttpServer程序" class="headerlink" title="0x42 浏览器访问HttpServer程序"></a>0x42 浏览器访问HttpServer程序</h3><ol><li><p>运行HttpServer程序，监听8090端口</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-4.png" alt="image.png" style="zoom:80%;" /></li><li><p>浏览器访问HttpServer程序，与HttpServer建立TCP连接并发送HTTP请求，收到HTTP响应并解析显示在浏览器窗口</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-5.png" alt="image.png" style="zoom:50%;" /></li><li><p>HttpServer程序与浏览器建立TCP连接，接收其HTTP请求并返回一个HTTP响应</p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-6.png" alt="image.png" style="zoom: 50%;" /></li></ol><h2 id="0x50-Web的发展历程"><a href="#0x50-Web的发展历程" class="headerlink" title="0x50 Web的发展历程"></a>0x50 Web的发展历程</h2><h3 id="0x51-阶段一：发布静态HTML文档"><a href="#0x51-阶段一：发布静态HTML文档" class="headerlink" title="0x51 阶段一：发布静态HTML文档"></a>0x51 阶段一：发布静态HTML文档</h3><p>静态HTML文档就是指事先存放在Web服务器端的文件系统中的HTML文档。当用户在浏览器中输入指向特定HTML文档的URL时，WEB服务器就会把该HTML文档的数据发送到浏览器端。在这个阶段，HTML文档只能包含文本及图片。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-7.png" alt="未命名文件.png"></p><h3 id="0x52-阶段二：发布静态多媒体信息"><a href="#0x52-阶段二：发布静态多媒体信息" class="headerlink" title="0x52 阶段二：发布静态多媒体信息"></a>0x52 阶段二：发布静态多媒体信息</h3><p>在上一个阶段，信息只能以文本和图片的形式来发布，这满足不了用户对信息形式多样化的强烈需求。用户的需求使得多媒体信息被引入到Web领域，在这个阶段，信息可以用文本、图片、动画、声音和视频等形式来表示。</p><p>从技术角度来看，这个阶段主要增强了浏览器的功能，要求浏览器能集成一些插件，并利用这些插件来展示特定形式的信息；而Web服务器并不需要做改进，不管是任何形式的静态信息，它们都作为文件事先存放在Web服务器端的文件系统中，Web服务器只需把包含特定信息的文件中的数据发送给浏览器即可，然后由浏览器来负责解析和展示数据。</p><h3 id="0x53-阶段三：提供浏览器端与用户的动态交互功能"><a href="#0x53-阶段三：提供浏览器端与用户的动态交互功能" class="headerlink" title="0x53 阶段三：提供浏览器端与用户的动态交互功能"></a>0x53 阶段三：提供浏览器端与用户的动态交互功能</h3><p>在上述几个阶段，用户在浏览器端都只能被动的观看来自服务器的静态信息。到了本阶段，用户不仅可以通过浏览器浏览信息，还可以与浏览器交互。该功能的实现归功于<code>Java Applet</code>、<code>JavaScript</code>等脚本语言的问世，此外，浏览器还必须能够解析和运行用脚本语言编写的小程序。</p><p>在这个阶段，Web服务器不需要做改进，执行用脚本语言编写的小程序的任务由浏览器来完成，Web服务器只要把包含小程序代码的文件中的数据发送到浏览器端即可。</p><h3 id="0x54-阶段四：提供服务器端与用户的动态交互功能"><a href="#0x54-阶段四：提供服务器端与用户的动态交互功能" class="headerlink" title="0x54 阶段四：提供服务器端与用户的动态交互功能"></a>0x54 阶段四：提供服务器端与用户的动态交互功能</h3><p>以上第三个阶段为用户提供了一些动态交互功能，该功能是由浏览器来完成的，并对用户的浏览器提出了诸多技术要求，如果浏览器不支持某种脚本语言，就无法运行网页中的脚本程序。</p><p>可以说，以上三个阶段的技术发展点都是在客户端，而对Web服务器端都没有做特别要求。到了本阶段，Web服务器端增加了动态执行特定程序代码的功能，这使得Web服务器能利用特定程序代码来动态生成HTML文档。Web服务器动态执行的程序分为两种：</p><ul><li>完全用编程语言编写的程序，如CGI（Common Gateway Interface）程序和用Java编写的Servlet程序。</li><li>嵌入了程序代码的HTML文档，如PHP、ASP和JSP文档。JSP文档是指嵌入了Java程序代码的HTML文档。</li></ul><blockquote><p>注：Web服务器动态执行特定程序代码的特征是Web服务器在运行时加载并执行由第三方提供的程序代码。所谓Web服务器动态生成HTML文档，就是指Web服务器再运行时才通过执行特定程序代码来生成HTML文档，而不是直接从文件系统中获取已经存在的HTML文档。</p></blockquote><p><strong>Servlet的简单模拟</strong></p><p>下面以Servlet为例，简单介绍Web服务器动态执行完全用编程语言编写的程序的原理。</p><p>我们在服务器端存放一个用Java语言编写的程序的<code>.class</code>文件——<code>HelloServlet.class</code>。当用户在浏览器端输入指向该类的URL时，Web服务器就会运行<code>HelloServlet</code>类，<code>HelloServlet</code>类生成<code>HTML</code>文档，并把它发给浏览器。</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-8.png" alt="image"></p><p>我们首先定义了一个<a href="../server/Servlet.java" title="Servlet接口">Servlet接口</a>（这个Servlet接口与SUN公司的Servlet规范中的Servlet接口有相似之处，这个简化了的Servlet接口能帮助我们理解Servlet的作用和运行原理），这个接口有一个<code>init()</code>方法和<code>service()</code>方法：</p><ul><li><code>init()</code>方法：初始化方法，当<a href="../server/HttpServerOne.java">HttpServerOne</a>类创建了该接口的实现类的一个实例后，就会立即调用该实例的<code>init()</code>方法</li><li><code>service()</code>方法：用于响应HTTP请求，产生具体的HTTP响应结果。<code>HttpServerOne</code>服务器在响应HTTP请求时，会调用实现了Servlet接口的特定类的<code>service()</code>方法。</li></ul><p>所谓的Web服务器动态执行程序代码，在本范例中就是<code>HttpServerOne</code>在运行时动态加载<code>Servlet</code>接口的实现类，创建它的实例，然后调用它的相关方法，这利用了Java语言的动态加载类的功能。</p><p><a href="../server/HelloServlet.java">HelloServlet类</a>实现了<code>Servlet</code>接口，其<code>service()</code>方法能解析HTTP请求中的请求参数，并会根据请求参数<code>username</code>的取值来生成HTML文档。</p><p>下面我们运行HttpServerOne服务器，然后用浏览器访问：</p><ol><li><p>启动服务器，监听端口</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/%20Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-9.png" alt="image"></p></li><li><p>浏览器访问，指定请求参数，得到对应的响应</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-10png" alt="image"></p><p>在上面的<a href="../server/HelloServlet.java">HelloServlet类</a>中我们必须费劲的解析原始的字符串形式的HTTP请求，而真正的Servlet技术无需我们自己动手解析字符串形式的HTTP请求，这个繁琐的工作由<strong>Servlet容器</strong>代劳了。</p></li></ol><h3 id="0x55-发布Web应用"><a href="#0x55-发布Web应用" class="headerlink" title="0x55 发布Web应用"></a>0x55 发布Web应用</h3><p>本阶段是在上一个阶段的基础上发展起来的。Web服务器端可动态执行的程序的功能变得越来越强大，不仅能动态生成HTML文档，还能处理各种应用领域里的业务逻辑，还能访问数据库。在这个阶段出现了Web应用的概念。所谓的Web应用，是指需要通过编程来创建的Web站点。在Web应用中不仅包括普通的静态HTML文档，还包含大量可被Web服务器动态执行的程序。用户在Internet上能开展业务的各种Web站点都可看作Web应用。</p><p>Web应用与传统桌面应用程序相比，具有以下特点：</p><ul><li>以浏览器作为展示客户端界面的窗口</li><li>客户端界面一律表现为网页形式，网页由HTML语言写成，具有交互功能</li><li>能完成与桌面应用程序类似的功能</li><li>使用浏览器-服务器架构，浏览器与服务器之间采用HTTP协议通信</li><li>Web应用通过Web服务器来发布</li></ul><h3 id="0x56-发布Web服务"><a href="#0x56-发布Web服务" class="headerlink" title="0x56 发布Web服务"></a>0x56 发布Web服务</h3><p><strong>Web</strong>是基于HTTP协议的分布式架构。HTTP协议采用客户/服务器通信模式，该协议规定了服务器与浏览器之间的交换数据的通信细节。</p><p><strong>Web服务架构</strong>与Web一样，也是网络应用层的一种分布式架构，同时也是基于客户/服务器通信模式，并且也能实现异构系统之间的通信。在Web服务架构中，服务端负责提供Web服务，而客户端则请求Web服务。Web服务可以看做是被客户端远程调用的各种方法，这些方法能处理特定业务逻辑，或者进行复杂运算等。请求过程如下；</p><p><img src="https://cdn.jsdelivr.net/gh/Ap0l1o/ImageHostingService@main/img/Web%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/F-11.png" alt="未命名文件 (2)"></p><p>Web服务架构采用SOAP（Simple Object Access Protocol，简单对象访问协议）作为通信协议。SOAP协议规定客户与服务器之间一律用XML语言进行通信。XML（Extensible Markup Language，可扩展标记语言）是一种可扩展的跨平台的标记语言。SOAP协议规定了客户端向服务器端发送的Web服务请求的具体数据格式，以及服务器端向客户端发送的Web服务响应结果的具体数据格式。</p><p>Web服务实际上是借助Web服务器来发布到网络上的，借用Web服务器来发布Web服务，就不必再创建专门的基于SOAP协议的服务器程序了。以下是客户程序访问特定Web服务的过程：</p><ol><li>客户程序发出一个<strong>原始请求</strong>。</li><li>客户端协议解析器负责把客户程序的原始请求包装为一个XML格式的<strong>SOAP请求</strong>。SOAP请求是基于SOAP协议的Web服务请求的简称。</li><li>客户端协议连接器把SOAP请求包装成一个<strong>HTTP请求</strong>，其中SOAP请求变成了HTTP请求的正文部分。客户端协议连接器接着把HTTP请求发送给Web服务器。</li><li>Web服务器接收到HTTP请求，取出HTTP请求的正文部分，即获得了<strong>SOAP请求</strong>。</li><li>服务器端协议解析器从SOAP请求中获取客户程序的<strong>原始请求数据</strong>，对其解析，然后调用Web服务。</li><li>Web服务返回<strong>原始的响应结果</strong>。</li><li>服务器端协议解析器把Web服务返回的原始响应结果包装为<strong>SOAP响应结果</strong>。SOAP响应结果是基于SOAP协议的Web服务响应结果的简称。</li><li>Web服务器把SOAP响应结果包装成一个<strong>HTTP响应结果</strong>，其中SOAP响应结果变成了HTTP响应结果的正文部分。Web服务器接着把HTTP响应结果发送给客户端协议连接器。</li><li>客户端协议连接器接收到HTTP响应结果，取出HTTP响应结果的正文部分，即得到了<strong>SOAP响应结果</strong>。</li><li>客户端协议解析器从SOAP响应结果中得到<strong>Web服务的原始响应结果</strong>，把它交给客户程序。</li></ol><p>Web的基本功能是提供客户程序与服务器之间的数据传输（主要是服务器发送给浏览器的HTML文档），而Web服务的基本功能是客户程序远程调用服务器端的方法。由于在进行远程方法调用时，客户端与服务器之间也涉及到数据的交换，因此Web服务可以借助Web来传输双方的通信数据。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
