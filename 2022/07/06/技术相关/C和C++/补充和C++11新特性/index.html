<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="C++智能指针和强制类型转换知识点总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++智能指针和强制类型转换">
<meta property="og:url" content="http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="ap0l1o">
<meta property="og:description" content="C++智能指针和强制类型转换知识点总结。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-06T05:03:00.000Z">
<meta property="article:modified_time" content="2023-12-20T13:06:24.021Z">
<meta property="article:author" content="ap0l1o">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/endless.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/endless-192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/endless-180.png">
        
      
    
    <!-- title -->
    <title>C++智能指针和强制类型转换</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="ap0l1o" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 RTL">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/CS%E5%9F%BA%E7%A1%80/%E6%88%91%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&text=C++智能指针和强制类型转换"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&is_video=false&description=C++智能指针和强制类型转换"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++智能指针和强制类型转换&body=Check out this article: http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&name=C++智能指针和强制类型转换&description=C++智能指针和强制类型转换知识点总结。"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&t=C++智能指针和强制类型转换"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">构造函数可以抛出异常吗，有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">初始化列表的异常怎么捕获？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">析构函数可以抛出异常吗，有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">析构函数如何处理异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">6.</span> <span class="toc-text">shared_ptr是线程安全的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr"><span class="toc-number">7.1.</span> <span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">7.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">7.3.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E5%A2%9E%E5%87%8F%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">7.3.1.</span> <span class="toc-text">计数器增减的规则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">7.4.</span> <span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">自己实现一个智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">内存泄漏检测方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">如何避免内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">野指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.</span> <span class="toc-text">强制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast"><span class="toc-number">11.1.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">11.2.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast"><span class="toc-number">11.3.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">11.4.</span> <span class="toc-text">reinterpret_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">12.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII"><span class="toc-number">13.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPP11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">14.</span> <span class="toc-text">CPP11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%E5%B8%B8%E9%87%8F"><span class="toc-number">14.1.</span> <span class="toc-text">nullptr常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexptr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.2.</span> <span class="toc-text">constexptr常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">auto类型指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">14.4.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">14.5.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">14.6.</span> <span class="toc-text">继承构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">14.7.</span> <span class="toc-text">override 保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.8.</span> <span class="toc-text">final 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4-for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">14.9.</span> <span class="toc-text">范围 for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%B1%82vector"><span class="toc-number">14.10.</span> <span class="toc-text">定义双层vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">14.11.</span> <span class="toc-text">仿函数（函数对象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.12.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8-function"><span class="toc-number">14.13.</span> <span class="toc-text">函数对象包装器 function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind%E7%BB%91%E5%AE%9A"><span class="toc-number">14.14.</span> <span class="toc-text">bind绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">14.15.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">14.16.</span> <span class="toc-text">移动语义</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        C++智能指针和强制类型转换
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ap0l1o</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-07-06T05:03:00.000Z" class="dt-published" itemprop="datePublished">2022-07-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> › <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/CS%E5%9F%BA%E7%A1%80/">CS基础</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C-C/" rel="tag">C/C++</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>对于如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = m/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>, argc<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后会提示 「出现未处理的异常」 ，这是因为 <code>foo</code> 函数里未处理 <code>n</code> 为 0 的情况，异常需要捕获。可以使用 <code>try catch</code> 来捕获。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = m / n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (...)	<span class="comment">// ...表示接住任何异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">foo</span>(<span class="number">1</span>, argc - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数可以抛出异常吗，有什么问题？"><a href="#构造函数可以抛出异常吗，有什么问题？" class="headerlink" title="构造函数可以抛出异常吗，有什么问题？"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qinguoyi/p/10304882.html">构造函数可以抛出异常吗，有什么问题？</a></h2><p>构造函数中应该避免抛出异常：</p>
<ul>
<li>构造函数中抛出异常后，对象的析构函数将不会被执行；</li>
<li>构造函数抛出异常时，本应该在析构函数中被 <code>delete</code> 的对象没有被 <code>delete</code>，会导致内存泄露；</li>
<li>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构；</li>
</ul>
<h2 id="初始化列表的异常怎么捕获？"><a href="#初始化列表的异常怎么捕获？" class="headerlink" title="初始化列表的异常怎么捕获？"></a>初始化列表的异常怎么捕获？</h2><ul>
<li>初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的 <code>try-catch</code> 不能执行，<code>catch</code> 也无法处理异常。可以通过函数 <code>try</code> 块解决该问题。</li>
<li>函数 <code>try</code> 块中的 <code>try</code> 出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个 <code>try</code> 关联的 <code>catch</code> 既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。cd ls</li>
</ul>
<h2 id="析构函数可以抛出异常吗，有什么问题？"><a href="#析构函数可以抛出异常吗，有什么问题？" class="headerlink" title="析构函数可以抛出异常吗，有什么问题？"></a>析构函数可以抛出异常吗，有什么问题？</h2><p><strong>析构函数不应该抛出异常</strong>：</p>
<ul>
<li><strong>其他正常，仅析构函数异常</strong>。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li>
<li><strong>其他异常，且析构函数异常</strong>。通常异常发生时，C++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li>
</ul>
<h2 id="析构函数如何处理异常？"><a href="#析构函数如何处理异常？" class="headerlink" title="析构函数如何处理异常？"></a>析构函数如何处理异常？</h2><ul>
<li>若析构函数抛出异常，调用 <code>std::abort()</code> 来终止程序；</li>
<li>在析构函数中 <code>catch</code> 捕获异常并作处理，吞下异常；</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，类应该提供普通函数执行该操作，而非在析构函数中；</li>
</ul>
<h2 id="shared-ptr是线程安全的吗"><a href="#shared-ptr是线程安全的吗" class="headerlink" title="shared_ptr是线程安全的吗"></a>shared_ptr是线程安全的吗</h2><p><strong>(1) 从引用计数的角度来看：</strong><br>虽然引用计数存在于每一个 <code>shared_ptr</code> 对象中，但是实际上它是要跟随对象所管理的资源。引用计数会随着指向这块资源的 <code>shared_ptr</code> 对象的增加而增加。因此引用计数是要指向同一块资源的所有的对象共享的，所以实际上引用计数在 <code>shared_ptr</code> 底层中是以指针的形式实现的，所有的对象通过指针访问同一块空间，从而实现共享。<br>那么也就是说，<strong>引用计数是一个临界资源</strong>，所以在多线程中，我们必须要保证临界资源访问的安全性，因此<strong>在 <code>shared_ptr</code> 底层中在对引用计数进行访问之前，首先对其加锁，当访问完毕之后，在对其进行解锁</strong>。<strong>所以 <code>shared_ptr</code> 的引用计数是线程安全的。</strong></p>
<p><strong>(2) 从被 shared_ptr 对象所管理的资源来看：</strong><br><code>shared_ptr</code>对象所管理的资源存放在堆上，它可以由多个<code>shared_ptr</code>所访问，所以这也是一个临界资源。<strong>因此当多个线程访问它时，会出现线程安全的问题</strong>。<br><strong>首先 <code>shared_ptr</code> 对象有两个变量，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数</strong>，当 <code>shared_ptr</code> 发生拷贝的时候，是先拷贝指向对象的指针，然后再拷贝引用计数，也就是说，**<code>shared_ptr</code> 的拷贝并不是一个原子操作<strong>。而问题就出现在这里。<br>所以</strong>多个<code>shared_ptr</code>对象对其所管理的资源的访问不是线程安全的**。如果不使用锁这会造成线程安全问题。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TianFang/archive/2008/09/20/1294590.html">智能指针</a></h2><p>智能指针有 <code>shared_ptr</code>， <code>weak_ptr</code>，<code>unique_ptr</code>，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wxquare/p/4759020.html">参考</a>，使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><ul>
<li><p><code>auto_ptr</code>指针在c++11标准中就被废除了，可以使用<code>unique_ptr</code>来替代，功能上是相同的，<code>unique_ptr</code>相比较<code>auto_ptr</code>而言，提升了安全性（没有浅拷贝），增加了特性（<code>delete</code>析构）和对数组的支持。</p>
</li>
<li><p><strong>有两个不好的地方</strong></p>
<ul>
<li>不能有两个 <code>auto_ptr</code> 对象拥有同一个内部指针的所有权，因为有可能某一时刻，两者均尝试析构这个内部指针。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 这样是错的</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">aptr1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">aptr2</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>当<strong>两个 auto_ptr 对象</strong>之间发生<strong>赋值</strong>操作时，内部指针被拥有的所有权会转移，这意味着右者对象会丧失所有权，不再指向这个内部指针（会被设置为 NULL）  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用其他的auto_ptr指针进行初始化</span></span><br><span class="line">std::auto_ptr&lt;<span class="keyword">int</span>&gt; aptr2 = aptr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;aptr2 %p : %d\r\n&quot;</span>, aptr2.<span class="built_in">get</span>(), *aptr2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>auto_ptr</code>的构造的参数可以是一个指针，或者是另外一个<code>auto_ptr</code>对象。当一个新的<code>auto_ptr</code>获取了内部指针的所有权后，之前的拥有者会释放其所有权。</p>
</li>
<li><p><code>auto_ptr.get()</code>获取地址，<code>*ptr</code>获取内容</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">aptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;auto_ptr %p : %d\r\n&quot;</span>, aptr.<span class="built_in">get</span>(), *aptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">auto_ptr 0000000000d71730 : 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>auto_ptr.release()</code>解除<code>auto_ptr</code>与指针的关系，并不释放掉原来的指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p %p : %d\r\n&quot;</span>, p, *p);</span><br><span class="line">    </span><br><span class="line">	<span class="function">std::auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">aptr</span><span class="params">(p)</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;auto_ptr %p : %d\r\n&quot;</span>, aptr.<span class="built_in">get</span>(), *aptr);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span>* ptr = aptr.<span class="built_in">release</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ptr %p : %d\r\n&quot;</span>, ptr, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以看出，原来指针的内容并没有被释放，只是解除了关系</span></span><br><span class="line"><span class="comment">p 0000000001001730 : 4</span></span><br><span class="line"><span class="comment">auto_ptr 0000000001001730 : 4</span></span><br><span class="line"><span class="comment">ptr 0000000001001730 : 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto_ptr.reset(p)</code>，将智能指针对象重置为<code>p</code>，并释放掉原来的指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1 %p : %d\r\n&quot;</span>, p1, *p1);</span><br><span class="line">    <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">4</span>);</span><br><span class="line">	<span class="function">std::auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">aptr</span><span class="params">(p1)</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;auto_ptr %p : %d\r\n&quot;</span>, aptr.<span class="built_in">get</span>(), *aptr);</span><br><span class="line">    </span><br><span class="line">    aptr.<span class="built_in">reset</span>(p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;auto_ptr %p : %d\r\n&quot;</span>, aptr.<span class="built_in">get</span>(), *aptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 %p : %d\r\n&quot;</span>, p1, *p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p1 0000000000781730 : 3</span></span><br><span class="line"><span class="comment">auto_ptr 0000000000f41730 : 3</span></span><br><span class="line"><span class="comment">auto_ptr 0000000000f41750 : 4</span></span><br><span class="line"><span class="comment">p1 0000000000781730 : 7871136</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>auto_ptr</code> 存在的问题</p>
<ul>
<li><strong>作为参数传递会存在问题</strong><ul>
<li>因为有拷贝构造和赋值的情况下，会释放原有的对象的内部指针，所以当有函数使用的是<code>auto_ptr</code>时，调用后会导致原来的内部指针释放。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_test</span><span class="params">(std::auto_ptr&lt;<span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::auto_ptr&lt;<span class="keyword">int</span>&gt; p1 = std::auto_ptr&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>));</span><br><span class="line">	<span class="built_in">foo_test</span>(p1);</span><br><span class="line">	<span class="comment">//这里的调用就会出错，因为拷贝构造函数的存在，p1实际上已经释放了其内部指针的所有权了</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, *p1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>不能使用 vector 数组</strong><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3></li>
</ul>
</li>
</ul>
<ul>
<li><p><code>shared_ptr</code>核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p>
<ul>
<li>不能将指针直接<strong>赋值</strong>给一个智能指针，一个是类，一个是指针。例如 ：<code>std::shared_ptr&lt;int&gt; p4 = new int(1);</code></li>
<li>可行的方式： <code>std::shared_ptr&lt;int&gt; p4(new int(1));</code><strong>初始化</strong></li>
<li>拷贝使得对象的引用计数增加 1，赋值使得原对象引用计数减 1，当计数为 0 时，自动释放内存。后来指向的对象引用计数加 1，指向后来的对象</li>
<li>赋值操作符减少左操作数原所指对象的引用计数（如果引用计数为减至 0，则删除对象），并增加右操作数所指对象的引用计数</li>
</ul>
</li>
<li><p><strong><code>shared_ptr</code> 创建后是栈上的对象，当出作用域后，每个对象会自动调用析构函数</strong>，如上所述，<code>new int(1)</code> 会生成一个指针，此时将其传参数给 <code>shared_ptr</code>，由 <code>shared_ptr</code> 对其进行管理，**<code>shared_ptr</code> 虽然是对象，但其有指针的特性，通过重载运算符<code>*</code>和<code>-&gt;</code>实现指针的特性来访问被管理的指针**。</p>
</li>
<li><p><code>shared_ptr</code>是可以共享所有权的智能指针</p>
<ul>
<li><code>shared_ptr</code> 的管理机制其实并不复杂，就是对所管理的对象（这里的对象本质是被管理的指针 <code>new int (1)</code>，并不是类和对象中的对象）进行了引用计数，当新增一个 <code>shared_ptr</code> 对该对象进行管理时，就将该对象的引用计数加一；减少一个 <code>shared_ptr</code> 对该对象进行管理时，就将该对象的引用计数减一，如果该对象的引用计数为 0 的时候，说明没有任何指针对其管理，才调用 <code>delete</code> 释放其所占的内存。   </li>
<li>对 <code>shared_ptr</code> 进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类，<strong>可以通过 <code>make_shared</code> 函数或者通过构造函数传入普通指针</strong></li>
<li>**不要把一个原生指针给多个 <code>shared_ptr</code>**，不要把 <code>this</code> 指针交给智能指针管理，这样会重复释放</li>
<li><strong><code>shared_ptr</code> 之间的资源共享是通过 <code>shared_ptr</code> 智能指针拷贝、赋值实现的，因为这样可以引起计数器的更新</strong>；而如果直接通过原生指针来初始化，就会导致 <code>m_sp</code> 和 <code>p</code> 都根本不知道对方的存在，然而却两者都管理同一块地方。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>; <span class="comment">//这样不会导致更新，两者不知对方存在</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">//这样才会导致计数器更新</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>shared_ptr</code>循环引用导致内存泄漏，引出<code>weak_ptr</code></p>
<ul>
<li>循环引用是两个强引用（<code>shared_ptr</code>）互相引用，使得两者的引用计数无法为0，进而无法释放，此时将循环引用的一方变为<code>weak_ptr</code>即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CA() called! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~CA() called! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_ptr</span><span class="params">(shared_ptr&lt;CB&gt; &amp;ptr)</span></span>&#123;</span><br><span class="line">        m_ptr_b = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;CB&gt; m_ptr_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CB</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CB() called! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CB</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~CB() called! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_ptr</span><span class="params">(shared_ptr&lt;CA&gt; &amp;ptr)</span></span>&#123; </span><br><span class="line">        m_ptr_a = ptr; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;CA&gt; m_ptr_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_refer_to_each_other</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;CA&gt; <span class="title">ptr_a</span><span class="params">(<span class="keyword">new</span> CA())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;CB&gt; <span class="title">ptr_b</span><span class="params">(<span class="keyword">new</span> CB())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr_a-&gt;<span class="built_in">set_ptr</span>(ptr_b);</span><br><span class="line">    ptr_b-&gt;<span class="built_in">set_ptr</span>(ptr_a);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_refer_to_each_other</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CA() called! </span></span><br><span class="line"><span class="comment">CB() called!</span></span><br><span class="line"><span class="comment">a use count : 1</span></span><br><span class="line"><span class="comment">b use count : 1</span></span><br><span class="line"><span class="comment">a use count : 2</span></span><br><span class="line"><span class="comment">b use count : 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
通过结果可以看到，最后<code>CA</code>和<code>CB</code>的对象并没有被析构。</li>
</ul>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul>
<li><strong>弱引用（<code>weak_ptr</code>）并不修改该对象的引用计数</strong>，<code>weak_ptr</code> 必须从一个 <code>share_ptr</code> 或另一个 <code>weak_ptr</code> 转换而来，这也说明，进行该对象的内存管理的是那个强引用的 <code>share_ptr</code>，<code>weak_ptr</code> 只是提供了对管理对象的一个访问手段这意味这弱引用它并不对对象的内存进行管理。弱引用在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</li>
</ul>
<ul>
<li>弱引用的 <code>expired()</code> 函数用于检测所管理的对象是否已经释放；</li>
<li>弱引用的 <code>lock()</code> 函数用于获取所管理的对象的强引用指针，不能直接访问弱引用，需要将其先通过 <code>lock</code> 转换为强引用再访问</li>
</ul>
<h4 id="计数器增减的规则："><a href="#计数器增减的规则：" class="headerlink" title="计数器增减的规则："></a>计数器增减的规则：</h4><p>初始化及增加的情形</p>
<ul>
<li>当创建一个新的<code>shared_ptr</code>时，内部对象计数器<code>T</code>和自身的计数器<code>Ref</code>均置1；</li>
<li>当将另外一个 <code>shared_ptr</code> 赋值给新的 <code>shared_ptr</code> 时，内部对象计数器+1（也即正常的引用计数），自身计数器（自身计数器也即若引用技术）不变；</li>
<li>当将另外一个<code>shared_ptr</code>赋值给新的<code>weak_ptr</code>时，内部对象计数器不变，自身计数器+1；</li>
<li>当从<code>weak_ptr</code>获取一个<code>shared_ptr</code>时，内部对象计数器+1，自身计数器不变。</li>
<li><strong>规律就是当<code>shared_ptr</code>加1的时候，内部对象计数器+1；当<code>weak_ptr</code>加1的时候，自身计数器+1。</strong><br>减少的情形：</li>
<li>当一个<code>shared_ptr</code>析构时，内部对象计数器-1.当内部对象计数器减为0时，则释放内部对象，并将自身计数器-1。</li>
<li>当一个<code>weak_ptr</code>析构时，自身计数器-1，当自身计数器减为0时，则释放自身<code>_Ref_count*</code>对象。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul>
<li> <code>unique_ptr</code> 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象</li>
</ul>
<ul>
<li><code>unique_ptr</code> 禁止使用<strong>拷贝构造</strong>和<strong>赋值运算符</strong>。因此，这就从根源上杜绝了 <code>auto_ptr</code> 作为参数传递的写法了。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="comment">// 这3种是不允许使用的</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = p;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(p)</span></span>;</span><br><span class="line">p4 = p;</span><br></pre></td></tr></table></figure>
</li>
<li><code>unique_ptr</code>多了<code>move</code>的用法。因为<code>unique_ptr</code>不能将自身对象内部指针直接赋值给其他<code>unique_ptr</code>，所以这里可以使用<code>std::move()</code>函数，让<code>unique_ptr</code>交出其内部指针的所有权，而自身置空，内部指针不会释放。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(p)</span></span>;</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; uptr2 = std::<span class="built_in">move</span>(uptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>数组  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_ary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;<span class="keyword">int</span>&gt;&gt; Ary;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">    Ary.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(uptr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, *uptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自己实现一个智能指针"><a href="#自己实现一个智能指针" class="headerlink" title="自己实现一个智能指针"></a>自己实现一个智能指针</h2><ol>
<li>用起来像指针</li>
<li>会自己对资源进行释放<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="keyword">size_t</span>* count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">SmartPointer</span>(T* _ptr = <span class="literal">nullptr</span>) : <span class="built_in">ptr</span>(_ptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">            count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer&amp; sptr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;sptr) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = sptr.ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = sptr.count;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;count)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; sptr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptr == sptr.ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =左边所指对象引用计数减一</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptr) &#123;	</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;count)--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = sptr.ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = sptr.count;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;count)++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载*</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载-&gt;</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;count)--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="keyword">this</span>-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">    sp2 = sp3;</span><br><span class="line">    cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h3 id="内存泄漏检测方法"><a href="#内存泄漏检测方法" class="headerlink" title="内存泄漏检测方法"></a>内存泄漏检测方法</h3><ul>
<li><p><code>VS</code>有一个CRT函数    <code>_CrtDumpMemoryLeaks()</code>函数，头文件<code>&lt;crtdbg.h&gt;</code>，程序前面加上 <code>#define CRTDBG_MAP_ALLOC</code></p>
</li>
<li><p>Linux系统下内存泄漏的检测方法（<code>valgrind</code>）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o test test.cpp</span><br><span class="line">valgrind --tool=memcheck ./test</span><br></pre></td></tr></table></figure></li>
<li><p>可以检测如下问题：</p>
<ul>
<li>使用未初始化的内存</li>
<li>内存读写越界</li>
<li>内存覆盖（<code>strcpy/strcat/memcpy</code>）</li>
<li>动态内存管理</li>
<li>内存泄漏<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3></li>
</ul>
</li>
</ul>
<ul>
<li>尽量避免在堆上分配内存</li>
<li>不要手动管理内存，可以尝试在适用的情况下使用智能指针</li>
<li>使用RAII</li>
<li>在 C++中避免内存泄漏的最好方法是尽可能少地在程序级别上进行 <code>new</code> 和 <code>delete</code> 调用，最好是没有</li>
</ul>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><strong>野指针指向一个已删除的对象或申请访问受限内存区域的指针</strong>。出现野指针的原因：</p>
<ul>
<li>指针变量未初始化；</li>
<li>指针释放未置空；</li>
<li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放；<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2>C++中强制转换为 <code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code>，<code>reinterpret_cast</code>，主要是为了解决 C 语言强制类型转换的以下三个缺点：</li>
</ul>
<ol>
<li><strong>没有从形式上体现出转换功能和风险的不同</strong><ul>
<li>例如，将 <code>int</code> 转换为 <code>double</code> 是没有风险的，但是将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同，C 语言的强制类型转换对这些不同不加以区分。</li>
</ul>
</li>
<li><strong>将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象</strong></li>
<li><strong>难以在程序中寻找到底什么地方进行了强制类型转换</strong><ul>
<li>强制类型转换时引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</li>
</ul>
</li>
</ol>
<p>C++有以下四种强制类型转换运算符：</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>基本等价于隐式转换，<strong>可以用于低风险的转换</strong>：</p>
<ul>
<li>整型和浮点型；</li>
<li>字符与整型；</li>
<li>转换运算符；</li>
<li><strong>空指针转换为任何目标类型的指针</strong>；</li>
<li><strong>可以用于子类指针转换为基类指针</strong>；</li>
</ul>
<p><strong>不可以用于风险较高的转换</strong>：</p>
<ul>
<li>不同类型的指针之间的转换</li>
<li>整型和指针之间的互相转换</li>
<li>不同类型的引用之间的转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 转换运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nInt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m_nInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">float</span> f = <span class="number">10.0f</span>;</span><br><span class="line">	f = n; <span class="comment">// 本质进行了隐式转换</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 低风险的转换 */</span></span><br><span class="line">	<span class="comment">// 整型与浮点型</span></span><br><span class="line">	<span class="keyword">float</span> ff = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字符与整型</span></span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// void*指针的转换</span></span><br><span class="line">	<span class="keyword">void</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">int</span> *pn = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换运算符</span></span><br><span class="line">	CInt obj;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(obj);</span><br><span class="line">	<span class="keyword">int</span> kk = obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 高风险的转换: 不允许，均无法编译通过 */</span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="comment">// 整型与指针转化</span></span><br><span class="line">	p = t;</span><br><span class="line">	<span class="keyword">char</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(t);</span><br><span class="line">	<span class="comment">// 不同指针类型之间转换</span></span><br><span class="line">	<span class="keyword">int</span> *pp;</span><br><span class="line">	p = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(pp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>static_cast 可用于基类与派生类之间的转换，但没有运行时类型检查</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *father = <span class="keyword">new</span> A;</span><br><span class="line">	B *son = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类转子类（不安全）</span></span><br><span class="line">	son = father;					<span class="comment">// 隐式转换失败</span></span><br><span class="line">	son = <span class="keyword">static_cast</span>&lt;B *&gt;(father); <span class="comment">// 转换成功，但是没有提供运行时检查，依然不安全</span></span><br><span class="line">	<span class="comment">// 子类转父类（安全）</span></span><br><span class="line">	father = son;					<span class="comment">// 成功</span></span><br><span class="line">	father = <span class="keyword">static_cast</span>&lt;A *&gt;(son); <span class="comment">// 成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><strong>用于具有虚函数的基类</strong>与<strong>派生类之间的指针或引用的转换</strong>。</p>
<ul>
<li>基类必须具备虚函数<ul>
<li>原因：<code>dynamic_cast</code> 是<strong>运行时类型检查</strong>，需要运行时类型信息（<code>RTTI</code>），而这个信息与类的<strong>虚函数表</strong>关系紧密，只有一个类定义了虚函数，才有虚函数表，也就是说会在运行时检测被转换的指针的类型（依赖 RTTI）</li>
</ul>
</li>
<li><strong>运行时检查</strong>，向下转化时，如果是非法的对于指针返回<code>NULL</code>，对于引用抛异常<code>bad_cast</code></li>
</ul>
<ul>
<li><strong>非必要时不要使用<code>dynamic_cast</code>，有额外的函数开销</strong></li>
</ul>
<p>常见的转换方式：</p>
<ul>
<li><strong>基类指针或引用转换为派生类指针和引用</strong>（<strong>必须使用</strong><code>dynamic_cast</code>）</li>
<li><strong>派生类指针或引用转基类指针或引用</strong>（更<strong>推荐使用</strong><code>static_cast</code>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 转换运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是父类&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是子类&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *father = <span class="keyword">new</span> A;</span><br><span class="line">	B *son = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向下转换：父类转子类（不安全）</span></span><br><span class="line">	<span class="comment">// dynamic_cast会在运行时进行检测，如果是不安全的，会转换失败</span></span><br><span class="line">	son = father;					 <span class="comment">// 隐式转换失败</span></span><br><span class="line">	son = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(father); <span class="comment">// 转换成功，全</span></span><br><span class="line">	<span class="comment">// 向上转换：子类转父类（安全）</span></span><br><span class="line">	father = son;					 <span class="comment">// 成功</span></span><br><span class="line">	father = <span class="keyword">dynamic_cast</span>&lt;A *&gt;(son); <span class="comment">// 成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><ul>
<li>用于删除 <code>const</code>、<code>volatile</code>特性，四个强制类型转换运算符中唯一能够去除<code>const</code>属性的运算符<ul>
<li><strong>常量对象或者基本数据类型不允许转化为非常量对象，只能通过指针或者引用来修改</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">const</span> string s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(n);	<span class="comment">// 错误</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// const_cast 中的类型必须是指针、引用、this指针</span></span><br><span class="line">	<span class="keyword">int</span> *k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;n);</span><br><span class="line">	*k = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; *k &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>常成员函数中去除 <code>this</code> 指针的 <code>const</code> 属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>() : <span class="built_in">m_nTest</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">// 常成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> nTest)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// m_nTest = nTest; // 错误</span></span><br><span class="line">		<span class="keyword">const_cast</span>&lt;CTest *&gt;(<span class="keyword">this</span>)-&gt;m_nTest = nTest; <span class="comment">// 正确</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_nTest &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_nTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CTest t;</span><br><span class="line">	t.<span class="built_in">foo</span>(<span class="number">5</span>);</span><br><span class="line">	t.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><ul>
<li>几乎什么都可以转，不能丢掉 <code>const</code>、<code>volatile</code> 特性；</li>
<li><strong>用于进行各种不同类型的转换</strong>；</li>
<li><strong>编译期处理，执行的是逐字节复制的操作</strong>；</li>
<li><strong>类似于显式强转，后果自负</strong>；</li>
</ul>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>运行时类型检查，在C++层面主要体现在<code>dynamic_cast</code>和<code>typeid</code></p>
<ul>
<li><code>dynamic_cast</code> ：动态类型转换</li>
<li><code>typeid</code>：<code>typeid</code> 运算符允许在运行时确定对象的类型，获取对象的实际类型</li>
</ul>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII 全称是「Resource Acquisition is Initialization」，直译过来是「<strong>资源获取即初始化</strong>」.</p>
<ul>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为 C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在 RAII 的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</li>
<li><strong>RAII 的核心思想是将资源或者状态与对象的生命周期绑定，通过 C++的语言机制，实现资源和状态的安全管理，智能指针是 RAII 最好的例子</strong>。</li>
</ul>
<h2 id="CPP11新特性"><a href="#CPP11新特性" class="headerlink" title="CPP11新特性"></a>CPP11新特性</h2><h3 id="nullptr常量"><a href="#nullptr常量" class="headerlink" title="nullptr常量"></a>nullptr常量</h3><ul>
<li>C++中 <code>NULL</code> 仅仅是 <code>#define NULL 0</code> 的一个宏定义，因此，有时候会产生歧义<ul>
<li>比如 <code>f(char*)</code> 和 <code>f(int)</code>，参数传 <code>NULL</code> 的话到底应该调用哪个；</li>
<li>事实上，在 VS 下测试这样的函数重载会优先调用 <code>f(int)</code>，但是 <code>f(char *)</code> 也是正确的，因此 C++引入 <code>nullptr</code> 来避免这个问题；</li>
</ul>
</li>
<li><code>nullptr</code> 是一个空指针，可以被转换成其他任意指针的类型；<h3 id="constexptr常量表达式"><a href="#constexptr常量表达式" class="headerlink" title="constexptr常量表达式"></a>constexptr常量表达式</h3></li>
<li>在编译过程中就能得到计算结果的表达式<h3 id="auto类型指示符"><a href="#auto类型指示符" class="headerlink" title="auto类型指示符"></a>auto类型指示符</h3></li>
</ul>
<ul>
<li><p>早在C++98标准中就存在了<code>auto</code>关键字，那时的<code>auto</code>用于声明变量为自动变量，自动变量意为拥有自动的生命期，这是多余的，因为就算不使用<code>auto</code>声明，变量依旧拥有自动的生命期：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span> ;  <span class="comment">//拥有自动生命期</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">20</span> ;<span class="comment">//拥有自动生命期</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">30</span> ;<span class="comment">//延长了生命期</span></span><br></pre></td></tr></table></figure></li>
<li><p>C++98 中的 <code>auto</code> 多余且极少使用，C++11 已经删除了这一用法，取而代之的是全新的 <code>auto</code> ：变量的自动类型推断，让编译器替我们去分析表达式所属的类型，直接推导；</p>
</li>
</ul>
<ul>
<li>**尤其是 STL 中 <code>map</code> 的迭代器这种很长的类型，适合用 <code>auto</code>**；</li>
</ul>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><ul>
<li><p>关键字<code>decltype</code>将变量的类型声明为表达式指定的类型</p>
</li>
<li><p><code>decltype</code>通常用于模板函数内部</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ft</span><span class="params">(T1 x, T2 y)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">decltype</span>(x+y) xpy = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>decltype</code>为了确定类型，编译器必须遍历一个核对表，假如有如下声明：<code>decltype(expression) var</code>；核对表简化版如下：</p>
<ul>
<li>如果<code>expression</code>是一个没有用括号括起的标识符，则<code>var</code>的类型与该标识符的类型相同，包括<code>const</code>等限定符；</li>
<li>如果<code>expression</code>是一个函数调用，则<code>var</code>的类型与函数的返回类型相同，实际上并不会调用函数，编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数；</li>
<li>如果<code>expression</code>声明为一个左值，则<code>var</code>为指向其类型的引用，前提是<code>expression</code>用括号括起来了；</li>
<li>如果前面都不满足，则<code>var</code>类型与<code>expression</code>类型相同。</li>
</ul>
</li>
</ul>
<h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><ul>
<li><strong>C++引入了委托构造的概念，这使得构造函数可以调用本类的另一个构造函数</strong>，从而达到简化代码的目的；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="keyword">float</span> value3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">float</span> f) : <span class="built_in">A</span>() &#123;</span><br><span class="line">        value3 = f;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(float)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> n) : <span class="built_in">A</span>(<span class="number">3.14f</span>) &#123;</span><br><span class="line">        value2 = n;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><ul>
<li>在传统 C++中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下，C++利用关键字 <code>using</code> 引入了继承构造的概念。派生类能够通过 <code>using</code> 语句声明要在子类中继承基类的全部构造函数。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="keyword">float</span> value3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">float</span> d) : <span class="built_in">A</span>() &#123;</span><br><span class="line">        value3 = d;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(float)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> n) : <span class="built_in">A</span>(<span class="number">3.14f</span>) &#123;</span><br><span class="line">        value2 = n;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A; 		<span class="comment">// 继承构造</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> n) : <span class="built_in">A</span>(n) &#123;&#125;	<span class="comment">// 显式声明A的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; b.value1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b.value2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b.value3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="override-保留字"><a href="#override-保留字" class="headerlink" title="override 保留字"></a>override 保留字</h3><ul>
<li><code>override</code>保留字表示当前函数重写了基类的虚函数。 </li>
<li>在函数比较多的情况下可以提示读者某个函数重写了基类虚函数，表示这个虚函数是从基类继承，不是派生类自己定义的。</li>
<li>强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><ul>
<li>禁用继承：C++11 中允许将类标记为 <code>final</code>，方法时直接在类名称后面使用关键字 <code>final</code>，如此，意味着继承该类会导致编译错误；</li>
<li>禁用重写：C++中还允许将方法标记为 <code>final</code>，这意味着无法再子类中重写该方法。这时 <code>final</code> 关键字至于方法参数列表后面；<h3 id="范围-for-语句"><a href="#范围-for-语句" class="headerlink" title="范围 for 语句"></a>范围 for 语句</h3></li>
</ul>
<ul>
<li>多与 <code>auto</code> 配合使用；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;somthing&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : str) <span class="comment">//对于str中的每个字符，i类型为char</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : str) <span class="comment">//对于若要改变每个字符的值，需要加引用</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定义双层vector"><a href="#定义双层vector" class="headerlink" title="定义双层vector"></a>定义双层vector</h3><ul>
<li><code>vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0))</code> 创建 m 行 n 列的二维数组，全部初始化为 0；</li>
</ul>
<h3 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h3><ul>
<li>定义<ul>
<li>仿函数（functor）又称之为<strong>函数对象</strong>（function object），<strong>其实就是重载了 <code>operator()</code> 操作符的 <code>struct</code> 或 <code>class</code>，是一个能行使函数功能的类</strong>；</li>
<li>它使一个类的使用看上去像一个函数，这个类就有了类似函数的行为，就是一个仿函数类；</li>
</ul>
</li>
<li>优点：仿函数由于是对象，因此可以保存函数状态，有非常大的优势；</li>
<li>缺点：需要显式定义一个类；</li>
</ul>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43265890/article/details/83218413">lambda表达式</a></h3><ul>
<li><strong>用于实现匿名函数，匿名函数只有函数体，没有函数名</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123;function body&#125;; </span><br><span class="line"><span class="comment">//2 省略mutable，表示const不可修改</span></span><br><span class="line">[capture list] (params list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;;  </span><br><span class="line"><span class="comment">//3 省略返回类型，按照函数体返回值决定返回类型</span></span><br><span class="line">[capture list] (params list) &#123;function body&#125;;	</span><br><span class="line"><span class="comment">//4 省略参数列表，无参函数</span></span><br><span class="line">[capture list] &#123;function body&#125;;		</span><br></pre></td></tr></table></figure></li>
<li>参数<ul>
<li><code>capture list</code> ：捕获外部变量列表；</li>
<li><code>params list</code> ：形参列表；</li>
<li><code>mutable</code> 指示符：用来说用是否可以修改捕获的变量，可选；</li>
<li><code>exception</code> ：异常设定；</li>
<li><code>return type</code> ：返回类型；</li>
<li><code>function body</code> ：函数体；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> a &lt; b&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>参数捕获方式<ul>
<li>值捕获 (传参)；</li>
<li>引用捕获（传引用）；</li>
<li>按值捕获所有变量（传 <code>=</code> 符号）；</li>
<li>按引用捕获所有变量（传 <code>&amp;</code> 符号）；</li>
</ul>
</li>
<li>匿名函数一般只有在定义的时候才能使用，为了保证后续还可以使用，可以使用<code>auto</code>类型推导  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123;<span class="keyword">return</span> a + b&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>嵌套 <code>lambda</code> 表达式  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="keyword">return</span> [n](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">return</span> n+x; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> c = <span class="built_in">f</span>(<span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>为什么要用 <code>lambda</code> 代替仿函数？</strong><br>在使用仿函数的时候不仅需要单独写一个类，还要重载运算符，这样的话就会导致需要写的代码非常多，而且还要起类名。而使用 <code>lambda</code> 可以简化这些操作，而且 <code>lambda</code> 还可以捕获所在作用域中的局部变量，以供其内部使用。</p>
<h3 id="函数对象包装器-function"><a href="#函数对象包装器-function" class="headerlink" title="函数对象包装器 function"></a>函数对象包装器 function</h3><p>为函数提供了一种容器（封装），<code>std::function</code> 就是 C++中用来代替 C 函数指针的。<code>function</code> 支持封装四种函数，分别为普通函数、匿名函数、类成员函数和函数对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = test;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 匿名函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = [](<span class="keyword">int</span> n) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 类的成员函数，注意，需要传递this指针</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(Test*, <span class="keyword">int</span>)&gt; f3 = &amp;Test::test;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">f3</span>(&amp;t, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(Test*, <span class="keyword">int</span>)&gt; f4 = &amp;Test::<span class="built_in"><span class="keyword">operator</span></span>();</span><br><span class="line">    <span class="built_in">f4</span>(&amp;t, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind绑定"><a href="#bind绑定" class="headerlink" title="bind绑定"></a>bind绑定</h3><p>将函数和函数参数绑定在一起，解决参数较多的函数多次调用时代码冗余的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">100</span>+b*<span class="number">10</span>+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(test, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f1</span>();   <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(test, std::placeholders::_1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">4</span>);  <span class="comment">// 423</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f3 = std::<span class="built_in">bind</span>(test, std::placeholders::_2, std::placeholders::_1, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 543</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bind</code> 有点像默认参数，但是默认参数顺序必须一致，而 <code>bind</code> 可以参数顺序不一致。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>左值和右值的区分标准在于<strong>能否获取地址</strong>。<br><strong>左值的定义表示的是可以获取地址的表达式</strong>（如变量名和解除引用的指针），它能出现在赋值语句的左边，对该表达式进行赋值。<br>左值引用使用 <code>&amp;</code> 符号，可以使用左值引用关联左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; j = *p; <span class="comment">// 合法，*p是解除引用的指针，是左值</span></span><br><span class="line"><span class="keyword">int</span>&amp; k = i;  <span class="comment">// 合法，i是变量，是左值</span></span><br><span class="line"><span class="keyword">int</span>&amp; i = <span class="number">0</span>;  <span class="comment">// 不合法，0是右值</span></span><br></pre></td></tr></table></figure>

<p><strong>右值表示无法获取地址的对象</strong>，有<strong>常量值、函数返回值、表达式</strong>等。无法获取地址，但不表示其不可改变。<br>而右值引用使用符号 <code>&amp;&amp;</code>，可以使用右值引用关联右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; r1 = <span class="number">13</span>;	<span class="comment">// 合法，13是常量，是右值</span></span><br><span class="line"><span class="keyword">double</span>&amp;&amp; r2 = std::<span class="built_in">sqrt</span>(<span class="number">2.0</span>); <span class="comment">// 合法，std::sqrt(2.0)是函数返回值，是右值</span></span><br></pre></td></tr></table></figure>

<p><code>const</code> 左值引用：<code>int &amp; i = 10;</code> 会报错，但是<code>const int &amp; i = 10;</code> 就不会报错，<code>const</code>修饰左值引用可以取得地址，但没法进行赋值。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><ul>
<li>转让所有权而非直接复制，从而避免了对原数据的拷贝；</li>
<li>提供一个移动构造函数和一个移动赋值运算符；</li>
<li>可使用 <code>static_cast&lt;&gt;</code> 将左值对象强制转换为右值，或者使用 <code>std::move()</code>；</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/running/">跑步</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">构造函数可以抛出异常吗，有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">初始化列表的异常怎么捕获？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">析构函数可以抛出异常吗，有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">析构函数如何处理异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">6.</span> <span class="toc-text">shared_ptr是线程安全的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-ptr"><span class="toc-number">7.1.</span> <span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">7.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">7.3.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E5%A2%9E%E5%87%8F%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">7.3.1.</span> <span class="toc-text">计数器增减的规则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">7.4.</span> <span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">自己实现一个智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">内存泄漏检测方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">如何避免内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">野指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.</span> <span class="toc-text">强制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast"><span class="toc-number">11.1.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">11.2.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast"><span class="toc-number">11.3.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">11.4.</span> <span class="toc-text">reinterpret_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">12.</span> <span class="toc-text">RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII"><span class="toc-number">13.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPP11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">14.</span> <span class="toc-text">CPP11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%E5%B8%B8%E9%87%8F"><span class="toc-number">14.1.</span> <span class="toc-text">nullptr常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexptr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.2.</span> <span class="toc-text">constexptr常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">auto类型指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">14.4.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">14.5.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">14.6.</span> <span class="toc-text">继承构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">14.7.</span> <span class="toc-text">override 保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.8.</span> <span class="toc-text">final 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4-for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">14.9.</span> <span class="toc-text">范围 for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%B1%82vector"><span class="toc-number">14.10.</span> <span class="toc-text">定义双层vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">14.11.</span> <span class="toc-text">仿函数（函数对象）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.12.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8-function"><span class="toc-number">14.13.</span> <span class="toc-text">函数对象包装器 function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind%E7%BB%91%E5%AE%9A"><span class="toc-number">14.14.</span> <span class="toc-text">bind绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">14.15.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">14.16.</span> <span class="toc-text">移动语义</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&text=C++智能指针和强制类型转换"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&is_video=false&description=C++智能指针和强制类型转换"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++智能指针和强制类型转换&body=Check out this article: http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&title=C++智能指针和强制类型转换"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&name=C++智能指针和强制类型转换&description=C++智能指针和强制类型转换知识点总结。"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/07/06/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/%E8%A1%A5%E5%85%85%E5%92%8CC++11%E6%96%B0%E7%89%B9%E6%80%A7/&t=C++智能指针和强制类型转换"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    ap0l1o
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
