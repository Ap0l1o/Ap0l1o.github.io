<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="STL源码知识点总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码知识点总结">
<meta property="og:url" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="ap0l1o">
<meta property="og:description" content="STL源码知识点总结。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-1-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-1-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-3.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-4.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-5.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-6.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-7.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-8.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-9.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-2-10.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-3.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-4.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-5.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-3-6.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-1.jpeg">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-3.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-4.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-5.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-6.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-7.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-8.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-13.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-12.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-11.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-9.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-10.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-4-1.jpeg">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-5-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-5-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-3.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-4.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-5.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-6.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-7.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-8.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-9.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-10.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-11.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-14.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-15.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-16.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-17.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-12.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-13.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-13.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-18.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-19.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-20.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-6-21.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-7-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-2.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-3.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-4.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-5.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-1.png">
<meta property="og:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-8-6.png">
<meta property="article:published_time" content="2023-07-25T05:22:00.000Z">
<meta property="article:modified_time" content="2023-07-25T05:23:09.714Z">
<meta property="article:author" content="ap0l1o">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/pic/stl-1-2.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/endless.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/endless-192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/endless-180.png">
        
      
    
    <!-- title -->
    <title>STL源码知识点总结</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="ap0l1o" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 RTL">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++Primer/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=STL源码知识点总结"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=STL源码知识点总结"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL源码知识点总结&body=Check out this article: http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=STL源码知识点总结&description=STL源码知识点总结。"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=STL源码知识点总结"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一.简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GNU%E6%BA%90%E4%BB%A3%E7%A0%81%E5%BC%80%E6%94%BE%E7%B2%BE%E7%A5%9E"><span class="toc-number">1.1.</span> <span class="toc-text">1.GNU源代码开放精神</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-STL%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">2.STL版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SGI-STL%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83"><span class="toc-number">1.3.</span> <span class="toc-text">3.SGI STL头文件分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-STL%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.STL六大部件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二.空间分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">1.空间分配器的标准接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SGI%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8std-allocator"><span class="toc-number">2.2.</span> <span class="toc-text">2.SGI标准的空间分配器std::allocator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SGI%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8std-alloc"><span class="toc-number">2.3.</span> <span class="toc-text">3.SGI特殊的空间分配器std::alloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 对象构造与析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%A4%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1）两级分配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8-malloc-alloc-template"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2）第一级分配器__malloc_alloc_template</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8-default-alloc-template"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3）第二级分配器__default_alloc_template</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 内存基本处理工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三.迭代器与traits编程技法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.迭代器相应类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.traits编程技法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 迭代器类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-std-iterator%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.std::iterator的保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SGI-STL%E7%9A%84-type-traits"><span class="toc-number">3.4.</span> <span class="toc-text">4.SGI STL的__type_traits</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">四.顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vector"><span class="toc-number">4.1.</span> <span class="toc-text">1.vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-vector%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 vector操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-list"><span class="toc-number">4.2.</span> <span class="toc-text">2.list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 list的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-list%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.5.</span> <span class="toc-text">2.5 list操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-deque"><span class="toc-number">4.3.</span> <span class="toc-text">3.deque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3 deque的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.4 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-deque%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.5 deque操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-stack"><span class="toc-number">4.4.</span> <span class="toc-text">4.stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-queue"><span class="toc-number">4.5.</span> <span class="toc-text">5.queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-heap"><span class="toc-number">4.6.</span> <span class="toc-text">6.heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-priority-queue"><span class="toc-number">4.7.</span> <span class="toc-text">7.priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-slist"><span class="toc-number">4.8.</span> <span class="toc-text">8.slist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-slist%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">4.8.1.</span> <span class="toc-text">8.1 slist的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-slist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.8.2.</span> <span class="toc-text">8.2 slist的迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">五.关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RB-tree"><span class="toc-number">5.1.</span> <span class="toc-text">1.RB-tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-RB-tree%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 RB-tree的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-RB-tree%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 RB-tree的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-RB-tree%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 RB-tree操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-set"><span class="toc-number">5.2.</span> <span class="toc-text">2.set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-map"><span class="toc-number">5.3.</span> <span class="toc-text">3.map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-multiset"><span class="toc-number">5.4.</span> <span class="toc-text">4.multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-multimap"><span class="toc-number">5.5.</span> <span class="toc-text">5.multimap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-hashtable"><span class="toc-number">5.6.</span> <span class="toc-text">6.hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.6.1.</span> <span class="toc-text">6.1 hashtable的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-hashtable%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text">6.2 hashtable的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-hashtable%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">6.3 hashtable操作的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-hash-functions"><span class="toc-number">5.6.4.</span> <span class="toc-text">6.4 hash functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-hash-set"><span class="toc-number">5.7.</span> <span class="toc-text">7.hash_set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-hash-map"><span class="toc-number">5.8.</span> <span class="toc-text">8.hash_map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-hash-multiset"><span class="toc-number">5.9.</span> <span class="toc-text">9.hash_multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-hash-multimap"><span class="toc-number">5.10.</span> <span class="toc-text">10.hash_multimap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六.算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.1.</span> <span class="toc-text">1.区间拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-copy"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-copy-backward"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 copy_backward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2.set相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-set-union"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 set_union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-set-intersection"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 set_intersection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-set-difference"><span class="toc-number">6.2.3.</span> <span class="toc-text">2.3 set_difference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-set-symmetric-difference"><span class="toc-number">6.2.4.</span> <span class="toc-text">2.4 set_symmetric_difference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%92%E5%BA%8Fsort"><span class="toc-number">6.3.</span> <span class="toc-text">3.排序sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">4.其它算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">七.仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1.仿函数的相应类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-unary-function"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 unary_function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-binary-function"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2 binary_function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">2.算术类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">3.关系运算类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4.逻辑运算类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%81%E5%90%8C%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8A%95%E5%B0%84"><span class="toc-number">7.5.</span> <span class="toc-text">5.证同，选择与投射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">八.适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1.容器适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">2.迭代器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-insert-iterators"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 insert iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89back-insert-iterator"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">1）back_insert_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89front-insert-iterator"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">2）front_insert_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89insert-iterator"><span class="toc-number">8.2.1.3.</span> <span class="toc-text">3）insert_iterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-reverse-iterators"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 reverse iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-iostream-iterators"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 iostream iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89istream-iterator"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">1）istream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89ostream-iterator"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">2）ostream_iterator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">3.函数适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-not1%E5%92%8Cnot2"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 not1和not2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89not1"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">1）not1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89not2"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">2）not2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-bind1st%E5%92%8Cbind2st"><span class="toc-number">8.3.2.</span> <span class="toc-text">3.2 bind1st和bind2st</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89bind1st"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">1）bind1st</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89bind2st"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">2）bind2st</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-compose1%E5%92%8Ccompose2"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.3 compose1和compose2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89compose1"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">1）compose1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89compose2"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">2）compose2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84ptr-fun"><span class="toc-number">8.3.4.</span> <span class="toc-text">3.4 用于函数指针的ptr_fun</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84mem-fun%E5%92%8Cmem-fun-ref"><span class="toc-number">8.3.5.</span> <span class="toc-text">3.5 用于成员函数指针的mem_fun和mem_fun_ref</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        STL源码知识点总结
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ap0l1o</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-07-25T05:22:00.000Z" class="dt-published" itemprop="datePublished">2023-07-25</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> › <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/CS%E5%9F%BA%E7%A1%80/">CS基础</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C-C/" rel="tag">C/C++</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><h2 id="1-GNU源代码开放精神"><a href="#1-GNU源代码开放精神" class="headerlink" title="1.GNU源代码开放精神"></a>1.GNU源代码开放精神</h2><p>全世界所有的STL实现版本，都源于Alexander Stepanov和Meng Lee完成的原始版本，这份原始版本有Hewlett-Packard Compant(惠普公司)拥有。每一个头文件都有一份声明，允许任何人任意运用、拷贝、修改、传播、贩卖这些代码，无需付费，唯一的条件是必须将声明置于使用者新开发的文件内</p>
<p>这份开放源代码的精神，一般统称为<strong>open source</strong></p>
<p><strong>GNU</strong>(音译为“革奴”)，代码<strong>G</strong>UN is <strong>N</strong>ot <strong>U</strong>nix。当时Unix是计算机界主流操作系统，由AT&amp;T Bell实验室的Ken Thompson和Dennis Ritchie创造。原本只是学术上的一个练习产品，AT&amp;T将它分享给许多研究人员。但是当所有研究与分享使这个产品越来越美好时，AT&amp;T开始思考是否应该追加投资，从中获利。于是开始要求大学校园内的相关研究人员签约，要求他们不得公开或透露UNIX源代码，并赞助Berkeley大学继续强化UNIX，导致后来发展出BSD(Berkeley Software Distribution)版本，以及更后来的FreeBSD、OpenBSD、NetBSD…，<strong>Stallman将AT&amp;T的这种行为视为思想禁锢，以及一种伟大传统的沦丧，于是进行了他的反奴役计划，称之为GNU:GUN is Not Unix</strong>，<strong>GNU计划中，早期最著名的软件包括Emacs和GCC，晚期最著名的是Linux操作系统</strong></p>
<p><strong>GNU以所谓的GPL(General Public License，广泛开放授权)来保护(或说控制)其成员</strong>：使用者可以自由阅读与修改GPL软件的源码，但如果使用者要传播借助GPL软件而完成的软件，必须也同意GPL规范。这种精神主要是强迫人们分享并回馈他们对GPL软件的改善。得之于人，舍于人</p>
<p><strong>Cygnus是一家商业公司</strong>，包装并出售自由软件基金会所构造的软件工具，并贩卖各种服务。他们协助芯片厂商调整GCC，在GPL的精神和规范下将GCC源代码的修正公布于世；他们提供GCC运作信息，提升其运行效率，并因此成为GCC技术领域的最佳咨询对象。Cygnus公司之于GCC，地位就像Red Hat公司之于Linux</p>
<h2 id="2-STL版本"><a href="#2-STL版本" class="headerlink" title="2.STL版本"></a>2.STL版本</h2><ul>
<li><strong>HP实现版本</strong>(HP STL)<ul>
<li><strong>所有STL实现版本的始祖</strong></li>
<li>运行任何人免费使用、拷贝、修改、传播、贩卖这份软件及其说明文件</li>
<li>唯一需要遵守的是：必须在所有文件中加上HP的版本声明和运用权限声明</li>
<li>这种授权不属于GNU GPL范畴，但属于open source范畴</li>
</ul>
</li>
<li><strong>P.J. Plauger实现版本</strong>(PJ STL)<ul>
<li>继承自HP版本，所有每一个头文件都有HP的版本说明</li>
<li>此外还加上P.J. Plauger的个人版权声明</li>
<li>不属于GNU GPL范畴，也不属于open source范畴</li>
<li><strong>被Visual C++采用</strong></li>
<li>符号命名不讲究、可读性较低</li>
</ul>
</li>
<li><strong>Rouge Wave实现版本</strong>(RW STL)<ul>
<li>继承自HP版本，所以每一个头文件都有HP的版本说明</li>
<li>此外还加上Rouge Wave的公司版权声明</li>
<li>不属于GNU GPL范畴，也不属于open source范畴</li>
<li><strong>被C++Builder采用</strong>（C++Builder对C++语言特性支持不错，连带给予了RW版本正面的影响）</li>
<li>可读性不错</li>
</ul>
</li>
<li><strong>STLport实现版本</strong><ul>
<li>以SGI STL为蓝本的高度可移植性实现版本</li>
</ul>
</li>
<li><strong>SGI STL实现版本</strong><ul>
<li>继承自HP版本，所以每一个头文件都有HP的版本说明</li>
<li>此外还加上SGI的公司版权声明</li>
<li>不属于GNU GPL范畴，但属于open source范畴</li>
<li><strong>被GCC采用</strong>（GCC对C++语言特性支持很好，连带给予了SGI STL正面影响）</li>
<li>可读性很高</li>
<li>为了具有高度移植性，考虑了不同编译器的不同编译能力</li>
</ul>
</li>
</ul>
<h2 id="3-SGI-STL头文件分布"><a href="#3-SGI-STL头文件分布" class="headerlink" title="3.SGI STL头文件分布"></a>3.SGI STL头文件分布</h2><ol>
<li><strong>C++标准规范下的C头文件</strong>：cstdio，csyflib，cstring，…</li>
<li><strong>C++标准程序库中不属于STL范畴者</strong>：stream，string，…</li>
<li>**STL标准头文件(无扩展名)**：vector，deque，list，map，…</li>
<li><strong>C++标准定案前，HP所规范的STL头文件</strong>：vector.h，deque.h，list.h，…</li>
<li><strong>SGI STL内部文件</strong>(<strong>STL真正实现与此</strong>)：stl_vector.h，stl_deque.h，stl_algo.h，…</li>
</ol>
<p>不同的编译器<strong>对C++语言的支持程度</strong>不尽相同。作为一个希望具备广泛移植能力的程序库，SGI STL准备了一个<strong>环境组态文件</strong><a href="tass-sgi-stl-2.91.57-source/stl_config.h">&lt;stl_config.h&gt;</a>，其中定义了许多常量，标示某些组态的成立与否，所有STL头文件都会直接或间接包含这个组态文件，并以条件式写法，让预处理器根据各个常量决定取舍哪一段程序代码，例如：</p>
<div align="center"> <img src="../pic/stl-1-2.png"/> </div>

<p><strong>组态测试程序</strong>：</p>
<ul>
<li><a href="stlbookcode/c1/1config.cpp">编译器对组态的支持</a></li>
<li><a href="stlbookcode/c1/1config3.cpp">组态3：__STL_STATIC_TEMPLATE_MEMBER_BUG</a></li>
<li><a href="stlbookcode/c1/1config5.cpp">组态5：__STL_CLASS_PARTIAL_SPECIALIZATION</a></li>
<li><a href="stlbookcode/c1/1config6.cpp">组态6：__STL_FUNCTION_TMPL_PARTIAL_ORDER</a></li>
<li>组态7：__STL_EXPLICIT_FUNCTION_TMPL_ARGS（整个SGI STL内都没有用到这一常量定义）</li>
<li><a href="stlbookcode/c1/1config8.cpp">组态8：__STL_MEMBER_TEMPLATES</a></li>
<li><a href="stlbookcode/c1/1config10.cpp">组态10：__STL_LIMITED_DEFAULT_TEMPLATES</a></li>
<li><a href="stlbookcode/c1/1config11.cpp">组态11：__STL_NON_TYPE_TMPL_PARAM_BUG</a></li>
<li><a href="stlbookcode/c1/1config-null-template-arguments.cpp">组态：__STL_EXPLICIT_FUNCTION_TMPL_ARGS</a>（<strong>bound friend templates</strong>）</li>
<li><a href="stlbookcode/c1/1config-template-exp-special.cpp">组态：__STL_TEMPLATE_NULL</a>（<strong>class template explicit specialization</strong>）</li>
</ul>
<h2 id="4-STL六大部件"><a href="#4-STL六大部件" class="headerlink" title="4.STL六大部件"></a>4.STL六大部件</h2><div align="center"> <img src="../pic/stl-1-1.png"/> </div>

<p>最重要的2个是<strong>容器</strong>与<strong>算法</strong></p>
<ul>
<li><strong>容器</strong>(container)</li>
<li><strong>分配器</strong>(Allocator)</li>
<li><strong>算法</strong>(Algorithms)</li>
<li><strong>迭代器</strong>(Iterrators)</li>
<li><strong>适配器</strong>(Adaptors)</li>
<li><strong>仿函数</strong>(Functors)</li>
</ul>
<br>

<h1 id="二-空间分配器"><a href="#二-空间分配器" class="headerlink" title="二.空间分配器"></a>二.空间分配器</h1><p>在运用层面，不需要关注空间分配器。但是在容器背后，空间分配器负责容器中元素空间的分配</p>
<p>不称作”内存分配器“，是因为分配的空间不一定是内存，可以是磁盘或其它辅助存储介质。可以实现一个获取磁盘空间的allocator。不过这里介绍的空间分配器获取的空间是内存</p>
<h2 id="1-空间分配器的标准接口"><a href="#1-空间分配器的标准接口" class="headerlink" title="1.空间分配器的标准接口"></a>1.空间分配器的标准接口</h2><p>通常，C++内存分配和释放的操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>...&#125;;</span><br><span class="line">Foo *pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>new内含2阶段操作</strong>：<ul>
<li>调用::operator new分配内存</li>
<li>调用构造函数构造对象</li>
</ul>
</li>
<li><strong>delete也含2阶段操作</strong>：<ul>
<li>调用析构函数析构对象</li>
<li>调用::operator delete释放内存</li>
</ul>
</li>
</ul>
<p>STL allocator将new和delete的2阶段操作进行了分离：</p>
<ul>
<li>内存分配：由alloc::allocate()负责</li>
<li>内存释放：由alloc::deallocate()负责</li>
<li>对象构造：由alloc::construct()负责</li>
<li>对象析构：由alloc::destroy负责</li>
</ul>
<p>根据<strong>STL的规范</strong>，以下是allocator的必要接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference_type</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个嵌套的class template，class rebind&lt;U&gt; 拥有唯一成员other,是一个typedef，代表allocator&lt;U&gt; </span></span><br><span class="line">allocator::rebind</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>()</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="keyword">const</span> allocator&amp;)  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> allocator::<span class="built_in">allocator</span>(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">allocator::~allocator</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;x</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span> <span class="keyword">const</span>   </span></span><br><span class="line"><span class="function">const_pointer <span class="title">allocator::address</span><span class="params">(const_reference x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//分配空间，足以容纳n个元素</span></span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//归还之前分配的空间</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//可分配的最大空间</span></span></span><br><span class="line"><span class="function">size_type <span class="title">allocator::max_size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//通过x，在p指向的地址构造一个对象。相当于new((void*)p) T(x)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocator::construct</span><span class="params">(pointer p,<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//析构地址p的对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只能有限度搭配PJ STL</strong>，因为PJ STL未完全遵循STL规格，其所供应的许多容器都需要一个非标准的空间分配器接口</li>
<li><strong>只能有限度地搭配RW STL</strong>，因为RW STL在很多容器身上运用了缓冲区，情况复杂很多</li>
<li><strong>完全无法应用于SGI STL</strong>，因为SGI STL在这个项目上根本就脱离了STL标准规格，使用一个专属的、拥有次层配置能力的、效率优越的特殊分配器。但提供了一个对其进行了封装的名为simple_alloc的分配器，符合部分标准</li>
</ul>
<h2 id="2-SGI标准的空间分配器std-allocator"><a href="#2-SGI标准的空间分配器std-allocator" class="headerlink" title="2.SGI标准的空间分配器std::allocator"></a>2.SGI标准的空间分配器std::allocator</h2><p>虽然SGI也定义有一个<strong>符合”部分“标准</strong>、名为<a href="tass-sgi-stl-2.91.57-source/defalloc.h">allocator</a>的分配器，但SGI自己从未用过它，也<strong>不建议我们使用</strong>。<strong>主要原因是效率不佳</strong>，只把C++的::operator new和::operator delete做一层薄薄的包装而已</p>
<h2 id="3-SGI特殊的空间分配器std-alloc"><a href="#3-SGI特殊的空间分配器std-alloc" class="headerlink" title="3.SGI特殊的空间分配器std::alloc"></a>3.SGI特殊的空间分配器std::alloc</h2><p>STL标准规定分配器定义于<code>&lt;memory&gt;</code>中，SGI<code>&lt;memory&gt;</code>内含两个文件，负责分离的2阶段操作</p>
<div align="center"> <img src="../pic/stl-2-1.png"/> </div>

<blockquote>
<p>真正在SGI STL中大显身手的分配器（即SGI特殊的空间分配器std::alloc）或为第一级分配器，或为第二级分配器</p>
</blockquote>
<h3 id="3-1-对象构造与析构"><a href="#3-1-对象构造与析构" class="headerlink" title="3.1 对象构造与析构"></a>3.1 对象构造与析构</h3><p><a href="tass-sgi-stl-2.91.57-source/stl_construct.h">&lt;stl_construct.h&gt;</a></p>
<div align="center"> <img src="../pic/stl-2-2.png"/> </div>

<blockquote>
<p>STL规定分配器必须拥有名为construct()和destroy()的两个成员函数，然而SGI特殊的空间分配器std::alloc并未遵守这一规则，所以实际上这部分属于STL allocator，但不属于std::alloc。换句话说，SGI特殊的空间分配器std::alloc不包含”3.1 对象构造与析构“，只包含”3.2 内存分配与释放“</p>
</blockquote>
<h3 id="3-2-内存分配与释放"><a href="#3-2-内存分配与释放" class="headerlink" title="3.2 内存分配与释放"></a>3.2 内存分配与释放</h3><p>SGI对内存分配与释放的设计哲学如下：</p>
<ul>
<li>向system heap申请空间</li>
<li>考虑多线程状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片问题（<strong>SGI设计了双层级分配器</strong>）</li>
</ul>
<p><strong>C++的内存分配基本操作是::operator new(),内存释放基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数。SGI正是以malloc和free()完成内存的分配与释放</strong></p>
<h4 id="1）两级分配器"><a href="#1）两级分配器" class="headerlink" title="1）两级分配器"></a>1）两级分配器</h4><p>考虑到小型区块所可能造成的内存碎片问题，SGI设计了双层级分配器：</p>
<div align="center"> <img src="../pic/stl-2-3.png"/> </div>

<ul>
<li>第一级分配器<ul>
<li>直接使用malloc()和free()</li>
</ul>
</li>
<li>第二级分配器<ul>
<li>当分配区块超过128bytes时，视为“足够大”，调用第一级分配器</li>
<li>当分配区块小于128bytes时，视为“过小”，为了降低额外负担，采用复杂的memory pool整理方式，不再求助于第一级分配器</li>
</ul>
</li>
</ul>
<p>无论alloc被定义为第一级或第二级分配器，SGI还为它再包装一个接口，使分配器的接口能够符合STL规格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in"><span class="keyword">sizeof</span></span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内部4个函数都是转调用分配器的成员函数。<strong>这个接口使分配器的分配单位从bytes转为个别元素的大小</strong></p>
<div align="center"> <img src="../pic/stl-2-4.png"/> </div>

<blockquote>
<p>上图中Alloc=alloc中的缺省alloc可以是第一级分配器，也可以是第二级分配器。SGI STL已经把它设为第二级分配器</p>
</blockquote>
<p>两级分配器都定义在头文件<a href="tass-sgi-stl-2.91.57-source/stl_alloc.h">&lt;stl_alloc.h&gt;</a>中</p>
<h4 id="2）第一级分配器-malloc-alloc-template"><a href="#2）第一级分配器-malloc-alloc-template" class="headerlink" title="2）第一级分配器__malloc_alloc_template"></a>2）第一级分配器__malloc_alloc_template</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般而言是线程安全，并且对于空间的运用比较高效</span></span><br><span class="line"><span class="comment">//无“template型别参数”，至于”非型别参数“inst，则完全没派上用场</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//oom：out of memory ，用来处理内存不足的情况</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);<span class="comment">//第一级分配器直接使用malloc()</span></span><br><span class="line">    <span class="comment">//以下无法满足需求时，改用oom_malloc()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//第一级分配器直接使用free()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);<span class="comment">//第一级分配器直接使用realloc()</span></span><br><span class="line">    <span class="comment">//以下无法满足需求时，改用oom_realloc()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下仿真C++的set_new_handler()。可以通过它指定自己的</span></span><br><span class="line"><span class="comment">//out-of-memory handler</span></span><br><span class="line"><span class="comment">//不能直接运用C++ new-handler机制，因为它并非使用::operator new来分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = f;</span><br><span class="line">    <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="comment">//初值为0，有待客户设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不断尝试释放、分配、再释放、再分配...</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*my_malloc_handler)(); <span class="comment">//调用处理例程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);     <span class="comment">//再次尝试分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不断尝试释放、分配、再释放、再分配...</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*my_malloc_handler)(); <span class="comment">//调用处理例程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n); <span class="comment">//再次尝试分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以malloc()、free()、realloc()等C函数执行实际的内存分配、释放、重分配操作</li>
<li>实现出类似C++ new-handler的机制（<strong>C++ new-handler机制是，可以要求系统在内存分配需求无法被满足时，调用一个你所指定的函数。换句话说，一旦::operator new无法完成任务，在丢出std::bad_alloc异常状态之前，会先调用由客户指定的处理例程，该处理例程通常即被称为new-handler</strong>），不能直接运用C++ new-handler机制，因为它并非使用::operator new来分配内存（<a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.md#3operator-new%E5%92%8Coperator-delete%E7%9A%84%E5%AE%9E%E7%8E%B0">operator new的实现</a>）</li>
</ul>
<h4 id="3）第二级分配器-default-alloc-template"><a href="#3）第二级分配器-default-alloc-template" class="headerlink" title="3）第二级分配器__default_alloc_template"></a>3）第二级分配器__default_alloc_template</h4><p>第二级分配器多了一些机制，避免太多小额区块造成内存的碎片，小额区块存在下列问题：</p>
<ul>
<li>产生内存碎片</li>
<li>额外负担。额外负担是一些区块信息，用以管理内存。区块越小，额外负担所占的比例就越大，越显浪费</li>
</ul>
<div align="center"> <img src="../pic/stl-2-5.png"/> </div>

<ul>
<li>当区块大于128bytes时，视为大区块<ul>
<li>转交第一级分配器处理</li>
</ul>
</li>
<li>当区块小于128bytes时，视为小额区块<ul>
<li>以<strong>内存池管理(也称为次层分配)<strong>：每次分配一大块内存，并维护对应的自由链表(free-list)，下次若载有相同大小的内存需求，就直接从free-list中拨出。如果客户释放小额区块，就由分配器回收到free-list中。</strong>维护有16个free-list</strong>，各自管理大小分别为8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128bytes的小额区块</li>
<li>SGI第二级分配器会主动将任何小额区块的内存需求量上调至8的倍数</li>
</ul>
</li>
</ul>
<p>free-list使用如下结构表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用union解决free-list带来的额外负担：维护链表所必须的指针而造成内存的另一种浪费</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span> <span class="comment">//系统视角</span></span><br><span class="line">    <span class="keyword">char</span> client_data[<span class="number">1</span>];        <span class="comment">//用户视角</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是free-list的实现技巧：</p>
<div align="center"> <img src="../pic/stl-2-6.png"/> </div>

<p>第二级分配器__default_alloc_template也定义在头文件<a href="tass-sgi-stl-2.91.57-source/stl_alloc.h">&lt;stl_alloc.h&gt;</a>中，以下为部分实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SUNPRO_CC</span></span><br><span class="line"><span class="comment">// breaks if we make these template class members:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>__ALIGN = <span class="number">8</span>&#125;;                           <span class="comment">//小型区块的上调边界</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>__MAX_BYTES = <span class="number">128</span>&#125;;                     <span class="comment">//小型区块的上限</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;    <span class="comment">//free-list的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二级分配器的定义</span></span><br><span class="line"><span class="comment">//无”template型别参数“，第一个参数用于多线程环境，第二参数完全没派上用场</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将bytes上调至8的倍数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//free-list</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//16个free-list</span></span><br><span class="line">    <span class="keyword">static</span> obj * <span class="keyword">volatile</span> free_list[__NFREELISTS]; </span><br><span class="line">    <span class="comment">//根据区块大小，决定使用第n号free-list。n从0算起</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个大小为n的对象，并可能加入大小为n的其它区块到free-list</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="comment">//分配一大块空间，可容纳nobjs个大小为”size“的区块</span></span><br><span class="line">    <span class="comment">//如果分配nobjs个区块有所不便，nobjs可能会降低</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chunk allocation state.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *start_free;  <span class="comment">//内存池起始位置。只在chunk_alloc()中变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *end_free;    <span class="comment">//内存池结束位置。只在chunk_alloc()中变化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123; <span class="comment">/*详述于后*/</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span>&#123; <span class="comment">/*详述于后*/</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下是static data member的定义与初始值*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * <span class="keyword">volatile</span></span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS] = </span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>空间分配函数<a href="tass-sgi-stl-2.91.57-source/stl_alloc.h#L403">allocate()</a><ul>
<li>若区块大于128bytes，就调用第一级分配器</li>
<li>若区块小于128bytes，检查对应的free-list<ul>
<li>若free-list之内有可用的区块，则直接使用</li>
<li>若free-list之内没有可用区块，将区块大小调至8倍数边界，调用refill()，准备为free-list重新填充空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<div align="center"> <img src="../pic/stl-2-7.png"/> </div>

<ul>
<li>空间释放函数<a href="tass-sgi-stl-2.91.57-source/stl_alloc.h#L433">deallocate()</a><ul>
<li>若区块大于128bytes，就调用第一级分配器</li>
<li>若区块小于128bytes，找出对应的free-list，将区块回收</li>
</ul>
</li>
</ul>
<div align="center"> <img src="../pic/stl-2-8.png"/> </div>

<ul>
<li><p>重新填充free-list的函数<a href="tass-sgi-stl-2.91.57-source/stl_alloc.h#L537">refill()</a></p>
<ul>
<li>若free-list中没有可用区块时，会调用chunk_alloc<strong>从内存池</strong>中申请空间重新填充free-list。缺省申请20个新节点(新区块)，如果内存池空间不足，获得的节点数可能小于20</li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_alloc.h#L465">chunk_alloc()</a>函数从内存池申请空间，根据end_free-start_free判断内存池中剩余的空间</p>
<ul>
<li>如果剩余空间充足<ul>
<li>直接调出20个区块返回给free-list</li>
</ul>
</li>
<li>如果剩余空间不足以提供20个区块，但足够供应至少1个区块<ul>
<li>拨出这不足20个区块的空间</li>
</ul>
</li>
<li>如果剩余空间连一个区块都无法供应<ul>
<li>利用malloc()从heap中分配内存（大小为需求量的2倍，加上一个随着分配次数增加而越来越大的附加量），为内存池注入新的可用空间（<strong>详细例子见下图</strong>）</li>
<li>如果malloc()获取失败，chunk_alloc()就四处寻找有无”尚有未用且区块足够大“的free-list。找到了就挖出一块交出</li>
<li>如果上一步仍未成功，那么就调用第一级分配器，第一级分配器有out-of-memory处理机制，或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则抛出bad_alloc异常</li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-2-9.png"/> </div>

<p>  上图中，一开始就调用chunk_alloc(32,20)，于是malloc()分配40个32bytes区块，其中第1个交出，另19个交给free-list[3]维护，余20个留给内存池；接下来客户调用chunk_alloc(64,20)，此时free_list[7]空空如也，必须向内存池申请。内存池只能供应(32*20)/64=10个64bytes区块，就把这10个区块返回，第1个交给客户，余9个由free_list[7]维护。此时内存池全空。接下来再调用chunk_alloc(96,20)，此时free-list[11]空空如也，必须向内存池申请。而内存池此时也为空，于是以malloc()分配40+n(附加量)个96bytes区块，其中第1个交出，另19个交给free-list[11]维护，余20+n(附加量)个区块留给内存池…</p>
</li>
</ul>
<h3 id="3-3-内存基本处理工具"><a href="#3-3-内存基本处理工具" class="headerlink" title="3.3 内存基本处理工具"></a>3.3 内存基本处理工具</h3><p>STL定义了5个全局函数，作用于未初始化空间上，有助于容器的实现：</p>
<ul>
<li>作用于单个对象（见<a href="#31-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84">3.1 对象构造与析构</a>，SGI STL定义在头文件<a href="tass-sgi-stl-2.91.57-source/stl_construct.h">&lt;stl_construct.h&gt;</a>中）<ul>
<li>construct()函数（构造单个对象）</li>
<li>destroy()函数（析构单个对象）</li>
</ul>
</li>
<li>作用于容器的区间（本节，SGI STL定义在头文件<a href="tass-sgi-stl-2.91.57-source/stl_uninitialized.h">&lt;stl_uninitialized.h&gt;</a>中，是高层copy()、fill()、fill_n()的底层函数）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L76">uninitialized_copy()</a>函数</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L171">uninitialized_fill()</a>函数</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L218">uninitialized_fill_n()</a>函数</li>
</ul>
</li>
</ul>
<p>容器的全区间构造函数通常分2步：</p>
<ol>
<li>分配内存区块，足以包含范围内的所有元素</li>
<li>调用上述3个函数在全区间范围内构造对象（因此，这3个函数使我们能够将内存的分配与对象的构造行为分离；并且3个函数都具有”commit or rollback“语意，要么所有对象都构造成功，要么一个都没有构造）</li>
</ol>
<div align="center"> <img src="../pic/stl-2-10.png"/> </div>

<br>

<h1 id="三-迭代器与traits编程技法"><a href="#三-迭代器与traits编程技法" class="headerlink" title="三.迭代器与traits编程技法"></a>三.迭代器与traits编程技法</h1><h2 id="1-迭代器相应类型"><a href="#1-迭代器相应类型" class="headerlink" title="1.迭代器相应类型"></a>1.迭代器相应类型</h2><p>在算法中运用迭代器时，很可能会用到其相应类型。所谓相应类型，迭代器所指之物的类型便是其中之一，算法可以在函数体中使用迭代器所指之物的类型来定义变量，也可能将迭代器所指之物的类型作为算法的返回值：</p>
<div align="center"> <img src="../pic/stl-3-1.png"/> </div>

<ul>
<li><strong>在函数体中使用迭代器所指之物的类型</strong><ul>
<li>C++支持sizeof()，但并未支持typeof()。即便动用RTTI性质中的typeid()，获得的也只是类型名称，不能拿来做变量声明</li>
<li>这里利用函数模板的参数推导机制解决。算法func()作为对外接口，算法的所有逻辑另外封装在一个实现函数func_impl()中，由于它是一个函数模板，一旦被调用，编译器就会自动进行参数推导，导出类型T</li>
</ul>
</li>
<li><strong>迭代器所指之物的类型作为算法的返回类型</strong><ul>
<li>函数模板的参数推导机制推导的是参数，无法推导函数的返回类型</li>
<li>这里使用嵌套类型声明解决。但是，对于类类型的迭代器，可以正常工作，但是<strong>非类类型的原生指针无法处理</strong></li>
</ul>
</li>
</ul>
<p>通过上图，可以了解到在算法中对迭代器相应类型的需求。除了迭代器所指之物的类型(value type)，迭代器相应类型还包括另外4种，在traits编程技法中将会介绍，并且会提到如何使用traits来解决上面的问题（这也是STL中实际使用的方法）</p>
<h2 id="2-traits编程技法"><a href="#2-traits编程技法" class="headerlink" title="2.traits编程技法"></a>2.traits编程技法</h2><p>上一节所使用的方法，在value type作为返回类型时，无法处理非类类型的原生指针。下图使用traits来解决，使用了模板偏特化来处理非类类型的原生指针：</p>
<div align="center"> <img src="../pic/stl-3-2.png"/> </div>

<br>

<p>现在，不论面对的是迭代器MyIter，或是原生指针int*或const int*，都可以通过traits取出正确的value type</p>
<div align="center"> <img src="../pic/stl-3-3.png"/> </div>

<blockquote>
<p>当然，若要“特性萃取机”traits能够有效运作，每一个迭代器必须遵循约定，自行以内嵌类型定义的方式定义出相应类型。这是一个约定，谁不遵守这个约定，谁就不能兼容于STL这个大家庭</p>
</blockquote>
<p><strong>根据经验，最常用到的迭代器相应类型有5种</strong>：</p>
<ol>
<li><p><strong>value type</strong>：指迭代器所指对象的类型</p>
</li>
<li><p><strong>difference type</strong>：用以表示两个迭代器之间的距离</p>
</li>
<li><p><strong>pointer</strong>：如果value type是T，那么pointer就是指向T的指针</p>
</li>
<li><p><strong>reference</strong>：如果value type是T，那么reference就是T的引用</p>
</li>
<li><p><strong>iterator category</strong>：迭代器的类型（<a href="#21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B">详见</a>）</p>
 <div align="center"> <img src="../pic/stl-3-4.png"/> </div></li>
</ol>
<p>如果希望开发的容器能与STL相容，一定要为容器定义这5种相应类型。“特性萃取机”traits会很忠实地将特性萃取出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category   iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type          value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type     difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer             pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference           reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator_traits必须针对传入的类型为pointer及pointer-to-const者设计偏特化版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以C++内建的ptrdiff_t（定义于&lt;cstddef&gt;头文件）作为原生指针的difference type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt;&#123;</span><br><span class="line">    <span class="comment">//原生指针是一种Random Access Iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag   iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                            value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                           pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                           reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生pointer-to-const的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt;&#123;</span><br><span class="line">    <span class="comment">//原生指针是一种Random Access Iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag   iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                            value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T*                     pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;                     reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>STL提供以下函数，简化迭代器相应类型的萃取：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数可以很方便地萃取category</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数可以很方便地萃取distance type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数可以很方便地萃取value type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-迭代器类型"><a href="#2-1-迭代器类型" class="headerlink" title="2.1 迭代器类型"></a>2.1 迭代器类型</h3><p>设计算法时，如果可能，尽量针对某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一种定义，这样才能在不同情况下提供最大效率，如下图的advanced()函数，用于移动迭代器：</p>
<div align="center"> <img src="../pic/stl-3-5.png"/> </div>

<p>在上图中，每个__advance()的最后一个参数都只声明类型，并未指定参数名称，因为它纯粹只是用来激活重载机制，函数之中根本不使用该参数。如果加上参数名称也没有错，但是没必要</p>
<p>将advance()中的iterator_category(i)展开得到iterator_traits&lt;InputIterator&gt;::iterator_category()，这会产生一个临时对象，其类型隶属于几种迭代器中的一种。然后，根据这个类型，编译器才决定调用哪一个__advance()重载函数</p>
<p><strong>上图以class来定义迭代器的各种分类标签，有下列好处</strong>：</p>
<ul>
<li>可以促成重载机制的成功运作</li>
<li><strong>通过继承，可以不必再写“单纯只做传递调用”的函数（如__advance()的Forward Iterator版只是单纯的调用Input Iterator版，因此可以省略）,可以通过<a href="stlbookcode/c3/3tag-test.cpp">这个例子</a>来模拟证实</strong></li>
</ul>
<h2 id="3-std-iterator的保证"><a href="#3-std-iterator的保证" class="headerlink" title="3.std::iterator的保证"></a>3.std::iterator的保证</h2><p>为了符合规范，任何迭代器都应该提供5个内嵌相应类型，以便于traits萃取，否则便是自别于整个STL架构，可能无法与其它STL组件顺利搭配。然而，写代码难免会有遗漏。因此，STL提供了一个iterators class如下，如果每个新设计的迭代器都继承自它，就可保证符合STL所需的规范；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Distance</span> =</span> <span class="keyword">ptrdiff_t</span>,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> =</span> T*,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Reference</span> =</span> T&amp;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Category    iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer     pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator class不含任何成员，存粹只是类型定义，所以继承它不会导致任何额外负担。由于后3个参数皆有默认值，故新的迭代器只需提供前2个参数即可。以下为一个继承示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListIter</span> :</span> <span class="keyword">public</span> std::iterator&lt;std::forword_iterator_tag, Item&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-SGI-STL的-type-traits"><a href="#4-SGI-STL的-type-traits" class="headerlink" title="4.SGI STL的__type_traits"></a>4.SGI STL的__type_traits</h2><p>SGI将STL的traits进一步扩大到迭代器以外，于是有了所谓的__type_traits，它属于SGI STL，不属于STL标准规范</p>
<ul>
<li>iterator_traits：负责萃取迭代器的特性</li>
<li>__type_traits：负责萃取类型的特性，包括：<ul>
<li>该类型是否具备non-trivial default ctor</li>
<li>该类型是否具备non-trivial copy ctor</li>
<li>该类型是否具备non-trivial assignment operator</li>
<li>该类型是否具备non-trivial dtor</li>
</ul>
</li>
</ul>
<p>通过使用__type_traits，在对某个类型进行构造、析构、拷贝、赋值等操作时，就可以采用最有效率的措施。这对于大规模而操作频繁的容器，有着显著的效率提升</p>
<p>萃取类型的特性时，我们希望得到一个”真“或”假“（以便决定采取什么策略），但其结果不应该只是个bool值，应该是个有着真/假性质的”对象”，因为我们希望利用响应的结果来进行参数推导，而编译器只有面对class object形式的参数，才会做参数推导，所以萃取类型的特性时，返回__true_type或__false_type：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>模板类__type_traits的泛化与特化/偏特化见下图：</p>
<div align="center"> <img src="../pic/stl-3-6.png"/> </div>

<br>

<h1 id="四-顺序容器"><a href="#四-顺序容器" class="headerlink" title="四.顺序容器"></a>四.顺序容器</h1><div align="center"> <img src="../pic/stl-4-1.jpeg"/> </div>

<p>上图中的“衍生”并非“派生”，而是内含关系。例如heap内含一个vector，priority-queue内含一个heap，stack和queue都含一个deque，set/map/multiset/multimap都内含一个RB-tree，has_x都内含一个hashtable</p>
<h2 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h2><p>array是静态空间，一旦配置了就不能改变；vector与array非常相似，但是vector是动态空间，随着元素的加入，内部机制会自动扩充以容纳新元素</p>
<p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L12">vector的定义</a></p>
<div align="center"> <img src="../pic/stl-4-2.png"/> </div>

<h3 id="1-1-迭代器"><a href="#1-1-迭代器" class="headerlink" title="1.1 迭代器"></a>1.1 迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素类型为何，普通指针都可以作为vector的迭代器而满足所有必要条件，因为vector迭代器所需要的操作行为，如operator*，operator-&gt;，operator++，operator–，operator+，operator-，operator+=，operator-=，普通指针天生就具备。vector支持随机存取，而普通指针正有着这样的能力。所以，vector提供的是Random Access Iterators：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T               value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*     iterator;   <span class="comment">//vector的迭代器时普通指针</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-分配器"><a href="#1-2-分配器" class="headerlink" title="1.2 分配器"></a>1.2 分配器</h3><p>vector缺省使用alloc作为空间分配器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，data_allocator::allocate(n)表示分配n个元素空间</p>
<h3 id="1-3-vector操作的实现"><a href="#1-3-vector操作的实现" class="headerlink" title="1.3 vector操作的实现"></a>1.3 vector操作的实现</h3><p>常见的vector操作包括：</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L98">vector(size_type n,const T &amp;value)</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L98">fill_initialize(size_type n,const T &amp;value)</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L213">allocate_and_fill(size_type n, const T&amp; x)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L144">push_back(const T &amp;x)</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L323">insert_aux(iterator position,const T &amp;x)</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L186">pop_back()</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L197">erase(iterator first, iterator last)</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L190">erase(iterator position)</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_vector.h#L361">insert(iterator position, size_type n, const T&amp; x)</a></li>
</ul>
<p><strong>插入操作可能造成vector的3个指针重新配置，导致原有的迭代器全部失效</strong></p>
<h2 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L124">list的定义</a></p>
<h3 id="2-1-节点"><a href="#2-1-节点" class="headerlink" title="2.1 节点"></a>2.1 节点</h3><div align="center"> <img src="../pic/stl-4-3.png"/> </div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;  <span class="comment">//类型为void*</span></span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-迭代器"><a href="#2-2-迭代器" class="headerlink" title="2.2 迭代器"></a>2.2 迭代器</h3><p>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在</p>
<p>list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。list中，迭代器与节点的关系见下图：</p>
<div align="center"> <img src="../pic/stl-4-4.png"/> </div>

<p>由于STL list是一个双向链表，迭代器必须具备前移、后移的能力，所以list提供的是Bidirectional Iterators</p>
<p><strong>list的插入和接合操作都不会造成原有的list迭代器失效，对于删除操作，也只有”指向被删除元素“的那个迭代器失效，其它迭代器不受任何影响</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;<span class="comment">//节点指针类型link_type</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  link_type node;<span class="comment">//迭代器内部的指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">  __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">  __list_iterator() &#123;&#125;</span><br><span class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">  <span class="comment">//对迭代器取值，取的是节点的数据值</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  <span class="comment">//以下是迭代器的成员存取运算子的标准做法</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对迭代器累加1，就是前进一个节点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    node = (link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对迭代器递减1，就是后退一个节点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    node = (link_type)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-list的数据结构"><a href="#2-3-list的数据结构" class="headerlink" title="2.3 list的数据结构"></a>2.3 list的数据结构</h3><p>SGI list不仅是一个双向链表，还是一个环状双向链表。所以它只需要一个指针，便可完整表现整个链表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node; <span class="comment">//只要一个指针，便可表示整个环状双向链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    size_type result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="../pic/stl-4-5.png"/> </div>

<h3 id="2-4-分配器"><a href="#2-4-分配器" class="headerlink" title="2.4 分配器"></a>2.4 分配器</h3><p>list缺省使用alloc作为空间分配器，并据此另外定义了一个list_node_allocator，为的是更方便以节点大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，list_node_allocator::allocate(n)表示分配n个节点空间</p>
<h3 id="2-5-list操作的实现"><a href="#2-5-list操作的实现" class="headerlink" title="2.5 list操作的实现"></a>2.5 list操作的实现</h3><ul>
<li>节点操作<ul>
<li>分配一个节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L156">get_node</a></li>
<li>释放一个节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L157">put_node</a></li>
<li>生成（分配并构造）一个节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L159">create_node</a></li>
<li>销毁（析构并释放）一个节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L167">destroy_node</a></li>
<li>节点插入：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L269">push_back</a>和<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L268">push_front</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_list.h#L243">insert</a></li>
</ul>
</li>
<li>节点移除：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L270">erase</a>,<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L283">pop_front</a>和<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L284">pop_back</a></li>
<li>移除某一数值的所有节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L468">remove</a></li>
<li>移除数值相同的连续节点：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L480">unique</a></li>
</ul>
</li>
<li>链表操作<ul>
<li>创建一个空链表：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L217">list()</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_list.h#L173">empty_initialize</a></li>
</ul>
</li>
<li>链表清空：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L438">clear</a></li>
</ul>
</li>
<li>链表拼接：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L328">splice</a><ul>
<li>将[first,last)内的元素移动到position之前：<a href="tass-sgi-stl-2.91.57-source/stl_list.h#L315">transfer</a>（[first,last)区间可以在同一个list之中，transfer并非公开接口，公开的是splice）</li>
</ul>
  <div align="center"> <img src="../pic/stl-4-6.png"/> </div></li>
</ul>
<h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3.deque"></a>3.deque</h2><p>deque是一种双向开口的连续线性空间</p>
<p>deque和vector最大的差异：</p>
<ol>
<li>deque允许于常数时间内对起头端进行元素的插入或移除操作</li>
<li>deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来（deque没有必要提供所谓的空间保留功能）</li>
</ol>
<h3 id="3-1-迭代器"><a href="#3-1-迭代器" class="headerlink" title="3.1 迭代器"></a>3.1 迭代器</h3><p>deque是分段连续空间。维持其”整体连续“假象的任务，落在了迭代器的operator++和operator–两个运算子身上</p>
<p>deque迭代器必须能够指出分段连续空间（即缓冲区）在哪；必须能够判断自己是否已经处于其所在缓冲器的边缘。为了能够正确跳跃，迭代器必须随时掌握中控器map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span>   <span class="comment">//未继承std::iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in"><span class="keyword">sizeof</span></span>(T)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为继承std::iterator，所以必须自行撰写5个必要的迭代器相应类型</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;                                 <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;                                  <span class="comment">// (3)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;                                <span class="comment">// (4)</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;                    <span class="comment">// (5)</span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保持与容器的联结</span></span><br><span class="line">  T* cur;           <span class="comment">//此迭代器所指缓冲区中的当前元素</span></span><br><span class="line">  T* first;         <span class="comment">//此迭代器所指缓冲区的头</span></span><br><span class="line">  T* last;          <span class="comment">//此迭代器所指缓冲区的尾(含备用空间)</span></span><br><span class="line">  map_pointer node; <span class="comment">//指向中控器map</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器操作：</p>
<ul>
<li>更新迭代器指向的缓冲区：set_node</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L130">解引用*</a> </li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L132">成员选择-&gt;</a></li>
<li><a href="135">迭代器相减-</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L140">前置++</a>和<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L148">后置++</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L154">前置–</a>和<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L162">后置–</a></li>
<li>复合赋值<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L168">+=</a>和<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L187">-=</a></li>
<li>迭代器<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L182">+n</a>和<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L189">-n</a></li>
<li>随机存取<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L194">[]</a></li>
<li>相等判断<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L196">==</a>，<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L197">!=</a>和<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L198">&lt;</a></li>
</ul>
<h3 id="3-3-deque的数据结构"><a href="#3-3-deque的数据结构" class="headerlink" title="3.3 deque的数据结构"></a>3.3 deque的数据结构</h3><p>deque采用一块所谓的map作为**主控(中控器)**。这里所谓的map是指一小块连续空间，其中每个元素都是一个指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL允许我们指定缓冲区大小，默认值0表示使用512bytes缓冲区</p>
<div align="center"> <img src="../pic/stl-4-7.png"/> </div>

<p>deque除了维护一个指向map的指针外，也维护start，finish两个迭代器。分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外，也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">temlate &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc,<span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class deque&#123;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//Basic types</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;.T*,BufSiz&gt; iterator;  <span class="comment">//迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">//Internal typedefs</span></span><br><span class="line">    <span class="comment">//元素的指针的指针</span></span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">//Data members</span></span><br><span class="line">    iterator start;         <span class="comment">//第一个节点的迭代器</span></span><br><span class="line">    iterator finish;        <span class="comment">//最后一个节点的迭代器</span></span><br><span class="line"></span><br><span class="line">    map_pointer map;        <span class="comment">//指向map，map是块连续空间</span></span><br><span class="line">                            <span class="comment">//其每个元素都是个指针，指向一个节点(缓冲区)</span></span><br><span class="line">    size_type map_size;     <span class="comment">//map的大小，即内有多少个指针</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>deque的中控器、缓冲区、迭代器的关系如下图：</p>
<div align="center"> <img src="../pic/stl-4-8.png"/> </div>

<h3 id="3-4-分配器"><a href="#3-4-分配器" class="headerlink" title="3.4 分配器"></a>3.4 分配器</h3><p>deque自行定义了2个专属的空间配置器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//专属的空间分配器，每次分配一个元素大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">    <span class="comment">//专属的空间分配器，每次分配一个指针大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;pointer,Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-deque操作的实现"><a href="#3-5-deque操作的实现" class="headerlink" title="3.5 deque操作的实现"></a>3.5 deque操作的实现</h3><ul>
<li>deque构造与初始化：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L360">deque</a><ul>
<li>元素初始化<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L847">fill_initialize</a><ul>
<li>空间分配与成员设定<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L797">create_map_and_nodes</a></li>
</ul>
</li>
</ul>
</li>
<li>插入操作：<ul>
<li>在队列末尾插入：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L439">push_back</a><ul>
<li>最后缓冲区只有1个可用空间时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L898">push_back_aux</a><ul>
<li>map不足时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L632">reserve_map_at_back</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L1289">reallocate_map</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在队列首部插入：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L448">push_front</a><ul>
<li>第一个缓冲区没有可用空间时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L912">push_front_aux</a><ul>
<li>map不足时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L639">reserve_map_at_front</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L1289">reallocate_map</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>指定位置插入一个元素：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L447">insert</a><ul>
<li>在首部插入：push_front</li>
<li>在尾部插入：push_back</li>
<li>在中间插入：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L994">insert_aux</a></li>
</ul>
</li>
</ul>
</li>
<li>弹出操作：<ul>
<li>弹出队列末尾元素：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L457">pop_back</a><ul>
<li>最后缓冲区没有元素时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L933">pop_back_aux</a></li>
</ul>
</li>
<li>弹出队列首部元素：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L466">pop_front</a><ul>
<li>第一个缓冲区仅有一个元素时：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L945">pop_front_aux</a></li>
</ul>
</li>
</ul>
</li>
<li>清除所有元素：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L774">clear</a></li>
<li>清除某个区间的元素：<a href="tass-sgi-stl-2.91.57-source/stl_deque.h#L743">erase</a></li>
</ul>
<h2 id="4-stack"><a href="#4-stack" class="headerlink" title="4.stack"></a>4.stack</h2><p>具有”修改某物接口，形成另一种风貌“的性质者，称为适配器。因此，STL stack往往不被归类为容器，而被归类为容器适配器</p>
<p>SGI STL以deque作为缺省情况下的stack底部结构，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">  <span class="comment">//以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> stack&amp;, <span class="keyword">const</span> stack&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> stack&amp;, <span class="keyword">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//以下完全利用Sequence c的操作，完成stack的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="comment">//deque是两头可进出，stack是后进后出</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有stack顶端的元素有机会被外界取用，stack不提供遍历功能，也<strong>不提供迭代器</strong></p>
<p><strong>指定其它容器作为stack的底层容器的方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>,list&lt;<span class="keyword">int</span>&gt; &gt; istack;</span><br></pre></td></tr></table></figure>

<h2 id="5-queue"><a href="#5-queue" class="headerlink" title="5.queue"></a>5.queue</h2><p>queue（队列）是一种先进先出的数据结构，尾端插入，首部移出</p>
<p>SGI STL以deque作为缺省情况下的queue底部结构，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">  <span class="comment">//以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//以下完全利用Sequence c的操作，完成stack的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="comment">//deque是两头可进出，queue是尾端进、首部出</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有首部元素才有机会被外界取用，queue不提供遍历功能，也<strong>不提供迭代器</strong></p>
<p><strong>指定其它容器作为queue的底层容器的方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>,list&lt;<span class="keyword">int</span>&gt; &gt; iqueue;</span><br></pre></td></tr></table></figure>

<h2 id="6-heap"><a href="#6-heap" class="headerlink" title="6.heap"></a>6.heap</h2><p>heap并不归属与STL容器组件，它是个幕后英雄，扮演priority queue的助手</p>
<p>heap是一颗完全二叉树，完全二叉树使用数组实现，因此使用一个vector作为heap的结构，然后通过一组xxx_heap算法，使其符合heap的性质</p>
<ul>
<li><p>上溯（在此之前应该push_back）：<a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L60">push_heap</a></p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L53">__push_heap_aux</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L40">__push_heap</a></li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-4-13.png"/> </div></li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L124">pop_heap</a>（在此之后应该pop_back）</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L118">__pop_heap_aux</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L110">__pop_heap</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L91">__adjust_heap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-4-12.png"/> </div></li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L209">sort_heap</a></p>
  <div align="center"> <img src="../pic/stl-4-11.png"/> </div></li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L184">make_heap</a></p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_heap.h#L189">__make_heap</a></li>
</ul>
</li>
</ul>
<h2 id="7-priority-queue"><a href="#7-priority-queue" class="headerlink" title="7.priority_queue"></a>7.priority_queue</h2><p>顾名思义，priority_queue就是具有优先级的queue，允许首部移出，尾端插入。缺省情况下利用一个max-heap完成，因此首部元素优先级最高</p>
<p>以下为SGI STL中priority_queue的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> vector&lt;T&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;       <span class="comment">//底层容器</span></span><br><span class="line">  Compare comp;     <span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> Compare&amp; x)</span> :  c(), comp(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以下用到的make_heap()、push_heap()、pop_heap()都是泛型算法</span></span><br><span class="line">  <span class="comment">//构造一个priority queue，首先根据传入的迭代器区间初始化底层容器c，然后调用</span></span><br><span class="line">  <span class="comment">//make_heap()使用底层容器建堆</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="keyword">const</span> Compare&amp; x)</span><br><span class="line">    : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) </span><br><span class="line">    : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先利用底层容器的push_back()将新元素推入末端，再重排heap</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.<span class="built_in">push_back</span>(x); </span><br><span class="line">      <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从heap内取出一个元素。但不是真正弹出，而是重排heap，然后以底层容器的pop_back()</span></span><br><span class="line">    <span class="comment">//取得被弹出的元素</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">      c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和queue一样，priority queue只有首部的元素有机会被外界取用。不提供遍历功能，也<strong>不提供迭代器</strong></p>
<h2 id="8-slist"><a href="#8-slist" class="headerlink" title="8.slist"></a>8.slist</h2><p>slist<strong>并不在标准规格之内</strong>，由SGI STL提供，slist和list不同的是slist是单链表</p>
<p>单链表每个节点的消耗更小，但是只支持单向遍历，所以功能会受到许多限制</p>
<p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_slist.h#L175">slist的定义</a></p>
<h3 id="8-1-slist的节点"><a href="#8-1-slist的节点" class="headerlink" title="8.1 slist的节点"></a>8.1 slist的节点</h3><div align="center"> <img src="../pic/stl-4-9.png"/> </div>

<p>节点相关的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表的节点基本结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __slist_node_base *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向链表的节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_node</span> :</span> <span class="keyword">public</span> __slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点相关的全局函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知某一节点prev_node，将新节点new_node插入其后</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link(</span><br><span class="line">    __slist_node_base *prev_node,</span><br><span class="line">    __slist_node_base *new_node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    prev_node-&gt;next = new_node; <span class="comment">//令prev节点的下一节点指向new节点</span></span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向链表的大小（元素个数）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __slist_size(__slist_node_base *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;node != <span class="number">0</span>;node = node-&gt;next)</span><br><span class="line">        ++result;   <span class="comment">//一个个累计</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-slist的迭代器"><a href="#8-2-slist的迭代器" class="headerlink" title="8.2 slist的迭代器"></a>8.2 slist的迭代器</h3><div align="center"> <img src="../pic/stl-4-10.png"/> </div>

<p>迭代器的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表的迭代器基本结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_iterator_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;   <span class="comment">//单向</span></span><br><span class="line"></span><br><span class="line">  __slist_node_base* node;  <span class="comment">//指向节点基本结构</span></span><br><span class="line"></span><br><span class="line">  __slist_iterator_base(__slist_node_base* x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123; node = node-&gt;next; &#125;    <span class="comment">//前进一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node == x.node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node != x.node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向链表的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_iterator</span> :</span> <span class="keyword">public</span> __slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __slist_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">  __slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125;</span><br><span class="line">  __slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  __slist_iterator(<span class="keyword">const</span> iterator&amp; x) : __slist_iterator_base(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((list_node*) node)-&gt;data; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">incr</span>(); <span class="comment">//前进一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">incr</span>(); <span class="comment">//前进一个节点</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="五-关联容器"><a href="#五-关联容器" class="headerlink" title="五.关联容器"></a>五.关联容器</h1><div align="center"> <img src="../pic/stl-4-1.jpeg"/> </div>

<p>标准的STL关联容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立容器，但并不开放给外界使用</p>
<p>此外，SGI STL还提供了一个不在标准规格之列的关联容器：hash table，以及以此hash table为底层机制而完成的hash_set(散列集合)、hash_map(散列映射表)、hash_multiset(散列多键集合)、hash_multimap(散列多键映射表)</p>
<h2 id="1-RB-tree"><a href="#1-RB-tree" class="headerlink" title="1.RB-tree"></a>1.RB-tree</h2><h3 id="1-1-RB-tree的节点"><a href="#1-1-RB-tree的节点" class="headerlink" title="1.1 RB-tree的节点"></a>1.1 RB-tree的节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;   <span class="comment">//红色为0</span></span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>;  <span class="comment">//黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RB-tree节点的基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color; <span class="comment">//颜色</span></span><br><span class="line">  base_ptr parent;  <span class="comment">//指向父节点的指针</span></span><br><span class="line">  base_ptr left;    <span class="comment">//指向左子节点的指针</span></span><br><span class="line">  base_ptr right;   <span class="comment">//指向右子节点的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，获取以x为根节点的RB-tree最小节点的指针</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，获取以x为根节点的RB-tree最大节点的指针</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RB-tree节点类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;    <span class="comment">//RB-tree节点的value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>键和值都包含在value_field中</strong></p>
<h3 id="1-2-RB-tree的迭代器"><a href="#1-2-RB-tree的迭代器" class="headerlink" title="1.2 RB-tree的迭代器"></a>1.2 RB-tree的迭代器</h3><p>SGI将RB-tree迭代器实现为两层：</p>
<div align="center"> <img src="../pic/stl-5-1.png"/> </div>

<p>RB-tree迭代器属于双向迭代器，但不具备随机定位能力。前进操作operator++()调用了基类迭代器的increment()，后退操作operator–()调用了基类迭代器的decrement()。前进或后退的举止行为完全依据二叉搜索树的节点排列法则</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  base_ptr node;    <span class="comment">//节点基类类型的指针，将迭代器连接到RB-tree的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;<span class="comment">//如果node右子树不为空，则找到右子树的最左子节点</span></span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果node右子树为空，则找到第一个“该节点位于其左子树”的节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">        node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp;</span><br><span class="line">        node-&gt;parent-&gt;parent == node)<span class="comment">//这种情况发生于node为header时（亦即node为</span></span><br><span class="line">      node = node-&gt;right;            <span class="comment">//end()时）header右子节点即mostright，指向max节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;<span class="comment">//如果左子树不为空，则找到左子树的最右子节点</span></span><br><span class="line">      base_ptr y = node-&gt;left;</span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">        y = y-&gt;right;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果左子树为空，则找到第一个“该节点位于其右子树”的节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_iterator</span> :</span> <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> Value&amp;, <span class="keyword">const</span> Value*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;                   self;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type; <span class="comment">//指向RB-tree节点的指针类型</span></span><br><span class="line"></span><br><span class="line">  __rb_tree_iterator() &#123;&#125;</span><br><span class="line">  __rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">  __rb_tree_iterator(<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解引用操作为获取所指RB-tree节点的value</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用父类的increment()，函数会修改node成员，使其指向后一个RB-tree节点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; <span class="built_in">increment</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">increment</span>();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//调用父类的decrement()，函数会修改node成员，使其指向前一个RB-tree节点</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; <span class="built_in">decrement</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">decrement</span>();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-RB-tree操作的实现"><a href="#1-3-RB-tree操作的实现" class="headerlink" title="1.3 RB-tree操作的实现"></a>1.3 RB-tree操作的实现</h3><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L428">RB-tree的定义</a></p>
<ul>
<li><strong>节点操作</strong>：<ul>
<li>涉及内存管理的操作<ul>
<li>分配节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L447">get_node</a></li>
<li>释放节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L449">put_node</a></li>
<li>创建节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L452">create_node</a></li>
<li>拷贝节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L462">clone_node</a></li>
<li>销毁节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L471">destroy_node</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L489">获取节点成员</a>：<ul>
<li>left</li>
<li>right</li>
<li>parent</li>
<li>value</li>
<li>key</li>
<li>color</li>
</ul>
</li>
</ul>
</li>
<li><strong>RB-tree操作</strong><ul>
<li>创建空RB-tree：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L542">rb_tree</a><ul>
<li>初始化：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L532">init</a></li>
</ul>
</li>
<li>获取root节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L485">root</a></li>
<li>获取最左子节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L486">leftmost</a></li>
<li>获取最右子节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L487">rightmost</a></li>
<li>获取起始节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L575">begin</a></li>
<li>获取末尾节点：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L577">end</a></li>
<li>是否为空：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L587">empty</a></li>
<li>大小：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L588">size</a></li>
<li><strong>插入节点</strong>：<ul>
<li>节点值独一无二：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L753">insert_unique</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L698">__insert</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L249">__rb_tree_rebalance</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L210">__rb_tree_rotate_left</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L229">__rb_tree_rotate_right</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>允许节点值重复：<a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L736">insert_equal</a><ul>
<li>__insert（同上）<ul>
<li>__rb_tree_rebalance（同上）<ul>
<li>__rb_tree_rotate_left（同上）</li>
<li>__rb_tree_rotate_right（同上）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>元素搜索</strong>：<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_tree.h#L964">find</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_set.h#L45">set的定义</a></p>
<p>set的所有元素都会根据元素的键值自动被排序。元素的键值就是实值，实值就是键值、set不允许两个元素具有相同的键值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//键值和实值类型相同，比较函数也是同一个</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;  <span class="comment">// 内含一棵RB-tree，使用RB-tree来表现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//iterator定义为RB-tree的const_iterator，表示set的迭代器无法执行写操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>set的元素值就是键值，关系到set元素的排列规则。因此不能通过set的迭代器改变set的元素值。set将其迭代器定义为RB-tree的const_iterator以防止修改</p>
<p>set所开放的各种操作接口，RB-tree也提供了，所以几乎所有的set操作行为，都只是转调用RB-tree的操作行为而已</p>
<h2 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_map.h#L58">map的定义</a></p>
<p>map的所有元素会根据元素的键值自动被排序。所有元素都是pair，同时拥有键值和实值，第一个元素被视为键值，第二个元素被视为实值。map不允许两个元素拥有相同的键值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;     <span class="comment">//键值类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T data_type;      <span class="comment">//实值类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;    </span><br><span class="line">  <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;    <span class="comment">//键值对，RB-tree节点中的value类型</span></span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;  <span class="comment">//键值比较函数</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </span><br><span class="line">                  select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;  <span class="comment">// 内含一棵RB-tree，使用RB-tree来表现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//迭代器和set不同，允许修改实值</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下标操作</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入操作</span></span><br><span class="line">  <span class="function">pair&lt;iterator,<span class="keyword">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x); &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以通过map的迭代器修改元素的实值，不能修改元素的键值</p>
<p>map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的map操作行为，都只是转调用RB-tree的操作行为而已</p>
<h2 id="4-multiset"><a href="#4-multiset" class="headerlink" title="4.multiset"></a>4.multiset</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_multiset.h#L45">set的定义</a></p>
<p>multiset的特性及用法和set完全相同，唯一的差别在于它允许键值重复，插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()</p>
<h2 id="5-multimap"><a href="#5-multimap" class="headerlink" title="5.multimap"></a>5.multimap</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_multimap.h#L45">map的定义</a></p>
<p>multimap的特性及用法和map完全相同，唯一的差别在于它允许键值重复，插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()</p>
<h2 id="6-hashtable"><a href="#6-hashtable" class="headerlink" title="6.hashtable"></a>6.hashtable</h2><div align="center"> <img src="../pic/stl-5-2.png"/> </div>

<p>SGI STL中以开哈希实现hash table，hash table表格中的元素为桶，每个桶中包含了哈希到这个桶中的节点，节点定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __hashtable_node *next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-hashtable的迭代器"><a href="#6-1-hashtable的迭代器" class="headerlink" title="6.1 hashtable的迭代器"></a>6.1 hashtable的迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          hashtable;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, </span><br><span class="line">                               ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, </span><br><span class="line">                                     ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">  node* cur;        <span class="comment">//迭代器目前所指的节点</span></span><br><span class="line">  hashtable* ht;    <span class="comment">//指向相应的hashtable</span></span><br><span class="line"></span><br><span class="line">  __hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123;&#125;</span><br><span class="line">  __hashtable_iterator() &#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前进操作首先尝试从目前所指的节点出发，前进一个位置(节点)，由于节点被安置于list内，所以利用节点的next指针即可轻易完成。如果目前节点正好是list的尾端，就跳至下一个bucket身，它正好指向下一个list的头部节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> node* old = cur;</span><br><span class="line">  cur = cur-&gt;next;  <span class="comment">//如果存在，就是它。否则进入以下if流程</span></span><br><span class="line">  <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">    <span class="comment">//根据元素值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">    size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">    <span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">      cur = ht-&gt;buckets[bucket];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> __hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashtable的迭代器没有后退操作，hashtable也没有定义所谓的逆向迭代器</p>
<h3 id="6-2-hashtable的实现"><a href="#6-2-hashtable的实现" class="headerlink" title="6.2 hashtable的实现"></a>6.2 hashtable的实现</h3><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L165">hashtable的定义</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="comment">//先前声明时，已给出Alloc默认值alloc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">  <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//以下3者都是function  objects</span></span><br><span class="line">  hasher hash;</span><br><span class="line">  key_equal equals;</span><br><span class="line">  ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;  <span class="comment">//hashtable节点类型</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">  vector&lt;node*,Alloc&gt; buckets; <span class="comment">//hashtable的桶数组，以vector完成</span></span><br><span class="line">  size_type num_elements;      <span class="comment">//元素个数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SGI STL以质数来设计表格大小，并且先将28个质数（逐渐呈现大约2倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数中，“最接近某数并大于某数”的质数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53</span>,         <span class="number">97</span>,           <span class="number">193</span>,         <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">  <span class="number">1543</span>,       <span class="number">3079</span>,         <span class="number">6151</span>,        <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">  <span class="number">49157</span>,      <span class="number">98317</span>,        <span class="number">196613</span>,      <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">  <span class="number">1572869</span>,    <span class="number">3145739</span>,      <span class="number">6291469</span>,     <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">  <span class="number">50331653</span>,   <span class="number">100663319</span>,    <span class="number">201326611</span>,   <span class="number">402653189</span>, <span class="number">805306457</span>, </span><br><span class="line">  <span class="number">1610612741</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数被next_size()所调用</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_next_prime(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* first = __stl_prime_list;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line">  <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-hashtable操作的实现"><a href="#6-3-hashtable操作的实现" class="headerlink" title="6.3 hashtable操作的实现"></a>6.3 hashtable操作的实现</h3><ul>
<li><strong>节点操作</strong><ul>
<li>涉及内存管理<ul>
<li>创建节点：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L477">new_node</a></li>
<li>销毁节点：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L488">delete_node</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>hashtable操作</strong><ul>
<li>创建满足n个bucket的hashtable：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L217">hashtable</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L499">initialize_buckets</a></li>
</ul>
</li>
<li>插入节点<ul>
<li>不允许键值重复： <a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L296">insert_unique</a><ul>
<li>判断和重新分配bucket：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L841">resize</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L624">insert_unique_noresize</a></li>
</ul>
</li>
<li>允许键值重复：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L302">insert_equal</a><ul>
<li>判断和重新分配bucket：resize（同上）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L647">insert_equal_noresize</a></li>
</ul>
</li>
</ul>
</li>
<li>哈希映射寻找bucket<ul>
<li>接受实值和buckets个数：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L472">bkt_num</a></li>
<li>只接受实值：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L462">bkt_num</a></li>
<li>只接受键值：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L457">bkt_num_key</a></li>
<li>接受键值和buckets个数：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L467">bkt_num_key</a></li>
</ul>
</li>
<li>清除：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L917">clear</a></li>
<li>复制：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L934">copy_from</a></li>
<li>查找元素：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L400">find</a></li>
<li>统计元素个数：<a href="tass-sgi-stl-2.91.57-source/stl_hashtable.h#L422">count</a></li>
</ul>
</li>
</ul>
<h3 id="6-4-hash-functions"><a href="#6-4-hash-functions" class="headerlink" title="6.4 hash functions"></a>6.4 hash functions</h3><p>hash function是计算元素位置的函数，SGI将这项任务赋予了bkt_num()，再由它来调用这里提供的hash function，取得一个可以对hashtable进行模运算的值。针对char，int，long等整数类型，大部分的hash functions什么也没做，只是忠实返回原值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __stl_hash_string(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span> ( ; *s; ++s)</span><br><span class="line">    h = <span class="number">5</span>*h + *s;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size_t</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">const</span> <span class="keyword">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">signed</span> <span class="keyword">char</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">short</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">short</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">short</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">long</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">long</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-hash-set"><a href="#7-hash-set" class="headerlink" title="7.hash_set"></a>7.hash_set</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_hash_set.h#L47">hash_set的定义</a></p>
<p>hash_set以hashtable为底层机制，由于hash_set所供应的操作接口hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为而已</p>
<h2 id="8-hash-map"><a href="#8-hash-map" class="headerlink" title="8.hash_map"></a>8.hash_map</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_hash_map.h#L49">hash_map的定义</a></p>
<p>hash_map以hashtable为底层机制，由于hash_map所供应的操作接口hashtable都提供了，所以几乎所有的hash_map操作行为，都只是转调用hashtable的操作行为而已</p>
<h2 id="9-hash-multiset"><a href="#9-hash-multiset" class="headerlink" title="9.hash_multiset"></a>9.hash_multiset</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_multiset.h#L45">hash_multiset的定义</a></p>
<p>hash_multiset和hash_set实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal()，后者则是采用insert_unique()</p>
<h2 id="10-hash-multimap"><a href="#10-hash-multimap" class="headerlink" title="10.hash_multimap"></a>10.hash_multimap</h2><p>SGI STL中<a href="tass-sgi-stl-2.91.57-source/stl_multimap.h#L45">hash_multimap的定义</a></p>
<p>hash_multimap和hash_map实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal()，后者则是采用insert_unique()</p>
<br>

<h1 id="六-算法"><a href="#六-算法" class="headerlink" title="六.算法"></a>六.算法</h1><div align="center"> <img src="../pic/stl-6-1.png"/> </div>
<div align="center"> <img src="../pic/stl-6-2.png"/> </div>
<div align="center"> <img src="../pic/stl-6-3.png"/> </div>
<div align="center"> <img src="../pic/stl-6-4.png"/> </div>

<h2 id="1-区间拷贝"><a href="#1-区间拷贝" class="headerlink" title="1.区间拷贝"></a>1.区间拷贝</h2><h3 id="1-1-copy"><a href="#1-1-copy" class="headerlink" title="1.1 copy"></a>1.1 copy</h3><p>SGI STL的copy算法用尽各种办法，包括函数重载、类型特性、偏特化等编程技巧来尽可能地加强效率</p>
<div align="center"> <img src="../pic/stl-6-5.png"/> </div>

<ul>
<li><p>泛化版本</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L177">copy</a><ul>
<li>泛化版本：<a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L135">__copy_dispatch</a><ul>
<li>版本一：<a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L108">__copy</a></li>
<li>版本二：<a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L128">__copy</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L118">__copy_d</a></li>
</ul>
</li>
</ul>
</li>
<li>偏特化版本：<a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L157">__copy_dispatch</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L146">__copy_t</a>（指针所指对象具有trivial…）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L152">__copy_t</a>（指针所指对象具有non-trivial…）</li>
</ul>
</li>
<li>偏特化版本：<a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L166">__copy_dispatch</a><ul>
<li>__copy_t（同上）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特化版本</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L183">copy</a>（针对const char*）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algobase.h#L188">copy</a>（针对const wchar_t*）</li>
</ul>
</li>
</ul>
<p>copy将输入区间<code>[first,last)</code>内的元素复制到输出区间<code>[result,result+(last-first))</code>内，也就是说，它会执行赋值操作<code>*result = *first,*(result+1) = *(first+1),...</code>依次类推。返回一个迭代器：<code>result+(last-first)</code>。copy对其template参数所要求的条件非常宽松。其输入区间只需由inputIterators构成即可，输出区间只需要由OutputIterator构成即可。这<strong>意味着可以使用copy算法，将任何容器的任何一段区间的内容，复制到任何容器的任何一段区间上</strong></p>
<div align="center"> <img src="../pic/stl-6-6.png"/> </div>

<p>由于拷贝的顺序，对于没有使用memmove()的版本，要特别注意目的区间与源区间重合的情况。memmove()能处理区间重合的情况</p>
<p>copy会为输出区间内的元素赋予新值，而不是产生新的元素。它不能改变输出区间的迭代器个数。换句话说，copy不能直接用来将元素插入空容器中。如果想将元素插入序列之内，要么使用序列容器的insert成员函数，要么使用copy算法并搭配insert_iterator</p>
<h3 id="1-2-copy-backward"><a href="#1-2-copy-backward" class="headerlink" title="1.2 copy_backward"></a>1.2 copy_backward</h3><p>copy_backward将<code>[first,last)</code>区间的每一个元素，以逆行的方向复制到以result-1为起点，方向亦为逆行的区间上。换句话说，copy_backward算法会执行赋值操作<code>*(result-1) = *(last - 1),*(result-2) = *(last - 2),...</code>以此类推，返回一个迭代器：<code>result-(last-first)</code></p>
<div align="center"> <img src="../pic/stl-6-7.png"/> </div>

<p>copy_backward所接受的迭代器必须是BidirectionalIterators，才能够“倒行逆施”</p>
<h2 id="2-set相关算法"><a href="#2-set相关算法" class="headerlink" title="2.set相关算法"></a>2.set相关算法</h2><p>这部分介绍的4个算法所接受的set，必须是有序区间，元素可能重复。换句话说，它们可以接受STL的set/multiset容器作为输入区间。hash_set/hash_multiset两种容器，以hashtable为底层机制，其内的元素并未呈现排序状态，所以虽然名称中也有set字样，却不可应用于这里的4个算法</p>
<h3 id="2-1-set-union"><a href="#2-1-set-union" class="headerlink" title="2.1 set_union"></a>2.1 set_union</h3><p>这个函数求集合s1和s2的并集。s1和s2及其并集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>
<p>s1和s2内的每个元素都不需要唯一，因此，如果某个值在s1出现n此，在s2出现m次，那么该值在输出区间中会出现max(m,n)次</p>
<p>SGI SLT中<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2104">set_union的实现</a>，操作示例如下：</p>
<div align="center"> <img src="../pic/stl-6-8.png"/> </div>

<h3 id="2-2-set-intersection"><a href="#2-2-set-intersection" class="headerlink" title="2.2 set_intersection"></a>2.2 set_intersection</h3><p>这个函数求集合s1和s2的交集。s1和s2及其交集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>
<p>SGI SLT中<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2155">set_intersection的实现</a>，操作示例如下：</p>
<div align="center"> <img src="../pic/stl-6-9.png"/> </div>

<h3 id="2-3-set-difference"><a href="#2-3-set-difference" class="headerlink" title="2.3 set_difference"></a>2.3 set_difference</h3><p>该函数计算两个集合的差集，即当s1为第一个参数，s2为第二个参数时，计算s1-s2。内含“出现于s1但不出现于s2”的每一个元素。s1和s2及其差集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>
<p>SGI SLT中<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2195">set_difference的实现</a>，操作示例如下：</p>
<div align="center"> <img src="../pic/stl-6-10.png"/> </div>

<h3 id="2-4-set-symmetric-difference"><a href="#2-4-set-symmetric-difference" class="headerlink" title="2.4 set_symmetric_difference"></a>2.4 set_symmetric_difference</h3><p>这个函数求集合s1和s2的对称差集，也就是说，它能构造出集合s1-s2与集合s2-s1的并集，内含“出现于s1但不出现于s2”以及“出现于s2但不出现于s1”的每一个元素。s1、s2及其对称差集都是以排序区间表示，返回值是一个迭代器，指向输出区间的尾端</p>
<p>由于s1和s2内的每个元素不需要唯一，因此如果某个值在s1出现n此，在s2出现m次，那么该值在输出区间中会出现|n-m|次</p>
<p>SGI SLT中<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2235">set_symmetric_difference的实现</a>，操作示例如下：</p>
<div align="center"> <img src="../pic/stl-6-11.png"/> </div>

<h2 id="3-排序sort"><a href="#3-排序sort" class="headerlink" title="3.排序sort"></a>3.排序sort</h2><p>sort要求传入的迭代器为随机迭代器，因此只能对vector和deque进行排序</p>
<p>STL的sort算法，数据量大时采用Quick Sort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷，就改用Insertion Sort。如果递归层次过深，还会改用Heap Sort</p>
<p>以下为SGI SLT的sort实现：</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1048">sort</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1005">__lg</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1012">__introsort_loop</a><ul>
<li>当子区间大于__stl_threshold(16)时才运行，否则直接返回<ul>
<li>当深度限制为0时，使用堆排序</li>
<li>当深度限制大于0时，继续递归排序</li>
</ul>
</li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L983">__final_insertion_sort</a>（此时，已经基本有序）<ul>
<li>当数组区间大于__stl_threshold(16)时<ul>
<li>对前面大小为16的区间调用：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L940">__insertion_sort</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L916">__linear_insert</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L891">__unguarded_linear_insert</a></li>
</ul>
</li>
</ul>
</li>
<li>对后面的区间调用：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L962">__unguarded_insertion_sort</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L955">__unguarded_insertion_sort_aux</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L891">__unguarded_linear_insert</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>当数组区间小于等于__stl_threshold(16)时<ul>
<li>调用：__insertion_sort（同上）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-其它算法"><a href="#4-其它算法" class="headerlink" title="4.其它算法"></a>4.其它算法</h2><p><strong>相对简单的算法</strong>：</p>
<ul>
<li><p><strong>查找</strong></p>
<ul>
<li>adjacent_find（查找第一对满足条件的相邻元素，返回第一个元素的迭代器）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L97">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L108">版本二</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L84">find</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L90">find_if</a>（可以指定操作）</li>
<li>find_end（在区间一中查找区间二最后一次出现的位置）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2557">版本一</a><ul>
<li>单向迭代器版：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2457">__find_end</a></li>
<li>双向迭代器版：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2507">__find_end</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2575">版本二</a>（可以指定操作）<ul>
<li>单向迭代器版：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2480">__find_end</a></li>
<li>双向迭代器版：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2530">__find_end</a></li>
</ul>
</li>
</ul>
</li>
<li>find_first_of（在区间一中查找区间二中任一元素第一次出现点）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2430">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2441">版本二</a>（允许指定操作）</li>
</ul>
</li>
<li>max_element<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2284">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2293">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li>min_element<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2303">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2312">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li>search（在序列一的区间中查找序列二的首次出现点）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L193">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L234">版本二</a>（允许指定操作）</li>
</ul>
</li>
<li>search_n（在序列一中查找连续n个满足条件的元素的起点）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L242">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L266">版本二</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>统计</strong></p>
<ul>
<li>count（统计等于某值的个数）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L139">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L120">版本二</a>（计数变量作为参数传入）</li>
</ul>
</li>
<li>count_if（可以指定操作）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L149">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L128">版本二</a>（计数变量作为参数传入）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>单区间操作</strong></p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L77">for_each</a>（将仿函数f施行于指定区间，f不允许修改元素，因为迭代器类型是InputIterators）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L357">generate</a>（将仿函数gen的运算结果赋值到指定区间的所有元素上）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L363">generate_n</a>（将仿函数gen的运算结果赋值到迭代器first开始的n个元素上）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L752">partition</a>（不保证元素的原始相对位置）</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-14.png"/> </div>

<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L849">stable_partition</a>（保留元素的原始相对位置）</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L392">remove</a>（区间大小并不发送变化，需要移除的元素会被后面的覆盖，区间尾部会有残余，返回指向第一个残余元素的迭代器）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L370">remove_copy</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L400">remove_if</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L381">remove_copy_if</a></li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-15.png"/> </div>

<ul>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L325">replace</a></p>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L339">replace_copy</a></p>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L332">repalce_if</a></p>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L348">replace_copy_if</a></p>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L516">reverse</a></p>
<ul>
<li>迭代器为双向迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L500">__reverse</a></li>
<li>迭代器为随机迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L510">__reverse</a></li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L521">reverse_copy</a></p>
</li>
<li><p><a href="">rotate</a>（将[first,middle)和[middle,last)的元素互换，middle所指元素将成为容器第一个元素）</p>
<ul>
<li>迭代器为向前迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L533">__rotate</a></li>
</ul>
  <div align="center"> <img src="../pic/stl-6-16.png"/> </div>

<ul>
<li>迭代器为双向迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L549">__rotate</a></li>
</ul>
  <div align="center"> <img src="../pic/stl-6-17.png"/> </div>

<ul>
<li>迭代器为随机迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L586">__rotate</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L558">__gcd</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L569">__rotate_cycle</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L604">rotate_copy</a></p>
</li>
<li><p>transform</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L307">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L316">版本二</a></li>
</ul>
</li>
<li><p>unique（移除相邻的重复元素，必须相邻，所以要先排序。和remove一样，会有残余）</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L487">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L493">版本二</a>（允许指定操作）</li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L438">unique_copy</a></p>
<ul>
<li>迭代器为向前迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L408">__unique_copy</a></li>
<li>迭代器为输出迭代器(不能读)：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L431">__unique_copy</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L418">__unique_copy</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>双区间操作</strong></p>
<ul>
<li>includes（判断区间二是否“涵盖于”区间一，两个区间必须有序）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2076">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2090">版本二</a></li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-12.png"/> </div>

<ul>
<li>merged（合并两个区间，置于另一段空间，返回指向结果序列最后元素下一位位置的迭代器）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1761">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1780">版本二</a>（允许指定操作）</li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-13.png"/> </div>
  
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L242">swap_ranges</a>（将区间一的元素与first2开始等个数的元素互换）</li>
</ul>
</li>
</ul>
<p><strong>较为复杂的算法</strong>：</p>
<ul>
<li><p><strong>查找</strong></p>
<ul>
<li>lower_bound（查找等于value的第一个元素的位置，不存在则返回第一个插入点）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1452">版本一</a><ul>
<li>迭代器是向前迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1407">__lower_bound</a></li>
<li>迭代器是随机迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1431">__lower_bound</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1505">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li>upper_bound（查找value的最后一个插入点，即如果存在元素等于value，那么插入最后一个等于value的元素之后）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1557">版本一</a><ul>
<li>迭代器是向前迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1512">__upper_bound</a></li>
<li>迭代器是随机迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1536">__upper_bound</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1610">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li>binary_search<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1747">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1757">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li>equal_range（返回一对迭代器i和j，i是lower_bound的结果，j是upper_bound的结果）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1675">版本一</a><ul>
<li>迭代器是向前迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1618">__equal_range</a></li>
<li>迭代器是随机迭代器：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1648">__equal_range</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>单区间操作</strong></p>
<ul>
<li><p>next_permutation（按字典序计算下一个排列组合。算法思想：从最尾端开始往前寻找两个相邻元素，令第一个元素为*i，第二个元素为*ii，且满足*i&lt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找到第一个大于*i的元素，设为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。就是下一个排列组合）</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2322">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2349">版本二</a></li>
</ul>
</li>
<li><p>prev_permutation（按字典序计算上一个排列组合。算法思想：从最尾端开始往前寻找两个相邻元素，令第一个元素为*i，第二个元素为*ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找到第一个小于*i的元素，设为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。就是下一个排列组合）</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2376">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2403">版本二</a></li>
</ul>
</li>
<li><p>random_shuffle</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L622">版本一</a>（使用内部随机数产生器）<br>  <a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L610">__random_shuffle</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L628">版本二</a>（使用一个会产生随机数的仿函数）</li>
</ul>
</li>
<li><p>partial_sort（将middle-first个最小元素排序并置于[first,middle)，其余元素放在middle开始的后半部）</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1272">版本一</a><ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1262">__partial_sort</a></li>
</ul>
</li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1289">版本二</a>（运行指定比较操作）<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1279">__partial_sort</a></li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-13.png"/> </div></li>
<li><p>partial_sort_copy</p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1322">版本一</a></li>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1357">版本二</a>（允许指定比较操作）</li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2058">inplace_merge</a></p>
<ul>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L2022">inplace_merge_aux</a></p>
<ul>
<li><p>有额外的缓冲区辅助：<a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1982">__merge_adaptive</a></p>
<ul>
<li>当序列1较小，且缓冲区足够容纳序列1</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-18.png"/> </div>

<ul>
<li>当序列2较小，且缓冲区足够容纳序列2</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-19.png"/> </div>

<ul>
<li>当缓冲区不足以容纳序列1和序列2<br>  <a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1867">__rotate_adaptive</a></li>
</ul>
  <div align="center"> <img src="../pic/stl-6-20.png"/> </div></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1380">nth_element</a></p>
<ul>
<li><a href="tass-sgi-stl-2.91.57-source/stl_algo.h#L1365">__nth_element</a></li>
</ul>
</li>
</ul>
  <div align="center"> <img src="../pic/stl-6-21.png"/> </div>

  <br></li>
</ul>
<h1 id="七-仿函数"><a href="#七-仿函数" class="headerlink" title="七.仿函数"></a>七.仿函数</h1><p>在STL标准规格定案后，仿函数采用<strong>函数对象</strong>作为新名称</p>
<p>函数指针的缺点在于：不能满足STL对抽象性的要求，也不能满足软件积木的要求——函数指针无法和STL其它组件（如适配器）搭配，产生更灵活的变化</p>
<p>就实现而言，仿函数其实就是一个“行为类似函数”的对象，为了能够“行为类似函数”，其类别定义中必须自定义function call运算子。拥有这样的运算子后，就可以在仿函数的对象后面加上一对小括号，以此调用仿函数所定义的operator()</p>
<div align="center"> <img src="../pic/stl-7-1.png"/> </div>

<p>STL仿函数的分类，若以操作数的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算，关系运算，逻辑运算三大类</p>
<p>任何应用程序欲使用STL內建的仿函数，都必须含入<functional>头文件，SGI则将它们实际定义于&lt;stl_function.h&gt;头文件</p>
<h2 id="1-仿函数的相应类型"><a href="#1-仿函数的相应类型" class="headerlink" title="1.仿函数的相应类型"></a>1.仿函数的相应类型</h2><p>STL仿函数应该有能力被函数适配器修饰，彼此像积木一样地串接。为了拥有适配能力，每一个仿函数必须定义自己的相应类型。就像迭代器如果要融入整个STL大家庭，也必须依照规定定义自己的5个相应类型一样。这些相应类型是为了让适配器能够取出，获得仿函数的某些信息</p>
<p>仿函数的相应类型主要用来表现<strong>函数参数类型</strong>和<strong>传回值类型</strong></p>
<p>为方便起见，&lt;stl_function.h&gt;定义了两个classes，分别代表一元仿函数和二元仿函数（STL不支持三元仿函数），其中没有任何data members或member functions，唯有一些类型定义。任何仿函数只要依据需求选择继承其中一个class，就自动拥有了那些相应类型，也就拥有了适配能力</p>
<h3 id="1-1-unary-function"><a href="#1-1-unary-function" class="headerlink" title="1.1 unary_function"></a>1.1 unary_function</h3><p>unary_function用来呈现一元函数的参数类型和返回值类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-binary-function"><a href="#1-2-binary-function" class="headerlink" title="1.2 binary_function"></a>1.2 binary_function</h3><p>binary_function用来呈现二元函数的第一参数类型，第二参数类型，以及返回值类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="2-算术类仿函数"><a href="#2-算术类仿函数" class="headerlink" title="2.算术类仿函数"></a>2.算术类仿函数</h2><p>以下为STL内建的“算术类仿函数”，除了“否定”运算为一元运算，其它都是二元运算：</p>
<ul>
<li>加法：plus&lt;T&gt;</li>
<li>减法：minus&lt;T&gt;</li>
<li>乘法：multiplies&lt;T&gt;</li>
<li>除法：divides&lt;T&gt;</li>
<li>取模：modulus&lt;T&gt;</li>
<li>否定：negate&lt;T&gt;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">multiplies</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divides</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">modulus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x % y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-关系运算类仿函数"><a href="#3-关系运算类仿函数" class="headerlink" title="3.关系运算类仿函数"></a>3.关系运算类仿函数</h2><p>以下为STL内建的“关系运算类仿函数”，每一个都是二元运算：</p>
<ul>
<li>等于：equal_to&lt;T&gt;</li>
<li>不等于：not_equal_to&lt;T&gt;</li>
<li>大于：greater&lt;T&gt;</li>
<li>大于或等于：greater_equal&lt;T&gt;</li>
<li>小于：less&lt;T&gt;</li>
<li>小于或等于：less_equal&lt;T&gt;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">not_equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x != y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &gt;= y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &lt;= y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-逻辑运算类仿函数"><a href="#4-逻辑运算类仿函数" class="headerlink" title="4.逻辑运算类仿函数"></a>4.逻辑运算类仿函数</h2><p>以下为STL内建的“逻辑运算类仿函数”，其中And和Or是二元运算，Not为一元运算：</p>
<ul>
<li>逻辑运算 And：logical_and&lt;T&gt;</li>
<li>逻辑运算 Or：logical_or&lt;T&gt;</li>
<li>逻辑运算 Not：logical_not&lt;T&gt;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x || y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-证同，选择与投射"><a href="#5-证同，选择与投射" class="headerlink" title="5.证同，选择与投射"></a>5.证同，选择与投射</h2><p>C++标准并未涵盖这里介绍的任何一个仿函数，不过它们常常存在于各个实现品中作为内部运用。在SGI STL中的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//证同函数。任何数值通过此函数后，不会有任何改变</span></span><br><span class="line"><span class="comment">//此函数运用于&lt;stl_set.h&gt;，用来指定RB-tree所需的KeyOfValue op</span></span><br><span class="line"><span class="comment">//那是因为set元素的键值即实值，所以采用identity</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择函数：接受一个pair，传回其第一元素</span></span><br><span class="line"><span class="comment">//此函数运用于&lt;stl_map.h&gt;，用来指定RB-tree所需的KeyOfValue op</span></span><br><span class="line"><span class="comment">//由于map系以pair元素的第一元素为其键值，所以采用select1st</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择函数：接受一个pair,传回其第二元素</span></span><br><span class="line"><span class="comment">//SGI STL并未运用此函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::second_type&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair&amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投射函数：传回其第一参数，忽略第二参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project1st</span> :</span> <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Arg1&gt; &#123;</span><br><span class="line">  <span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Arg1&amp; x, <span class="keyword">const</span> Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投射函数：传回第二参数，忽略第一参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project2nd</span> :</span> <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Arg2&gt; &#123;</span><br><span class="line">  <span class="function">Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Arg1&amp;, <span class="keyword">const</span> Arg2&amp; y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="八-适配器"><a href="#八-适配器" class="headerlink" title="八.适配器"></a>八.适配器</h1><p>适配器在STL组件的灵活组合运用功能上，扮演着轴承、转换器的角色</p>
<p>STL所提供的各种适配器中：1）改变仿函数接口者，称为函数适配器；2）改变容器接口者，称为容器适配器；3）改变迭代器接口者，称为迭代器适配器</p>
<h2 id="1-容器适配器"><a href="#1-容器适配器" class="headerlink" title="1.容器适配器"></a>1.容器适配器</h2><p>STL提供两个容器适配器：queue和stack，它们修饰deque的接口而生成新的容器风貌</p>
<p>stack的底层由deque构成。stack封锁住了所有的deque对外接口，只开放符合stack原则的几个函数</p>
<p>queue的底层也由deque构成。queue封锁住了所有的deque对外接口，只开放符合queue原则的几个函数</p>
<blockquote>
<p>stack和queue的具体详见第四章</p>
</blockquote>
<h2 id="2-迭代器适配器"><a href="#2-迭代器适配器" class="headerlink" title="2.迭代器适配器"></a>2.迭代器适配器</h2><p>STL提供了许多应用于迭代器身上的适配器，包括：</p>
<ol>
<li><p><a href="#21-insert-iterators">insert iterators</a>：可以将一般迭代的赋值操作转变为插入操作，可以分为下面几个</p>
<ul>
<li><a href="#1back_insert_iterator">back_insert_iterator</a>：专门负责尾端的插入操作</li>
<li><a href="#2front_insert_iterator">front_insert_iterator</a>：专门负责首部的插入操作</li>
<li><a href="#3insert_iterator">insert_iterator</a>：可以从任意位置执行插入操作</li>
</ul>
<p> 由于上面3个迭代器的使用接口不是十分直观，因此，STL提供了三个相应函数用以获取相应迭代器：</p>
 <div align="center"> <img src="../pic/stl-8-2.png"/> </div></li>
<li><p><a href="#22-reverse-iterators">reverse iterators</a>：可以将一般迭代器的行进方向反转</p>
</li>
<li><p><a href="#23-iostream-iterators">iostream iterators</a>：可以将迭代器绑定到某个iostream对象身上</p>
<ul>
<li>绑定到istream对象身上的，称为istream_iterator，拥有输入功能</li>
<li>绑定到ostream对象身上的，称为ostream_iterator，拥有输出功能</li>
</ul>
</li>
</ol>
<p><strong>C++ Standard规定它们的接口可以藉由<iterator>获得</strong>，SGI STL将它们实际定义于&lt;stl_iterator.h&gt;</p>
<h3 id="2-1-insert-iterators"><a href="#2-1-insert-iterators" class="headerlink" title="2.1 insert iterators"></a>2.1 insert iterators</h3><p><strong>insert iterators实现的主要观念是</strong>：每一个insert iterators内部都维护有一个容器（必须由用户指定）；容器当然有自己的迭代器，于是，当客户端对insert iterators做赋值操作时，就在insert iterators中被转为对该容器的迭代器做插入操作（也就是说，调用底层容器的push_front()或push_back()或insert()）</p>
<p>其它迭代器惯常的行为如：operator++、operator++(int)、operator*都被关闭，更没有提供operator–或operator–(int)或operator-&gt;等功能，因此类型被定义为output_iterator_tag</p>
<h4 id="1）back-insert-iterator"><a href="#1）back-insert-iterator" class="headerlink" title="1）back_insert_iterator"></a>1）back_insert_iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">back_insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Container* container; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;    <span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数。传入一个容器，使back_insert_iterator与容器绑定起来</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">back_insert_iterator</span><span class="params">(Container&amp; x)</span> : container(&amp;x) &#123;</span>&#125;</span><br><span class="line">  <span class="comment">//赋值操作</span></span><br><span class="line">  back_insert_iterator&lt;Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(value);  <span class="comment">//赋值操作的关键是转调用容器的push_back()</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以下3个操作对back_insert_iterator不起作用（关闭功能）</span></span><br><span class="line">  <span class="comment">//三个操作符返回的都是back_insert_iterator自己</span></span><br><span class="line">  back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用back_insert_iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> back_insert_iterator&lt;Container&gt; <span class="title">back_inserter</span><span class="params">(Container&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> back_insert_iterator&lt;Container&gt;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）front-insert-iterator"><a href="#2）front-insert-iterator" class="headerlink" title="2）front_insert_iterator"></a>2）front_insert_iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">front_insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Container* container; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;   <span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数。传入一个容器，使front_insert_iterator与容器绑定起来</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">front_insert_iterator</span><span class="params">(Container&amp; x)</span> : container(&amp;x) &#123;</span>&#125;</span><br><span class="line">  <span class="comment">//赋值操作</span></span><br><span class="line">  front_insert_iterator&lt;Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_front</span>(value);  <span class="comment">//赋值操作的关键是转调用容器的push_front()</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以下3个操作对front_insert_iterator不起作用（关闭功能）</span></span><br><span class="line">  <span class="comment">//三个操作符返回的都是front_insert_iterator自己</span></span><br><span class="line">  front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用front_insert_iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> front_insert_iterator&lt;Container&gt; <span class="title">front_inserter</span><span class="params">(Container&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> front_insert_iterator&lt;Container&gt;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）insert-iterator"><a href="#3）insert-iterator" class="headerlink" title="3）insert_iterator"></a>3）insert_iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Container* container;                 <span class="comment">//底层容器</span></span><br><span class="line">  <span class="keyword">typename</span> Container::iterator iter;    <span class="comment">//底层容器的迭代器（前2个插入迭代器没有）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;    <span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数。传入一个容器，使insert_iterator与容器和容器迭代器绑定起来</span></span><br><span class="line">  <span class="built_in">insert_iterator</span>(Container&amp; x, <span class="keyword">typename</span> Container::iterator i) </span><br><span class="line">    : <span class="built_in">container</span>(&amp;x), <span class="built_in">iter</span>(i) &#123;&#125;</span><br><span class="line">  <span class="comment">//赋值操作</span></span><br><span class="line">  insert_iterator&lt;Container&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123; </span><br><span class="line">    iter = container-&gt;<span class="built_in">insert</span>(iter, value);  <span class="comment">//赋值操作的关键是转调用容器的insert()</span></span><br><span class="line">    ++iter; <span class="comment">//使insert iterator永远随其目标贴身移动</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以下3个操作对insert_iterator不起作用（关闭功能）</span></span><br><span class="line">  <span class="comment">//三个操作符返回的都是insert_iterator自己</span></span><br><span class="line">  insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用insert_iterator</span></span><br><span class="line"><span class="comment">//和前2个插入迭代器不容，这里还需额外传入一个底层容器的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>, <span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> insert_iterator&lt;Container&gt; <span class="title">inserter</span><span class="params">(Container&amp; x, Iterator i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">  <span class="keyword">return</span> insert_iterator&lt;Container&gt;(x, <span class="built_in">iter</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-reverse-iterators"><a href="#2-2-reverse-iterators" class="headerlink" title="2.2 reverse iterators"></a>2.2 reverse iterators</h3><p>可以通过一个<strong>双向顺序容器</strong>调用rbegin()，和rend()来获取相应的逆向迭代器。只要双向顺序容器提供了begin(),end()，它的rbegin()和rend()就如同下面的形式。单向顺序容器slist不可使用reserve iterators。有些容器如stack、queue、priority_queue并不提供begin()，end()，当然也就没有rbegin()和rend()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator; <span class="comment">//容器迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator; <span class="comment">//逆向迭代器类型</span></span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;   iterator; <span class="comment">//容器迭代器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  <span class="comment">//逆向迭代器类型</span></span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;   iterator;  <span class="comment">//容器迭代器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator; <span class="comment">//逆向迭代器类型</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(finish); &#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(start); &#125;</span><br></pre></td></tr></table></figure>

<p>正向迭代器和逆向迭代器的逻辑位置如下图：</p>
<div align="center"> <img src="../pic/stl-8-3.png"/> </div>

<p>具有这样的逻辑位置关系，当我们将一个正向迭代器区间转换为一个逆向迭代器区间后，不必再有任何额外处理，就可以让接受这个逆向迭代器区间的算法，以相反的元素次序处理区间中的每一个元素</p>
<p>reverse_iterator实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reverse_iterator</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Iterator current; <span class="comment">//对应的正向迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//迭代器的5种相应类型都和其对应的正向迭代器相同</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category</span><br><span class="line">          iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type</span><br><span class="line">          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type</span><br><span class="line">          difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer</span><br><span class="line">          pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference</span><br><span class="line">          reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> Iterator iterator_type;              <span class="comment">//代表正向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;     <span class="comment">//代表逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">reverse_iterator</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//下面这个构造函数将逆向迭代器与正向迭代器x关联起来</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span> : current(x) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">reverse_iterator</span>(<span class="keyword">const</span> self&amp; x) : <span class="built_in">current</span>(x.current) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//base()成员函数返回相应的正向迭代器</span></span><br><span class="line">  <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对逆向迭代器取值，就是将“对应的正向迭代器”后退一步后取值ßßßß</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    Iterator tmp = current;</span><br><span class="line">    <span class="keyword">return</span> *--tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//前置++，++变为--</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    --current;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后置++，++变--</span></span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --current;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前置--，--变++</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    ++current;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//后置--，--变++</span></span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++current;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//前进与后退方向完全逆转</span></span><br><span class="line">  self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>(current - n);</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    current -= n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>(current + n);</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">    current += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第一个*会调用本类的operator*，第二个不会</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="2-3-iostream-iterators"><a href="#2-3-iostream-iterators" class="headerlink" title="2.3 iostream iterators"></a>2.3 iostream iterators</h3><h4 id="1）istream-iterator"><a href="#1）istream-iterator" class="headerlink" title="1）istream_iterator"></a>1）istream_iterator</h4><p>所谓绑定一个istream object，其实就是在istream iterator内部维护一个istream member，客户端对于这个迭代器所做的operator++操作，会被引导调用迭代器内部所含的那个istream member的输入操作(operator&gt;&gt;)。这个迭代器是个input iterator，不具备operator–</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits,Distance&gt;</span></span><br><span class="line"><span class="comment">//然而一般使用input iterators时都只使用第一个template参数、此时以下仍适用</span></span><br><span class="line"><span class="comment">//SGI STL 3.3已实现出符合标准接口的istream_iterator，做法与本版大同小异</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span> =</span> <span class="keyword">ptrdiff_t</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> istream_iterator&lt;T, Distance&gt;&amp; x,</span><br><span class="line">                                   <span class="keyword">const</span> istream_iterator&lt;T, Distance&gt;&amp; y);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  istream* stream;</span><br><span class="line">  T value;</span><br><span class="line">  <span class="keyword">bool</span> end_marker;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    end_marker = (*stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (end_marker) *stream &gt;&gt; value;       <span class="comment">//关键</span></span><br><span class="line">    <span class="comment">//输入后，stream的状态可能改变，所以下面再判断一次以决定end_marker</span></span><br><span class="line">    <span class="comment">//当读到eof或读到类型不符的数据，stream即处于false状态</span></span><br><span class="line">    end_marker = (*stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> input_iterator_tag iterator_category; <span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T                  value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance           difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T*           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp;           reference;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">istream_iterator</span>() : <span class="built_in">stream</span>(&amp;cin), <span class="built_in">end_marker</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">istream_iterator</span>(istream&amp; s) : <span class="built_in">stream</span>(&amp;s) &#123; <span class="built_in">read</span>(); &#125;</span><br><span class="line">  <span class="comment">//以上两行的用法：</span></span><br><span class="line">  <span class="comment">// istream_iterator&lt;int&gt; eos;         造成end_marker为false</span></span><br><span class="line">  <span class="comment">// istream_iterator&lt;int&gt; initer(cin)  引发read()，程序至此会等待输入</span></span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//迭代器前进一个位置，就代表要读取一次数据</span></span><br><span class="line">  istream_iterator&lt;T, Distance&gt;&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    <span class="built_in">read</span>(); </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  istream_iterator&lt;T, Distance&gt; <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">    istream_iterator&lt;T, Distance&gt; tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下图展示了copy()和istream_iterator共同合作的例子：</p>
<div align="center"> <img src="../pic/stl-8-4.png"/> </div>

<h4 id="2）ostream-iterator"><a href="#2）ostream-iterator" class="headerlink" title="2）ostream_iterator"></a>2）ostream_iterator</h4><p>所谓绑定一个ostream object，其实就是在oßstream iterator内部维护一个ostream member，客户端对于这个迭代器所做的operator=操作，会被引导调用迭代器内部所含的那个ostream member的输出操作(operator&lt;&lt;)。这个迭代器是个Onput iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits&gt;</span></span><br><span class="line"><span class="comment">//然而一般使用onput iterators时都只使用第一个template参数、此时以下仍适用</span></span><br><span class="line"><span class="comment">//SGI STL 3.3已实现出符合标准接口的ostream_iterator，做法与本版大同小异</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  ostream* stream;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* string;   <span class="comment">//每次输出后的间隔符号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;    <span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ostream_iterator</span>(ostream&amp; s) : <span class="built_in">stream</span>(&amp;s), <span class="built_in">string</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">ostream_iterator</span>(ostream&amp; s, <span class="keyword">const</span> <span class="keyword">char</span>* c) : <span class="built_in">stream</span>(&amp;s), <span class="built_in">string</span>(c)  &#123;&#125;</span><br><span class="line">  <span class="comment">//对迭代器做赋值操作，就代表要输出一笔数据</span></span><br><span class="line">  ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; value) &#123; </span><br><span class="line">    *stream &lt;&lt; value;               <span class="comment">//关键，输出数值</span></span><br><span class="line">    <span class="keyword">if</span> (string) *stream &lt;&lt; string;  <span class="comment">//如果间隔符号不为空，输出间隔符号</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line">  ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下图展示了copy()和ostream_iterator共同合作的例子：</p>
<div align="center"> <img src="../pic/stl-8-5.png"/> </div>

<h2 id="3-函数适配器"><a href="#3-函数适配器" class="headerlink" title="3.函数适配器"></a>3.函数适配器</h2><p>函数适配器(functor adapters，亦即function adapters)是所有适配器中数量最庞大的一个族群，其适配灵活度也是前2者所不能及，可以适配、适配、再适配</p>
<p><strong>函数适配器的价值</strong>：通过它们之间的绑定、组合、修饰能力，几乎可以无限制地创造出各种可能的表达式，搭配STL算法一起演出。下表是STL函数适配器一览表：</p>
<div align="center"> <img src="../pic/stl-8-1.png"/> </div>

<p><strong>适配操作包括</strong>：</p>
<ul>
<li><strong>bind、negate、compose</strong></li>
<li><strong>对一般函数或成员函数的修饰</strong></li>
</ul>
<p><strong>C++标准规定，这些适配器的接口可由&lt;functional&gt;获得</strong>，SGI STL将它们定义于&lt;stl_function.h&gt;</p>
<p><strong>注意，所有期望获得适配能力的组件，本身都必须是可适配的。换句话说，1）一元仿函数必须继承自unary_function；2）二元仿函数必须继承自binary_function；3）成员函数必须以mem_fun处理过；4）一般函数必须以ptr_fun处理过。一个未经ptr_fun处理过的一般函数，虽然也能以函数指针的形式传给STL算法使用，却无法拥有任何适配能力</strong></p>
<p>下图是count_if()和bind2nd(less<int>(),12)的搭配实例；</p>
<div align="center"> <img src="../pic/stl-8-6.png"/> </div>

<h3 id="3-1-not1和not2"><a href="#3-1-not1和not2" class="headerlink" title="3.1 not1和not2"></a>3.1 not1和not2</h3><h4 id="1）not1"><a href="#1）not1" class="headerlink" title="1）not1"></a>1）not1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下适配器用来表示某个 &quot;可适配 predicate&quot; 的逻辑负值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unary_negate</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Predicate pred;   <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> Predicate&amp; x)</span> : pred(x) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">pred</span>(x); <span class="comment">//将pred的运算结果加上否定运算</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以更方便使用unary_negate</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_negate&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）not2"><a href="#2）not2" class="headerlink" title="2）not2"></a>2）not2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下适配器用来表示某个 &quot;可适配 binary predicate&quot; 的逻辑负值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_negate</span> </span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">typename</span> Predicate::first_argument_type,</span><br><span class="line">                           <span class="keyword">typename</span> Predicate::second_argument_type,</span><br><span class="line">                           <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Predicate pred;   <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">binary_negate</span><span class="params">(<span class="keyword">const</span> Predicate&amp; x)</span> : pred(x) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::first_argument_type&amp; x, </span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">const</span> <span class="keyword">typename</span> Predicate::second_argument_type&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">pred</span>(x, y);  <span class="comment">//将pred的运算结果加上否定运算</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以更方便使用binary_negate</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_negate&lt;Predicate&gt; <span class="title">not2</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> binary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-bind1st和bind2st"><a href="#3-2-bind1st和bind2st" class="headerlink" title="3.2 bind1st和bind2st"></a>3.2 bind1st和bind2st</h3><h4 id="1）bind1st"><a href="#1）bind1st" class="headerlink" title="1）bind1st"></a>1）bind1st</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下适配器用来表示某个 &quot;可适配 binary function&quot; 转换为 “unary function”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder1st</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::second_argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation op;     <span class="comment">//内部成员</span></span><br><span class="line">  <span class="keyword">typename</span> Operation::first_argument_type value;    <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">binder1st</span>(<span class="keyword">const</span> Operation&amp; x,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; y)</span><br><span class="line">      : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;  <span class="comment">//将表达式和第一参数记录于内部成员</span></span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op</span>(value, x);    <span class="comment">//实际调用表达式，并将value绑定为第一参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以更方便使用binder1st</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder1st&lt;Operation&gt; <span class="title">bind1st</span><span class="params">(<span class="keyword">const</span> Operation&amp; op, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先把x转型为op的第一参数类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::first_argument_type arg1_type;</span><br><span class="line">  <span class="keyword">return</span> binder1st&lt;Operation&gt;(op, <span class="built_in">arg1_type</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）bind2st"><a href="#2）bind2st" class="headerlink" title="2）bind2st"></a>2）bind2st</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下适配器用来表示某个 &quot;可适配 binary function&quot; 转换为 “unary function”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder2nd</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation op;     <span class="comment">//内部成员</span></span><br><span class="line">  <span class="keyword">typename</span> Operation::second_argument_type value;   <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">binder2nd</span>(<span class="keyword">const</span> Operation&amp; x,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y) </span><br><span class="line">      : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;  <span class="comment">//将表达式和第二参数记录于内部成员</span></span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op</span>(x, value);  <span class="comment">//实际调用表达式，并将value绑定为第二参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以更方便使用binder2nd</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> Operation&amp; op, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先把x转型为op的第一参数类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line">  <span class="keyword">return</span> binder2nd&lt;Operation&gt;(op, <span class="built_in">arg2_type</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-compose1和compose2"><a href="#3-3-compose1和compose2" class="headerlink" title="3.3 compose1和compose2"></a>3.3 compose1和compose2</h3><h4 id="1）compose1"><a href="#1）compose1" class="headerlink" title="1）compose1"></a>1）compose1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知两个 &quot;可适配 unary function&quot; f(),g()，以下适配器用来产生一个h()，</span></span><br><span class="line"><span class="comment">//使 h(x) = f(g(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation1</span>, <span class="keyword">class</span> <span class="title">Operation2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unary_compose</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">                                            <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation1 op1;   <span class="comment">//内部成员</span></span><br><span class="line">  Operation2 op2;   <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数，将两个表达式记录于内部成员</span></span><br><span class="line">  <span class="built_in">unary_compose</span>(<span class="keyword">const</span> Operation1&amp; x, <span class="keyword">const</span> Operation2&amp; y) : <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Operation1::result_type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x));     <span class="comment">//函数合成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用unary_compose</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation1</span>, <span class="keyword">class</span> <span class="title">Operation2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_compose&lt;Operation1, Operation2&gt; <span class="title">compose1</span><span class="params">(<span class="keyword">const</span> Operation1&amp; op1, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">const</span> Operation2&amp; op2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unary_compose&lt;Operation1, Operation2&gt;(op1, op2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）compose2"><a href="#2）compose2" class="headerlink" title="2）compose2"></a>2）compose2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知一个 “可适配 binary function” f 和 两个 &quot;可适配 unary function&quot; g1,g2，</span></span><br><span class="line"><span class="comment">//以下适配器用来产生一个h，使 h(x) = f(g1(x),g2(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation1</span>, <span class="keyword">class</span> <span class="title">Operation2</span>, <span class="keyword">class</span> <span class="title">Operation3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_compose</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Operation1 op1;   <span class="comment">//内部成员</span></span><br><span class="line">  Operation2 op2;   <span class="comment">//内部成员</span></span><br><span class="line">  Operation3 op3;   <span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数，将三个表达式记录于内部成员</span></span><br><span class="line">  <span class="built_in">binary_compose</span>(<span class="keyword">const</span> Operation1&amp; x, <span class="keyword">const</span> Operation2&amp; y, </span><br><span class="line">                 <span class="keyword">const</span> Operation3&amp; z) : <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y), <span class="built_in">op3</span>(z) &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Operation1::result_type</span></span><br><span class="line"><span class="function">  <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x), <span class="built_in">op3</span>(x));     <span class="comment">//函数合成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用binary_compose</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Operation1</span>, <span class="keyword">class</span> <span class="title">Operation2</span>, <span class="keyword">class</span> <span class="title">Operation3</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_compose&lt;Operation1, Operation2, Operation3&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose2</span><span class="params">(<span class="keyword">const</span> Operation1&amp; op1, <span class="keyword">const</span> Operation2&amp; op2, <span class="keyword">const</span> Operation3&amp; op3)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> binary_compose&lt;Operation1, Operation2, Operation3&gt;(op1, op2, op3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-用于函数指针的ptr-fun"><a href="#3-4-用于函数指针的ptr-fun" class="headerlink" title="3.4 用于函数指针的ptr_fun"></a>3.4 用于函数指针的ptr_fun</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下适配器其实就是把一个一元函数指针包起来</span></span><br><span class="line"><span class="comment">//当仿函数被动调用时，就调用该函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pointer_to_unary_function</span> :</span> <span class="keyword">public</span> unary_function&lt;Arg, Result&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">Result</span> (*ptr)(Arg);   <span class="comment">//内部成员，一个函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">pointer_to_unary_function</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//构造函数，将函数指针记录于内部成员中</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_unary_function</span><span class="params">(Result (*x)(Arg))</span> : ptr(x) &#123;</span>&#125;</span><br><span class="line">  <span class="comment">//通过函数指针指向函数</span></span><br><span class="line">  <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便使用pointer_to_unary_function </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_unary_function&lt;Arg, Result&gt; <span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pointer_to_unary_function&lt;Arg, Result&gt;(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下适配器其实就是把一个二元函数指针包起来</span></span><br><span class="line"><span class="comment">//当仿函数被动调用时，就调用该函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pointer_to_binary_function</span> :</span> <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Result&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Result</span> (*ptr)(Arg1, Arg2);  <span class="comment">//内部成员，一个函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pointer_to_binary_function</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//构造函数，将函数指针记录于内部成员中</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_binary_function</span><span class="params">(Result (*x)(Arg1, Arg2))</span> : ptr(x) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//通过函数指针指向函数</span></span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg1 x, Arg2 y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x, y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便使用pointer_to_binary_function </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="keyword">class</span> <span class="title">Arg2</span>, <span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_binary_function&lt;Arg1, Arg2, Result&gt; </span></span><br><span class="line"><span class="function"><span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg1, Arg2))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-用于成员函数指针的mem-fun和mem-fun-ref"><a href="#3-5-用于成员函数指针的mem-fun和mem-fun-ref" class="headerlink" title="3.5 用于成员函数指针的mem_fun和mem_fun_ref"></a>3.5 用于成员函数指针的mem_fun和mem_fun_ref</h3><p>假设Shape是一个继承体系中的基类，并且具有虚函数display()，有一个vector&lt;Shape*&gt; V，那么可以给for_each()传入一个以适配器mem_fun修饰的display()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>(),<span class="built_in">mem_fun</span>(&amp;Shape::display));</span><br></pre></td></tr></table></figure>

<p>不能写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>(),&amp;Shape::display);</span><br><span class="line">for_each(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>(),Shape::display);</span><br></pre></td></tr></table></figure>

<p>以下是用于成员函数的适配器的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“无任何参数”、“通过pointer调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun_t</span> :</span> <span class="keyword">public</span> unary_function&lt;T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_t</span><span class="params">(S (T::*pf)())</span> : f(pf) &#123;</span>&#125;       <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;    <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过pointer调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun_t</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">const</span> T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_t</span><span class="params">(S (T::*pf)() <span class="keyword">const</span>)</span> : f(pf) &#123;</span>&#125; <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* p)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;    <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过reference调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun_ref_t</span> :</span> <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(S (T::*pf)())</span> : f(pf) &#123;</span>&#125;   <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;     <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过reference调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun_ref_t</span> :</span> <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_ref_t</span><span class="params">(S (T::*pf)() <span class="keyword">const</span>)</span> : f(pf) &#123;</span>&#125;  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; r)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;          <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有1个参数”、“通过pointer调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun1_t</span> :</span> <span class="keyword">public</span> binary_function&lt;T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_t</span><span class="params">(S (T::*pf)(A))</span> : f(pf) &#123;</span>&#125;         <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p, A x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125;  <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)(A);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有1个参数”、“通过pointer调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun1_t</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_t</span><span class="params">(S (T::*pf)(A) <span class="keyword">const</span>)</span> : f(pf) &#123;</span>&#125;  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* p, A x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125; <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)(A) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有1个参数”、“通过reference调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun1_ref_t</span> :</span> <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A))</span> : f(pf) &#123;</span>&#125;     <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r, A x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125;   <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)(A);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有1个参数”、“通过reference调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun1_ref_t</span> :</span> <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A) <span class="keyword">const</span>)</span> : f(pf) &#123;</span>&#125; <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; r, A x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125;     <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">S</span> (T::*f)(A) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * 下面的8个辅助函数简化了上面8个类的使用</span></span><br><span class="line"><span class="comment"> * mem_fun 与 mem_fun_ref</span></span><br><span class="line"><span class="comment"> * mem_fun1 与 mem_fun1_ref：C++标准已经去掉了1，改成和上面2个</span></span><br><span class="line"><span class="comment">                            函数重载的形式</span></span><br><span class="line"><span class="comment"> *********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">mem_fun_t</span>&lt;S,T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)())</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">mem_fun_t</span>&lt;S,T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const_mem_fun_t</span>&lt;S,T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)() <span class="keyword">const</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_mem_fun_t</span>&lt;S,T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">mem_fun_ref_t</span>&lt;S,T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)())</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">mem_fun_ref_t</span>&lt;S,T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const_mem_fun_ref_t</span>&lt;S,T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)() <span class="keyword">const</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_mem_fun_ref_t</span>&lt;S,T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">mem_fun1_t</span>&lt;S,T,A&gt; <span class="title">mem_fun1</span><span class="params">(S (T::*f)(A))</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">mem_fun1_t</span>&lt;S,T,A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const_mem_fun1_t</span>&lt;S,T,A&gt; <span class="title">mem_fun1</span><span class="params">(S (T::*f)(A) <span class="keyword">const</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_mem_fun1_t</span>&lt;S,T,A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">mem_fun1_ref_t</span>&lt;S,T,A&gt; <span class="title">mem_fun1_ref</span><span class="params">(S (T::*f)(A))</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">mem_fun1_ref_t</span>&lt;S,T,A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">S</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const_mem_fun1_ref_t</span>&lt;S,T,A&gt; <span class="title">mem_fun1_ref</span><span class="params">(S (T::*f)(A) <span class="keyword">const</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_mem_fun1_ref_t</span>&lt;S,T,A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/running/">跑步</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一.简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GNU%E6%BA%90%E4%BB%A3%E7%A0%81%E5%BC%80%E6%94%BE%E7%B2%BE%E7%A5%9E"><span class="toc-number">1.1.</span> <span class="toc-text">1.GNU源代码开放精神</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-STL%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">2.STL版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SGI-STL%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83"><span class="toc-number">1.3.</span> <span class="toc-text">3.SGI STL头文件分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-STL%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.STL六大部件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二.空间分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">1.空间分配器的标准接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SGI%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8std-allocator"><span class="toc-number">2.2.</span> <span class="toc-text">2.SGI标准的空间分配器std::allocator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SGI%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8std-alloc"><span class="toc-number">2.3.</span> <span class="toc-text">3.SGI特殊的空间分配器std::alloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 对象构造与析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%A4%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">1）两级分配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8-malloc-alloc-template"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">2）第一级分配器__malloc_alloc_template</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8-default-alloc-template"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3）第二级分配器__default_alloc_template</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 内存基本处理工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三.迭代器与traits编程技法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.迭代器相应类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.traits编程技法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 迭代器类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-std-iterator%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.std::iterator的保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SGI-STL%E7%9A%84-type-traits"><span class="toc-number">3.4.</span> <span class="toc-text">4.SGI STL的__type_traits</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">四.顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vector"><span class="toc-number">4.1.</span> <span class="toc-text">1.vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-vector%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 vector操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-list"><span class="toc-number">4.2.</span> <span class="toc-text">2.list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 list的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-list%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.5.</span> <span class="toc-text">2.5 list操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-deque"><span class="toc-number">4.3.</span> <span class="toc-text">3.deque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3 deque的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.4 分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-deque%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.5 deque操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-stack"><span class="toc-number">4.4.</span> <span class="toc-text">4.stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-queue"><span class="toc-number">4.5.</span> <span class="toc-text">5.queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-heap"><span class="toc-number">4.6.</span> <span class="toc-text">6.heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-priority-queue"><span class="toc-number">4.7.</span> <span class="toc-text">7.priority_queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-slist"><span class="toc-number">4.8.</span> <span class="toc-text">8.slist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-slist%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">4.8.1.</span> <span class="toc-text">8.1 slist的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-slist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.8.2.</span> <span class="toc-text">8.2 slist的迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">五.关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RB-tree"><span class="toc-number">5.1.</span> <span class="toc-text">1.RB-tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-RB-tree%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 RB-tree的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-RB-tree%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 RB-tree的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-RB-tree%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 RB-tree操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-set"><span class="toc-number">5.2.</span> <span class="toc-text">2.set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-map"><span class="toc-number">5.3.</span> <span class="toc-text">3.map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-multiset"><span class="toc-number">5.4.</span> <span class="toc-text">4.multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-multimap"><span class="toc-number">5.5.</span> <span class="toc-text">5.multimap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-hashtable"><span class="toc-number">5.6.</span> <span class="toc-text">6.hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.6.1.</span> <span class="toc-text">6.1 hashtable的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-hashtable%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text">6.2 hashtable的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-hashtable%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">6.3 hashtable操作的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-hash-functions"><span class="toc-number">5.6.4.</span> <span class="toc-text">6.4 hash functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-hash-set"><span class="toc-number">5.7.</span> <span class="toc-text">7.hash_set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-hash-map"><span class="toc-number">5.8.</span> <span class="toc-text">8.hash_map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-hash-multiset"><span class="toc-number">5.9.</span> <span class="toc-text">9.hash_multiset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-hash-multimap"><span class="toc-number">5.10.</span> <span class="toc-text">10.hash_multimap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六.算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.1.</span> <span class="toc-text">1.区间拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-copy"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-copy-backward"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 copy_backward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2.set相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-set-union"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 set_union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-set-intersection"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 set_intersection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-set-difference"><span class="toc-number">6.2.3.</span> <span class="toc-text">2.3 set_difference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-set-symmetric-difference"><span class="toc-number">6.2.4.</span> <span class="toc-text">2.4 set_symmetric_difference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%92%E5%BA%8Fsort"><span class="toc-number">6.3.</span> <span class="toc-text">3.排序sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">4.其它算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">七.仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1.仿函数的相应类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-unary-function"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 unary_function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-binary-function"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2 binary_function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">2.算术类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">3.关系运算类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">4.逻辑运算类仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%81%E5%90%8C%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8A%95%E5%B0%84"><span class="toc-number">7.5.</span> <span class="toc-text">5.证同，选择与投射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">八.适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1.容器适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">2.迭代器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-insert-iterators"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 insert iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89back-insert-iterator"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">1）back_insert_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89front-insert-iterator"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">2）front_insert_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89insert-iterator"><span class="toc-number">8.2.1.3.</span> <span class="toc-text">3）insert_iterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-reverse-iterators"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 reverse iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-iostream-iterators"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 iostream iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89istream-iterator"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">1）istream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89ostream-iterator"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">2）ostream_iterator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">3.函数适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-not1%E5%92%8Cnot2"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 not1和not2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89not1"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">1）not1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89not2"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">2）not2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-bind1st%E5%92%8Cbind2st"><span class="toc-number">8.3.2.</span> <span class="toc-text">3.2 bind1st和bind2st</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89bind1st"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">1）bind1st</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89bind2st"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">2）bind2st</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-compose1%E5%92%8Ccompose2"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.3 compose1和compose2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89compose1"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">1）compose1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89compose2"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">2）compose2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84ptr-fun"><span class="toc-number">8.3.4.</span> <span class="toc-text">3.4 用于函数指针的ptr_fun</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84mem-fun%E5%92%8Cmem-fun-ref"><span class="toc-number">8.3.5.</span> <span class="toc-text">3.5 用于成员函数指针的mem_fun和mem_fun_ref</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=STL源码知识点总结"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=STL源码知识点总结"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL源码知识点总结&body=Check out this article: http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=STL源码知识点总结"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=STL源码知识点总结&description=STL源码知识点总结。"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=STL源码知识点总结"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    ap0l1o
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
