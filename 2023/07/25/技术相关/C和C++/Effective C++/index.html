<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Effective C++知识点总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++总结">
<meta property="og:url" content="http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/index.html">
<meta property="og:site_name" content="ap0l1o">
<meta property="og:description" content="Effective C++知识点总结。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-25T05:05:00.000Z">
<meta property="article:modified_time" content="2023-07-27T01:47:32.164Z">
<meta property="article:author" content="ap0l1o">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/endless.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/endless-192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/endless-180.png">
        
      
    
    <!-- title -->
    <title>Effective C++总结</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="ap0l1o" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 RTL">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/C++Primer/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/07/07/%E5%85%B3%E4%BA%8E%E8%B7%91%E6%AD%A5/%E5%A4%8F%E8%AE%AD%E8%AF%BE%E8%A1%A8/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&text=Effective C++总结"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&is_video=false&description=Effective C++总结"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Effective C++总结&body=Check out this article: http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&name=Effective C++总结&description=Effective C++知识点总结。"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&t=Effective C++总结"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-number">1.</span> <span class="toc-text">一.让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.</span> <span class="toc-text">条款02：尽量以const,enum,inline替换#define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%BB%A5const%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.1.</span> <span class="toc-text">1）以const替换#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BB%A5enum%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.2.</span> <span class="toc-text">2）以enum替换#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%BB%A5inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.3.</span> <span class="toc-text">3）以inline替换#define</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.2.</span> <span class="toc-text">条款03：尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89const%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）const修饰变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89const%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）const修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">3）const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">条款04：确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">二.构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">条款05：了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">2.2.</span> <span class="toc-text">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">条款08：别让异常逃离析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">1）原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">2.4.2.</span> <span class="toc-text">2）如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">条款09：绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-number">2.6.</span> <span class="toc-text">条款10：令operator&#x3D;返回一个reference to *this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operater-%E4%B8%AD%E5%A4%84%E7%90%86%E3%80%8C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E3%80%8D"><span class="toc-number">2.7.</span> <span class="toc-text">条款11：在operater&#x3D;中处理「自我赋值」</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">2.8.</span> <span class="toc-text">条款12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">三.资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">3.1.</span> <span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.</span> <span class="toc-text">条款14：在资源管理类中小心copying行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">3.3.</span> <span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">条款16：成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.5.</span> <span class="toc-text">条款 17：以独立语句将 new 的对象置入智能指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">四.设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">条款18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-number">4.2.</span> <span class="toc-text">条款19：设计class犹如设计type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value"><span class="toc-number">4.3.</span> <span class="toc-text">条款20：宁以pass-by-reference-to-const替换pass-by-value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-number">4.4.</span> <span class="toc-text">条款21：必须返回对象时，别妄想返回其reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-number">4.5.</span> <span class="toc-text">条款22：将成员变量声明为private</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AFpublic"><span class="toc-number">4.5.1.</span> <span class="toc-text">1）为什么不能是public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E9%82%A3%E4%B9%88protected%E8%A1%8C%E4%B8%8D%E8%A1%8C"><span class="toc-number">4.5.2.</span> <span class="toc-text">2）那么protected行不行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">条款23：宁以non-member、non-friend替换member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">条款24：若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">条款25：考虑写出一个不抛出异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">五.实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">5.1.</span> <span class="toc-text">条款26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">5.3.</span> <span class="toc-text">条款28：避免返回handles指向对象内部成分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%A2%9E%E5%8A%A0%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">5.3.1.</span> <span class="toc-text">1）增加封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BD%BF%E5%BE%97%E3%80%8C%E9%80%9A%E8%BF%87const%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%8D%E6%88%90%E4%B8%BA%E5%8F%AF%E8%83%BD"><span class="toc-number">5.3.2.</span> <span class="toc-text">2）使得「通过const修改对象的数据」成为可能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E9%98%B2%E6%AD%A2%E3%80%8C%E8%99%9A%E5%90%8A%E3%80%8D-dangle-%E5%8F%91%E7%94%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">3）防止「虚吊」(dangle)发生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E3%80%8C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E3%80%8D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">5.4.</span> <span class="toc-text">条款29：为「异常安全」而努力是值得的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%842%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text">1）异常安全的2个条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E7%9A%843%E4%B8%AA%E4%BF%9D%E8%AF%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">2）异常安全函数的3个保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.4.3.</span> <span class="toc-text">3）最终目标是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">5.5.</span> <span class="toc-text">条款30：透彻了解inlining的里里外外</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E5%B0%86%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">5.6.</span> <span class="toc-text">条款31：将文件间的编译依存关系将至最低</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">六.继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">条款 32：确定你的 public 继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">6.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">1）继承中的作用域嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%90%8D%E7%A7%B0%E9%81%AE%E6%8E%A9%E4%BC%9A%E9%81%AE%E6%8E%A9%E5%9F%BA%E7%B1%BB%E6%89%80%E6%9C%89%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">6.2.2.</span> <span class="toc-text">2）名称遮掩会遮掩基类所有重载版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89pure-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">1）pure virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89impure-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">2）impure virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.3.</span> <span class="toc-text">3）non-virtual函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35%EF%BC%9A%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">6.4.</span> <span class="toc-text">条款 35：考虑 virtual 函数以外的其他选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%97%89%E7%94%B1Non-Virtual-Interface%E6%89%8B%E6%B3%95%E5%AE%9E%E7%8E%B0Template-Method%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">1）藉由Non-Virtual Interface手法实现Template Method模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%97%89%E7%94%B1Function-Pointers%E5%AE%9E%E7%8E%B0Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">2）藉由Function Pointers实现Strategy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%97%89%E7%94%B1tr1-function%E5%AE%8C%E6%88%90Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.3.</span> <span class="toc-text">3）藉由tr1::function完成Strategy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E4%BC%A0%E7%BB%9F%E7%9A%84Stategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.4.</span> <span class="toc-text">4）传统的Stategy模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">条款36：绝不重新定义继承而来的non-virtual函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">6.6.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96%E3%80%8C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E3%80%8D"><span class="toc-number">6.7.</span> <span class="toc-text">条款 38：通过复合塑模出 has-a 或「根据某物实现出」</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">6.8.</span> <span class="toc-text">条款 39：明智而审慎地使用 private 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89private-%E7%BB%A7%E6%89%BF"><span class="toc-number">6.8.1.</span> <span class="toc-text">1）private 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%A4%8D%E5%90%88"><span class="toc-number">6.8.2.</span> <span class="toc-text">2）复合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.9.</span> <span class="toc-text">条款40：明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">七.模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%9A%E6%80%81"><span class="toc-number">7.1.</span> <span class="toc-text">条款41：了解隐式接口和编译器多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">条款 42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">7.3.</span> <span class="toc-text">条款43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-templates"><span class="toc-number">7.4.</span> <span class="toc-text">条款 44：将与参数无关的代码抽离 templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">条款45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">7.6.</span> <span class="toc-text">条款47：请使用traits classes表现类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE48%EF%BC%9A%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">条款48：认识template元编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete"><span class="toc-number">8.</span> <span class="toc-text">八.定制new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.1.</span> <span class="toc-text">条款49：了解new-handler的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AE%9E%E7%8E%B0-class-%E4%B8%93%E5%B1%9E%E7%9A%84-new-handlers"><span class="toc-number">8.1.1.</span> <span class="toc-text">1）实现 class 专属的 new_handlers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">条款 50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-51%EF%BC%9A%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-number">8.3.</span> <span class="toc-text">条款 51：编写 new 和 delete 时需固守常规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89operator-new-%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">8.3.1.</span> <span class="toc-text">1）operator new 需要遵守的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89operator-delete-%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">8.3.2.</span> <span class="toc-text">2）operator delete 需要遵守的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE52%EF%BC%9A%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete"><span class="toc-number">8.4.</span> <span class="toc-text">条款52：写了placement new也要写placement delete</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Effective C++总结
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ap0l1o</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-07-25T05:05:00.000Z" class="dt-published" itemprop="datePublished">2023-07-25</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> › <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/CS%E5%9F%BA%E7%A1%80/">CS基础</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/C-C/" rel="tag">C/C++</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一.让自己习惯C++"></a>一.让自己习惯C++</h1><h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以<code>const</code>,<code>enum</code>,<code>inline</code>替换<code>#define</code></h2><p><strong>这个条款或许改为「宁可以编译器替换预处理器」比较好</strong></p>
<h3 id="1）以const替换-define"><a href="#1）以const替换-define" class="headerlink" title="1）以const替换#define"></a>1）以<code>const</code>替换<code>#define</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line">替换为：</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>调试的需要</strong>：<code>#define</code>的记号会被预处理器移走，记号名称可能没进入记号表内。因此当<code>#define</code>的宏名称获得一个编译错误时，会引起困惑，浪费大量时间追踪错误。而<code>AspectRatio</code>肯定会被编译器看到</li>
<li><strong>更小的代码量</strong>：对浮点数而言，使用常量可能比使用 <code>#define</code> 导致较小量的代码，因为预处理器「盲目地将 <code>ASPECT_RATIO</code> 替换为 1.653 可能导致目标码出现多份 1.653</li>
</ul>
<p>但是，以常量替换<code>#define</code>时要注意：</p>
<ul>
<li><strong>定义常量指针时：由于常量定义式通常被定义在头文件内，因此有必要将指针声明为const</strong>。如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>class专属常量</strong>：class专属常量需要声明在class内部，并且被class使用：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];          <span class="comment">//使用该常量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通常定义出现在头文件中</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;    <span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于<code>static</code>修饰的class专属整形常量，如果需要对该常量取地址或编译器坚持要看到一个定义式。那么必须提供类外定义。如果类内声明时提供了初始值，类外定义就不能再设初值。但是某些编译器可能不支持类内初始值，因此需要在类外定义时提供初始值，但是这样就不能像<code>scores</code>成员一样，在类内使用该常量。因此，如果需要使用class专属常量，最好改用<code>enum hack</code></p>
<h3 id="2）以enum替换-define"><a href="#2）以enum替换-define" class="headerlink" title="2）以enum替换#define"></a>2）以<code>enum</code>替换<code>#define</code></h3><p>正如上面所提到的，编译器可能不支持类内初始值，因此改用<code>enum hack</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>NumTurns = <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];   <span class="comment">//这就没问题了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>enum hack</code>的行为比较像<code>#define</code>而不像<code>const</code>。例如取一个<code>const</code>的地址时合法的，但取一个<code>enum</code>的地址就不合法，而取一个<code>#define</code>的地址通常也不合法</p>
<h3 id="3）以inline替换-define"><a href="#3）以inline替换-define" class="headerlink" title="3）以inline替换#define"></a>3）以<code>inline</code>替换<code>#define</code></h3><p>以<code>#define</code>实现宏看起来像函数，并且不会导致函数调用带来的开销，但是可能引发错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ?  (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b);       <span class="comment">//a被累加2次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b + <span class="number">10</span>);  <span class="comment">//a被累加1次</span></span><br></pre></td></tr></table></figure>

<p>使用<code>inline</code>函数可以减轻为参数加上括号以及参数被核算多次等问题。同时，<code>inline</code>可以实现一个「类内的<code>private inline</code>函数」，但一般而言宏无法完成此事</p>
<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用<code>const</code></h2><h3 id="1）const修饰变量"><a href="#1）const修饰变量" class="headerlink" title="1）const修饰变量"></a>1）<code>const</code>修饰变量</h3><p>如果变量本身不应该被修改，应该使用 <code>const</code> 修饰。这样编译器可以进行保护，确保这个变量不会被修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;                    <span class="comment">// non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;              <span class="comment">// non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;             <span class="comment">// const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;       <span class="comment">// const pointer, const data </span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果关键字<code>const</code>出现在星号左边，表示被指物是常量</li>
<li>如果出现在星号右边，表示指针自身是常量</li>
</ul>
<h3 id="2）const修饰函数"><a href="#2）const修饰函数" class="headerlink" title="2）const修饰函数"></a>2）<code>const</code>修饰函数</h3><ul>
<li>修饰参数时，和修饰一般变量相同</li>
<li><strong>修饰返回值，可以降低因客户错误而造成的意外</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (a * b = c)&#123; <span class="comment">//其实是想做一个比较动作，使用const修饰返回值可以避免这种错误</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果 a 和 b 都是内置类型。这样的代码直截了当就是不合法。而一个「良好的用户自定义类型」的特征是他们避免与内置类型不兼容。因此对 <code>operator *</code> 的定义应该如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<h3 id="3）const修饰成员函数"><a href="#3）const修饰成员函数" class="headerlink" title="3）const修饰成员函数"></a>3）<code>const</code>修饰成员函数</h3><p><code>const</code>修饰成员函数有2个好处：</p>
<ol>
<li><strong>可读性</strong>：使得接口容易被理解，可以知道哪个函数可以改动对象哪个函数不行</li>
<li><code>const</code>修饰的成员函数可以作用于<code>const</code>对象<br>但是，使用 <code>const</code> 修饰成员函数时需要注意，C++对常量性的定义是 bitwise constness，即函数 <code>const</code> 成员函数不应该修改对象的任何成员变量。因此，如果成员变量是一个指针，那么不修改指针指向而修改指针所指之物，也符合 bitwise constness，因此如果不是从 bitwise constness 的角度，这样也是修改了对象：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span>   <span class="comment">// bitwise constness声明</span></span><br><span class="line">  &#123; <span class="keyword">return</span> pText[position]; &#125;                    <span class="comment">// 但其实不恰当</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; <span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>];            <span class="comment">//调用const operator[]取得一个指针，</span></span><br><span class="line">                                <span class="comment">//指向cctb的数据</span></span><br><span class="line">*pc = <span class="string">&#x27;J&#x27;</span>;                      <span class="comment">//cctb现在有了「Jello」这样的内容</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>还有一种logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> *pText;</span><br><span class="line">  std::<span class="keyword">size_t</span> textLength;         <span class="comment">// 最近一次计算的文本区块长度</span></span><br><span class="line">  <span class="keyword">bool</span> lengthIsValid;             <span class="comment">// 目前的长度是否有效</span></span><br><span class="line">&#125;;                                     </span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!lengthIsValid) &#123;                 </span><br><span class="line">    textLength = std::<span class="built_in">strlen</span>(pText);    <span class="comment">//错误！在const成员函数内不能复制给</span></span><br><span class="line">    lengthIsValid = <span class="literal">true</span>;               <span class="comment">//textLength和lengthIsValid</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，C++对常量性的定义是bitwise constness的，所以这样的操作非法。解决办法是使用<code>mutable</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> *pText;</span><br><span class="line">  <span class="keyword">mutable</span> std::<span class="keyword">size_t</span> textLength;         <span class="comment">// 这些成员变量可能总是会被更改</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;             <span class="comment">// 即使在const成员函数内</span></span><br><span class="line">&#125;;                                     </span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!lengthIsValid) &#123;                 </span><br><span class="line">    textLength = std::<span class="built_in">strlen</span>(pText);    <span class="comment">//现在可以这样</span></span><br><span class="line">    lengthIsValid = <span class="literal">true</span>;               <span class="comment">//也可以这样</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，上面提到了 2 种「修改」 <code>const</code> 成员函数中修改对象（修改 <code>const</code> 对象）的方法。<br>最后，<code>const</code> 和 <code>non-cons</code>t 版本的函数可能含有重复的代码，如果抽离出来单独成为一个成员函数还是有重复。如果希望去重，可以使用「运用 <code>const</code> 成员函数实现出其 <code>non-const</code> 孪生兄弟」的技术：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">                [pos]   </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p><strong>读取未初始化对象的后果</strong>：读取未被初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值就可能让程序终止，更可能的情况是读入一些「半随机」bits，污染了正在进行读取动作的那个对象，最终导致不可预知的程序行为，以及许多令人不愉快的调试过程。<br>按对象的类型划分：</p>
<ul>
<li><strong>对于内置类型的对象</strong>：永远在使用前初始化</li>
<li><strong>类类型的对象</strong>：初始化责任落在构造函数身上<ul>
<li><strong>效率上的问题</strong>：<ul>
<li>类类型成员的初始化动作发生在构造函数本体之前。比起先调用<code>default</code>构造函数然后再调用<code>copy assignment</code>操作符，单只调用一次<code>copy</code>构造函数比较高效。因此，善用初始化列表有助于提升效率</li>
<li>内置类型成员的初始化不一定发生在赋值动作的的时间点之前。对于内置类型成员，一般为了保持一致也在初始化列表中给出初始值</li>
</ul>
</li>
<li><strong>初始化顺序</strong>：成员的初始化顺序与类内声明顺序相同</li>
</ul>
</li>
</ul>
<p>按对象的作用域与生命周期划分：</p>
<ul>
<li><strong><code>static</code>对象</strong><ul>
<li><strong><code>non-local static</code> 对象</strong>：C++对「定义于不同的编译单元内的 <code>non-local static</code> 对象」的初始化相对次序并无明确定义<ul>
<li><code>global</code> 对象</li>
<li>定义于 <code>namespace</code> 作用域内的对象</li>
<li><code>classes</code> 内、file 作用域内被声明为 <code>static</code> 的对象</li>
</ul>
</li>
<li><strong><code>local static</code> 对象</strong>：函数内的 <code>local static</code> 对象会在「该函数被调用期间、首次遇上该对象的定义式」时被初始化<ul>
<li>函数内被声明为 <code>static</code> 的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，如果一个 <code>non-local static</code> 对象的初始化依赖于另外一个 <code>non-local static</code> 的初始化，那么可能造成错误。解决方法是使用 <code>local static</code> 对象替换 <code>non-local static</code> 对象（参考单例模式）。</p>
<h1 id="二-构造-析构-赋值运算"><a href="#二-构造-析构-赋值运算" class="headerlink" title="二.构造/析构/赋值运算"></a>二.构造/析构/赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>一般情况下，编译器会为类合成下列函数：</p>
<ul>
<li><strong><code>default</code>构造函数</strong></li>
<li><strong><code>copy</code>构造函数</strong>：编译器生成的版本只是单纯地将来源对象的每一个<code>non-static</code>成员变量拷贝到目标对象</li>
<li><strong><code>copy assignment</code> 操作符</strong>：编译器生成的版本只是单纯地将来源对象的每一个 <code>non-static</code> 成员变量拷贝到目标对象；</li>
<li><strong>析构函数</strong>：编译器生成的版本是 <code>non-virtual</code> 的。</li>
</ul>
<blockquote>
<p><a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.md#%E7%AC%AC2%E7%AB%A0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E6%84%8F%E5%AD%A6">更深层次的理解</a>（对象模型第 2 章、第 5 章）</p>
</blockquote>
<p>以下情况编译器不会合成<strong>copy assignment操作符</strong>：</p>
<ul>
<li><strong>含有引用成员</strong>：原因在于这种情况下，赋值的目的不明确。是修改引用还是修改引用的对象？如果是修改引用，这是被禁止的。因此编译器干脆拒绝这样的赋值行为；</li>
<li><strong>含有 const 成员</strong>：const 对象不应该修改；</li>
<li><strong>父类的 copy assignment 操作符被声明为 private</strong>：无法处理基类子对象，因此也就无法合成；</li>
</ul>
<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为什么要拒绝</strong>？比如，房产应该是独一无二的，这种情况下应该拒绝对象拷贝动作。<br>一般情况下，不声明相应函数即可拒绝。但是编译器会为类合成一些函数，因此需要显式拒绝。<br>还是以拒绝对象拷贝为例子，拒绝方法包括：</p>
<ol>
<li><strong>将 <code>copy</code> 构造函数或 <code>copy assignment</code> 操作符声明为 <code>private</code>，并且不定义</strong>（这被用于 C++ <code>iostream</code> 程序库中）；<ul>
<li>这种情况下 <code>member</code> 函数和 <code>friend</code> 函数还是可以调用，如果 <code>member</code> 函数或 <code>friend</code> 函数中执行了复制，会引发<strong>链接错误</strong>。<strong>可以使用一个基类，在基类中将 <code>copy</code> 构造函数或 <code>copy assignment</code> 操作符声明为 <code>private</code>，并且继承这个基类</strong>。这样可以将<strong>链接错误</strong>移至<strong>编译期</strong>，因为尝试拷贝时，编译器会试着生成一个 <code>copy</code> 构造函数和一个 <code>copy assignment</code> 操作符，这些函数的「编译器合成版」会尝试调用其基类的对应兄弟，而那些调用会被编译器拒绝，因为 <code>private</code>；</li>
</ul>
</li>
<li><strong>使用 delete</strong>（这个在书中没有提到）；</li>
</ol>
<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h2><ul>
<li><strong>为基类声明  <code>virtual</code>  析构函数</strong>：当派生类对象经由一个基类指针被删除，而该基类带有一个 <code>non-virtual</code> 析构函数，结果未定义——实际执行时通常发生的是对象的 <code>derived</code> 成分没有销毁，即「局部销毁」，造成资源泄露（因为存在这个问题，所以不要继承一个不被用作基类的类）；</li>
<li><code>class</code> 不用作基类时，不要将析构函数声明为 <code>virtual</code> ：<code>virtual</code> 会引入虚函数指针，这会增加空间开销，使得类无法被 C 函数使用，从而不再具有移植性；</li>
</ul>
<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><strong>C++并不禁止析构函数吐出异常，但是并不鼓励这样做</strong></p>
<h3 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h3><p>如果析构函数吐出异常，程序可能过早结束（比如某个函数调用发生异常，在回溯寻找<code>catch</code>过程中，每离开一个函数，这个函数内的局部对象会被析构，如果此时析构函数又抛出异常，前一个异常还没得到处理又来一个，因此一般会引起程序过早结束）。异常从析构函数中传播出去，可能会导致不明确的行为</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28592504">知乎相关描述</a></p>
</blockquote>
<h3 id="2）如何解决"><a href="#2）如何解决" class="headerlink" title="2）如何解决"></a>2）如何解决</h3><ol>
<li>在析构函数中<code>catch</code>异常，然后调用<code>abort</code>终止程序。通过<code>abort</code>抢先置「不明确行为」于死地</li>
<li>在析构函数中<code>catch</code>异常，然后记录该失败，即<strong>吞掉异常</strong>（通常是个坏主意，因为这样压制了「某些动作失败」的重要信息。但是也比负担「草率结束程序」或」不明确行为带来的风险「好）</li>
<li>重新设计接口，让客户能够在析构前主动调用可能引起异常的函数，然后析构函数中使用一个<code>bool</code>变量，根据用户是否主动调用来决定析构函数中是否应该调用可能引起异常的函数，<strong>让客户拥有主动权</strong>（如果客户没有主动调用，那么当发生异常时也不应该抱怨，因为已经给出了客户自己处理异常的机会）</li>
</ol>
<h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用<code>virtual</code>函数</h2><p>如果希望在继承体系中根据类型在构建对象时表现出不同行为，可以会想到在基类的构造函数中调用一个虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span>                           <span class="comment">//所有交易的基类</span></span><br><span class="line"><span class="keyword">public</span>:                                           </span><br><span class="line">    <span class="built_in">Transaction</span>()&#123;           </span><br><span class="line">        ...                           </span><br><span class="line">        <span class="built_in">logTransaction</span>();                         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//做出一份因类型不同而不同的日志记录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;        <span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;      <span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>但是最终调用的 <code>virtual</code> 函数都是基类的版本。同时，因为是纯虚函数，除非定义该函数，否则将报链接错误。</strong><br><strong>在子类构造期间，<code>virtual</code> 函数绝不会下降到派生类阶层。取而代之的是，对象的作为就像隶属基类类型一样。即派生类对象的基类构造期间，对象的类型是基类而不是派生类；除此之外，若使用运行期类型信息</strong>（如 <code>dynamic_cast</code> 和 <code>typeid</code>），也会把对象视为基类类型（这样对待是合理的：因为子类部分尚未初始化，如果调用的是子类的虚函数，通常会访问子类部分的数据，会引发安全问题）。<br><strong>同样的道理也适用于析构函数。一旦派生类析构函数开始执行，对象内的派生类成员变量便呈现未定义值，所以 C++视它们仿佛不再存在。进入基类析构函数后对象就成为一个基类对象</strong>。<br>如果希望实现最初的功能，即根据类型产生不同日志记录，那么可以在派生类的成员初始化列表中，向基类传递一些类型相关的信息，基类构造函数根据这些信息生成不同的日志记录，此时日志记录的生成函数不再是 <code>virtual</code> 函数。</p>
<h2 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令<code>operator=</code>返回一个<code>reference to *this</code></h2><p><strong>这是为了实现「连锁赋值」</strong>。这个协议除了适用于 <code>operator=</code>，还适用于 <code>+=</code>、<code>-=</code>、<code>*=</code>。</p>
<blockquote>
<p>这只是个协议，并无强制性，如果不遵循，代码一样可通过编译。</p>
</blockquote>
<h2 id="条款11：在operater-中处理「自我赋值」"><a href="#条款11：在operater-中处理「自我赋值」" class="headerlink" title="条款11：在operater=中处理「自我赋值」"></a>条款11：在operater=中处理「自我赋值」</h2><p>考虑如下Widget类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *pb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面的<code>operator=</code>实现是一份不安全的实现，在自赋值时会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; </span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要处理自赋值，可以有以下几种方式：</p>
<ol>
<li><p><strong>在开头添加「证同测试」</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">        pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这样做虽然能处理自赋值，但不是异常安全的，如果 `new` 时发生异常，对象的 `pb` 将指向一块被删除的内存。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过确保异常安全来获得自赋值的回报</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap *pOrig = pb;               <span class="comment">// remember original pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);         <span class="comment">// make pb point to a copy of *pb</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;                     <span class="comment">// delete the original pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在，如果new失败，pb会保持原状。同时也能处理自赋值。如果担心效率可以在开头加上「证同测试」。但是if判断也会引入开销，因此需要权衡自赋值发生的频率</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用<code>copy and swap</code>技术</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为pass by reference</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);               <span class="comment">// swap *this&#x27;s data with</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">// the copy&#x27;s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为pass by value</span></span><br><span class="line"><span class="comment">//这种方式的缺点是代码不够清晰，但是将「copying动作「从函数本体内移至」函数参数构造阶段」</span></span><br><span class="line"><span class="comment">//却可令编译器有时生成更高效的代码</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);                <span class="comment">// swap *this&#x27;s data with</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">// the copy&#x27;s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>如果声明自己的 <code>copying</code> 函数，意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的，会以一种奇怪的方式回敬：如果你自己写出的 <code>copying</code> 函数代码不完全，它也不会告诉你。</p>
<ul>
<li><strong><code>copy</code>构造函数</strong><ul>
<li><strong>非继承中</strong>：当为类添加一个新成员时，<code>copy</code> 构造函数也需要为新成员添加拷贝代码。否则会调用新成员的默认构造函数初始化新成员；</li>
<li><strong>继承中</strong>：在派生类的 <code>copy</code> 构造函数中，不要忘记调用基类的 <code>copy</code> 构造函数拷贝基类部分。否则会调用基类的默认构造函数初始化基类部分；</li>
</ul>
</li>
<li><strong><code>copy</code>赋值运算符</strong><ul>
<li><strong>非继承中</strong>：当为类添加一个新成员时，<code>copy</code> 赋值运算符中也需要为新成员添加赋值代码，否则新成员会保持不变；</li>
<li><strong>继承中</strong>：在派生类的 <code>copy</code> 赋值运算符中，不要忘记调用基类的 <code>copy</code> 赋值运算符，否则基类部分会保持不变；</li>
</ul>
</li>
</ul>
<h1 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p>当申请一块动态内存时，可能会发生泄漏：</p>
<ul>
<li>**忘记 <code>delete</code>**；</li>
<li><strong>有<code>delete</code>，但是<code>delete</code>之前跳出控制流</strong>：在代码的维护过程中，动态分配内存和<code>delete</code>之间可能会加入<code>return</code>之类的控制流变更语句，或者是可能引发异常的代码，这样可能会使程序执行不到<code>delete</code>从而造成资源泄露</li>
</ul>
<p><strong>总结起来就是，手工 <code>delete</code> 一个是需要时刻记住 <code>delete</code>，增加编码负担，另一个是即使明确 <code>delete</code>，在 <code>delete</code> 之前控制流可能发生改变从而还是会造成资源泄露</strong>。<br>因此，<strong>一个好的办法是使用对象管理资源，包括下列两个关键想法</strong>：</p>
<ul>
<li><strong>获得资源后立刻放进管理对象</strong>：「以对象管理资源」的观念常被称为「资源取得时机便是初始化时机」(<strong>RAII</strong>)；</li>
<li><strong>管理对象运用析构函数确保资源被释放</strong>；</li>
</ul>
<p>一个对象管理资源的例子是<code>auto_ptr</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pIntv</span><span class="params">(createInvestment())</span></span>;    </span><br><span class="line">    ...     </span><br><span class="line">&#125;           <span class="comment">//经由auto_ptr的析构函数自动删除pInv</span></span><br></pre></td></tr></table></figure>

<p>对于<strong>对象管理资源，需要注意对象的复制行为</strong>：例如，复制逻辑可能是多个对象管理相同的资源，那么析构时就会重复 <code>delete</code>。因此，如果是这种复制逻辑，那么应该引入引用计数，析构时根据引用计数决定是否 <code>delete</code>。否则，一个资源就应该只由一个对象来管理，那么复制时就原来对象管理的资源就应该修改成 <code>null</code>，而复制所得的新对象将取得资源的唯一拥有权（如 <code>auto_ptr</code>）。  </p>
<blockquote>
<p>C++没有特别针对「动态分配数组」而设计的类似 <code>auto_ptr</code> 或 <code>tr1:: shared_ptr</code> 那样的东西，甚至 TR1 中也没有。那是因为 <code>vector</code> 和 <code>string</code> 几乎总是可以取代动态分配而得的数组。因此当需要动态分配数组时，提倡使用 <code>vector</code>（<a href="C++Primer.md#23-unique_ptr">可以使用<code>unique_ptr</code>管理动态数组</a>）。</p>
</blockquote>
<h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>并非所有资源都是动态内存，除此之外还有锁等资源，也应该通过「对象管理资源」来确保获取资源后能够正确的释放，<strong>根据资源的类型，和不同的需求，可能需要定义不同的 <code>copy</code> 行为</strong>：</p>
<ol>
<li><strong>禁止复制</strong>：比方说锁资源，管理锁资源的对象复制通常并不合理。因此应该禁止这类对象的复制，可以通过继承一个 <code>copying</code> 操作被声明为 <code>private</code> 的基类来禁止复制，这点在条款 06 中有提到；</li>
<li><strong>对底层资源使用「引用计数法」</strong>：如果希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制 <code>RAII</code> 对象时，应该将资源的「被引用数」递增。<code>tr1:: shared_ptr</code> 便是如此（当资源引用计数减为 0 时，如果不希望删除资源，比方说锁资源，可以使用 <code>shared_ptr</code> 的「删除器」）；</li>
<li><strong>复制底部资源</strong>：这种情况下，希望在复制 <code>RAII</code> 对象时，同时复制其关联的底层资源。展现出一种「深拷贝」的行为；</li>
<li><strong>转移底部资源的拥有</strong>：如果希望任一时刻一个资源只由一个 RAII 对象管理，那么在复制 RAII 对象时，应该实现拥有权的「转移」，原 <code>RAII</code> 对象拥有的资源设为 <code>null</code>（如 <code>auto_ptr</code>）；</li>
</ol>
<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>API 往往要求访问原始资源（即被 RAII 对象管理的资源，而不是直接访问 RAII 对象），所以每一个 RAII 类应该提供一个「取得其所管理的资源」的办法</strong>。<br>取得 RAII 对象所管理资源的办法可以通过显式转换或隐式转换：</p>
<ul>
<li>**显式转换(比较安全，但不易用)**：如<code>shared_ptr</code>的<code>get()</code>方法</li>
<li>**隐式转换 (比较易用，但不安全)**：如 <code>shared_ptr</code> 的 <code>operator *</code>和 <code>operator-&gt;</code></li>
</ul>
<p>如果通过实现隐式转换（比如，实现<code>operator()</code>）来提供对元素资源的访问，可能不安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下，Font是一个RAII对象，FontHandle是一个原始资源</span></span><br><span class="line"></span><br><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;  </span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1; <span class="comment">//原意是想使用Font，复制一个RAII对象</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，如果实现了隐式转换，底层资源会被复制，如果 f1 销毁，f2 会成为「虚吊的」（dangle）。<br>是否该提供一个显式转换函数将 RAII 转换为其底层资源，或是应该提供隐式转换，答案主要取决于 RAII 被设计执行的特定工作，以及它被使用的情况。</p>
<h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用<code>new</code>和<code>delete</code>时要采取相同形式</h2><p>当使用<code>new</code>和<code>delete</code>时，发生2件事</p>
<ul>
<li><code>new</code><ul>
<li>内存被分配出来（通过名为 <code>operator new</code> 的函数）；</li>
<li>针对此内存会有一个（或更多）构造函数被调用；</li>
</ul>
</li>
<li><code>delete</code><ul>
<li>针对此内存会有一个（或更多）析构函数被调用；</li>
<li>内存被释放（通过名为 <code>operator delete</code> 的函数）；</li>
</ul>
</li>
</ul>
<p>单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括「数组大小」的记录，以便 <code>delete</code> 知道需要调用多少次析构函数。<br><strong>当使用 <code>delete</code> 时，唯一能够让 <code>delete</code> 知道内存中是否存在一个「数组大小记录」的办法是，由你来告诉它。即加上 <code>[]</code>，<code>delete</code> 便认为指针指向一个数组，否则它便认为指针指向单一对象</strong>。<br>因此，应该像这样使用 <code>new</code> 和 <code>delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string* stringPtr1 = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string* stringPtr2 = <span class="keyword">new</span> std::string[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span> [] stringPtr2;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对 <code>stringPtr1</code> 使用 <code>delete []</code> 形式，结果未定义，但不太可能让人愉快。假设内存布局上，<code>delete</code> 会读取若干内存并将它解释为「数组大小」，然后开始多次调用析构函数，浑然不知它所处理的那块内存不但不是个数组，也或许并未持有它正忙着销毁的那种类型的对象；</li>
<li>如果没有对 <code>stringPtr2</code> 使用 <code>delete []</code> 形式，结果亦未定义，但可以猜想可能导致太少的析构函数被调用。犹有进者，这对内置类型如 <code>int</code> 者亦未定义，即使这类类型并没有析构函数；</li>
</ul>
<p>因此，**如果调用 <code>new</code> 时使用了 <code>[]</code>，必须在对应调用 <code>delete</code> 时也使用 <code>[]</code>；如果调用 <code>new</code> 时没使用 <code>[]</code>，那么也不该在对应调用 <code>delete</code> 时使用 <code>[]</code>**。<br>这点在 <code>typedef</code> 中尤其需要注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];        <span class="comment">//每个人的地址有4行，每行是一个string</span></span><br><span class="line"></span><br><span class="line">std::string *pa1 = <span class="keyword">new</span> AddressLines;        <span class="comment">//就像new string[4]一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pa1;             <span class="comment">//错误！行为未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pa1;          <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<p>为避免这类错误，最好尽量不要对数组形式做 <code>typedef</code> 动作。</p>
<h2 id="条款-17：以独立语句将-new-的对象置入智能指针"><a href="#条款-17：以独立语句将-new-的对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 new 的对象置入智能指针"></a>条款 17：以独立语句将 <code>new</code> 的对象置入智能指针</h2><p>考虑如下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func1</span>(std::tr1::shared_ptr&lt;原始资源类&gt;(<span class="keyword">new</span> 原始资源类),<span class="built_in">func2</span>());</span><br></pre></td></tr></table></figure>

<p>在调用<code>func1</code>之前，编译器必须创建代码，做以下3件事</p>
<ul>
<li>执行 <code>func2</code>；</li>
<li>执行<code>new</code> 原始资源类创建一个原始资源；</li>
<li>调用 <code>tr1::shared_ptr</code> 构造函数；</li>
</ul>
<p>但是执行顺序弹性很大。如果执行顺序如下；</p>
<ol>
<li>执行 <code>new</code> 原始资源类创建一个原始资源；</li>
<li>执行 <code>func2</code>；</li>
<li>调用 <code>tr1::shared_ptr</code> 构造函数；</li>
</ol>
<p>现在，如果2发生异常，那么因为1创建的资源未被置入<code>tr1::shared_ptr</code>内，因此会发生内存泄露。也就是说，在「资源被创建」和「资源被转换为资源管理对象」两个时间点之间有可能发生异常干扰。因此，应该使用独立语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tr1::shared_ptr&lt;原始资源类&gt;(<span class="keyword">new</span> 原始资源类) p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func1</span>(p,<span class="built_in">func2</span>());</span><br></pre></td></tr></table></figure>

<h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><ol>
<li><strong>通过引入新类型来防止误用</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span> month,<span class="keyword">int</span> day,<span class="keyword">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 上面日期类的构造函数中，年月日都是 <code>int</code>，那么很容易传入顺序错误的参数。因此，可以因为 3 个表示年月日的新类：Year、Month、Day。从而防止这种问题。更进一步，为了使得传入的数据有效，比如月份，可以设计生成 12 个月份对象的 <code>static</code> 成员函数，并将构造函数声明为 <code>private</code> 强制要求通过调用 <code>static</code> 成员函数得到月份对象。使用 <code>enum</code> 没有那么安全，<code>enum</code> 可被拿来当作一个 <code>int</code> 使用；</li>
<li><strong>除非有好的理由，否则应该尽量让你的 <code>type</code> 的行为与内置类型一致</strong>：如 <code>if(a * b = c)</code> 对内置类型来说不合法，那么你的 <code>type</code> 在实现 <code>operator *</code>时就应该返回一个 <code>const</code> 对象；</li>
<li><strong>提供一致的接口</strong>：如 C++ STL 容器都提供 <code>size()</code> 返回容器大小，但是 Java 和. Net 对于不同容器大小接口可能不同，这会增加使用负担；</li>
<li><strong>返回「资源管理对象」而不是原始资源</strong>：如用 <code>shared_ptr</code> 管理资源时，客户可能会忘记使用智能指针，从而开启了忘记释放和重复释放的大门。通过修改接口的返回类型为智能指针，从而确保元素资源处于「资源管理对象」的掌控之中；</li>
</ol>
<h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计<code>class</code>犹如设计<code>type</code></h2><p>在设计<code>class</code>时，下列问题将导致<code>class</code>你的设计规范：</p>
<ul>
<li>新<code>type</code>的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新<code>type</code>的对象如果被<code>passed by value</code>，意味着什么？</li>
<li>什么是新<code>type</code>的「合法值」？</li>
<li>你的新<code>type</code>需要配合某个继承体系吗？</li>
<li>你的新<code>type</code>需要什么样的转换？</li>
<li>什么样的操作符和函数对此新<code>type</code>而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新<code>type</code>的成员？</li>
<li>什么是新<code>type</code>的「未声明接口」？</li>
<li>你的新<code>type</code>有多么一般化？</li>
<li>你真的需要一个新<code>type</code>吗？</li>
</ul>
<h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以<code>pass-by-reference-to-const</code>替换<code>pass-by-value</code></h2><p><code>pass-by-reference-to-const</code>有下列好处：</p>
<ul>
<li><strong>更高的效率</strong>：如果一个类处于继承体系的底部，并且包含大量成员，<code>pass-by-value</code> 会导致大量的构造函数被调用，在函数调用完成后，又有大量的析构函数被调用；</li>
<li><strong>防止继承中的对象切割</strong>：如果是 <code>pass-by-value</code>，并且传入一个子类对象时，传入的子类对象会被切割，只保有基类对象的部分，从而无法表现多态；</li>
</ul>
<p><code>reference</code> 往往以指针实现出来，因此 <code>pass by reference</code> 通常意味真正传递的是指针。因此，<strong>对于内置类型，<code>pass by value</code> 往往比 <code>pass by reference</code> 的效率更高</strong>。**<code>pass by value</code> 同样适用于 STL 的迭代器和函数对象**。<br>并不是所有小型对象都是 <code>pass-by-value</code> 的合格候选者：</p>
<ul>
<li>对象小并不意味着 <code>copy</code> 构造函数不昂贵。许多对象——包括大多数 STL 容器——内含的东西比一个指针多一些，但是复制这种对象却需承担「复制那些指针所指的每一样东西」。那将非常昂贵；</li>
<li>即使 <code>copy</code> 构造函数不昂贵，还是可能有效率上的争议。某些编译器对待「内置类型」和「用户自定义类型」的态度截然不同，纵使两者拥有相同的底层表述，「用户自定义类型」也不会被编译器放入缓存器，因此 <code>pass by reference</code> 更适合；</li>
</ul>
<blockquote>
<p>可以合理假设「<code>pass-by-value</code> 并不昂贵」的唯一对象就是内置类型和 STL 的迭代器和函数对象。其它任何时候，宁以 <code>pass-by-reference-to-const</code> 替换 <code>pass-by-value</code>。</p>
</blockquote>
<h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其<code>reference</code></h2><p>必须返回对象的最常见例子是运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure>

<p>在必须返回对象时，不要企图返回<code>reference</code>，可以通过反面来说，也就是如果返回<code>reference</code>会是什么情况？</p>
<ul>
<li>**在 <code>stack</code> 上构造一个局部对象，返回局部对象的 <code>reference</code>**；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n,lhs.d * rhs.d)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  注意！使用 <code>reference</code> 的本意是避免构造新对象，但是一个新的对象 <code>result</code> 还是经由构造函数构造。更严重的是，这个局部对象在函数调用完成后就被销毁了，<code>reference</code> 将指向一个被销毁的对象。</li>
<li>**在 <code>heap</code> 上构造一个局部对象，返回这个对象的 <code>reference</code>**；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational *result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);</span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line">Rational w,x,y,z;</span><br><span class="line">w = x * y *z;</span><br></pre></td></tr></table></figure>
  这样虽然 <code>reference</code> 不再引用一个被销毁的对象，但是因为了动态内存分配的开销，而且谁该为 <code>delete</code> 负责也成为问题。同时，在上面的连乘例子中，会多次动态分配内存，但是只返回最后一次的指针，因此会造成资源泄露。</li>
<li><strong>构造一个<code>static</code>局部对象，每次计算结果保存在这个对象中，返回其<code>reference</code></strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Rational result</span><br><span class="line">    result = ...;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">Rational w,x,y,z;</span><br><span class="line"><span class="keyword">if</span>((w * x) == (y * z))&#123;...&#125;</span><br></pre></td></tr></table></figure>
  首先，显而易见的问题是这个函数在多线程情况下是不安全的，多个线程会修改相同的 <code>static</code> 对象；除此之外，在上面的 <code>if</code> 判断中，不管传入的 <code>w,x,y,z</code> 是什么，由于 <code>operator*</code> 传回的 <code>reference</code> 都指向同一个 <code>static</code> 对象，因此上面的判断永远都会为 <code>true</code>。</li>
</ul>
<h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><h3 id="1）为什么不能是public"><a href="#1）为什么不能是public" class="headerlink" title="1）为什么不能是public"></a>1）为什么不能是public</h3><p>3个原因：</p>
<ol>
<li><strong>语法一致性</strong>：如果成员变量和成员函数一样，都是<code>public</code>，那么调用时会困惑于该不该使用括号。如果想获取大小时使用<code>size</code>，但是这到底是一个成员变量还是一个成员函数？</li>
<li><strong>更精准的控制</strong>：通过将成员变量声明为<code>private</code>，通过成员函数提供访问，可以实现更精准的访问控制 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLevels</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="keyword">const</span>   </span>&#123;<span class="keyword">return</span> readOnly;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="keyword">int</span> value)</span>    </span>&#123;readWrite = value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="keyword">const</span>    </span>&#123;<span class="keyword">return</span> readWrite;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="keyword">int</span> value)</span>    </span>&#123;writeOnly = value;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> noAccess;   <span class="comment">//对此int无访问动作</span></span><br><span class="line">    <span class="keyword">int</span> readOnly;   <span class="comment">//对此int做只读访问</span></span><br><span class="line">    <span class="keyword">int</span> readWrite;  <span class="comment">//对此int做读写访问</span></span><br><span class="line">    <span class="keyword">int</span> writeOnly;  <span class="comment">//对此int做只写访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>**封装 (主要)**：<code>private</code> 将成员变量封装，如果通过 <code>public</code> 暴露，在需要改成员变量的大量实现代码中，当这个成员变量被修改或删除时，所有直接访问该成员变量的代码将会变得不可用；</li>
</ol>
<h3 id="2）那么protected行不行"><a href="#2）那么protected行不行" class="headerlink" title="2）那么protected行不行"></a>2）那么<code>protected</code>行不行</h3><p><code>protected</code> 成员变量和 <code>public</code> 成员变量的论点十分相同。「语法一致性」和「细微划分的访问控制」等理由也适用于 <code>protected</code> 数据。同时，**<code>protected</code> 也并不具备良好的封装性<strong>。<br>假设有一个 <code>public</code> 成员变量，而我们最终取消了它。所以使用它的客户代码都会被破坏。因此，<code>public</code> 成员变量完全没有封装性。假设有一个 <code>protected</code> 变量，而我们最终取消了它，所有使用它的派生类都会被破坏。因此，<code>protected</code> 成员变量也缺乏封装性。<br>因此，</strong>从封装的角度看，只有 <code>private</code> 能提供封装性**。</p>
<h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以<code>non-member</code>、<code>non-friend</code>替换<code>member</code>函数</h2><p>假设有个浏览器类，包含一些功能用来清除下载元素高速缓冲区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCookies</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，如果想整个执行所有这些动作，那么有两种选择，一种实现成<code>member</code>函数，一种实现成<code>non-member</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//实现成成员函数，能访问private成员</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">clearCache</span>();</span><br><span class="line">    <span class="built_in">clearCookies</span>();</span><br><span class="line">    <span class="built_in">clearHistory</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者实现成非成员函数，不能访问private成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123;</span><br><span class="line">  wb.<span class="built_in">clearCache</span>();</span><br><span class="line">  wb.<span class="built_in">clearCookies</span>();</span><br><span class="line">  wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题是应该如何选择？这个问题主要在于<strong>封装性</strong>。<br>如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。<strong>越少人看到它，就有越大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物</strong>。<br>因此，对于对象内的代码。越少代码可以看到数据（也就是访问它），越多的数据可被封装，我们也就越能自由地改变对象数据。作为一种粗糙的测量，越多函数可访问它，数据的封装性就越低。<br>条款 22 所说，成员变量应该是 <code>private</code>。能够访问 <code>private</code> 成员变量的函数只有 <code>class</code> 的 <code>member</code> 函数加上 <code>friend</code> 函数而已。<strong>如果要在一个 <code>member</code> 函数和一个 <code>non-member</code>，<code>non-friend</code> 函数之间做选择，而且两者提供相同机能，那么，导致较大封装性的是 <code>non-member</code>，<code>non-friend</code> 函数</strong>，也就是本条款这样选择的原因。  </p>
<h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>为<code>class</code>支持隐式类型转换不是个好主意，但是在数值类型之间颇为合理。考虑有理数和内置整形之间的相乘运算。具有如下有理数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Rational</span>(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">1</span>); <span class="comment">//构造函数刻意不为explicit，提供了Int-to-Rational的隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//分子的访问函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//分母的访问函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，有理数提供了 Int-to-Rational 的隐式转换方式，那么 <code>operator*</code> 应该实现成 <code>member</code>，还是 <code>non-member</code>？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//实现为member</span></span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现为non-member</span></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p><strong>问题发生在混合运算上。如果实现成member，那么下面的混合运算只有一半行得通</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;                  <span class="comment">// OK</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;                  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>因为内置类型 <code>int</code> 并没有相应的 <code>class</code>，也就没有 <code>operator*</code>成员函数。所以后者会出错。但是当实现为 <code>non-member</code> 时，具有 2 个参数，都能通过 <code>int</code> 转换为 <code>Rational</code>，所以上面 2 行代码都能运行。因此，若所有参数皆需类型转换，请为此采用 <code>non-member</code> 函数。</p>
<h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p>「以指针指向一个对象，内含真正数据」。这种设计的常见表现形式是所谓的「PIMPL （Pointer to IMPLementation）手法」。如下，WidgetImpl 包含了 Widget 的真正数据，而 Widget 只包含一个 WidgetImpl 类型的指针，指向一个 WidgetImpl 对象。这种设计特点，决定了 Widget 的 copying 行为应该表现出一种「深拷贝」的行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// Widget真正的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	    <span class="comment">// todo</span></span><br><span class="line">        *impl = *(rhs.impl);</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，如果使用标准库的 <code>swap</code> 交换 2 个 Widget 对象，会引起 WidgetImpl 对象的拷贝，由于其内含有 Widget 的大量数据，因此效率可能十分低。<strong>实际上这种情况下，交换 2 个指针就可以了</strong>。为此，我们可能实现出 <code>swap</code> 特化版来提升效率，但是由于其内直接访问 Widget 的 <code>private</code> 成员，因此无法通过编译。所以我们采用下图右下角的方案，在 Widget 类内实现一个 <code>public</code> 的 <code>swap</code> 函数，然后特化版的 <code>swap</code> 调用这个 <code>public</code> 的 <code>swap</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        impl = rhs.impl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(impl, other.impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版的标准库swap</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; lhs, Widget&amp; rhs) &#123;</span><br><span class="line">        lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来就是：</p>
<ul>
<li>首先，如果<code>swap</code>的缺省实现对你的<code>class</code>或<code>class template</code>提供可接受的效率，那不需要做额外的事</li>
<li>否则，如果<code>swap</code>的缺省实现效率不足（那几乎总是意味着你的<code>class</code>或<code>template</code>使用了某种<code>pimpl</code>手法），试着做以下事情：<ul>
<li>提供一个 <code>public swap</code> 成员函数，让它高效地置换你的类型的两个对象的值（<strong>这个 <code>public swap</code> 成员函数绝不应该抛出异常。这个约束不可施行于非成员版，因为 <code>swap</code> 缺省版是以 <code>copy</code> 构造函数和 <code>copy assignment</code> 操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的 <code>swap</code>，往往提供的不只是高效置换对象值的方法，而且不抛出异常。一般而言这两个 <code>swap</code> 特性是连在一起的，因为高效的 <code>swap</code> 几乎总是基于对内置类型的操作，而内置类型上的操作绝对不会抛出异常</strong>）</li>
<li>在你的 <code>class</code> 或 <code>template</code> 所在的命名空间内提供一个 <code>non-member swap</code>，并令它调用上述 <code>swap</code> 成员函数</li>
<li>如果你正编写一个 <code>class</code>（而非 <code>class template</code>），为你的 <code>class</code> 特化 <code>std::swap</code>。并令它先调用你的 <code>swap</code> 成员函数</li>
</ul>
</li>
<li>最后，如果你调用 <code>swap</code>，请确定包含一个 <code>using</code> 声明，以便让 <code>std::swap</code> 在你的函数内曝光可见，然后不加任何 <code>namespace</code> 修饰符地调用 <code>swap</code>；</li>
</ul>
<h1 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>只要定义了一个变量而其类型带有一个构造函数或析构函数，那么</p>
<ul>
<li>当程序的控制流到达这个变量定义式时，你便得承受构造成本；</li>
<li>当这个变量离开作用域时，你便得承受析构成本；</li>
</ul>
<p>即使这个变量最终并未被使用，仍需耗费这些成本，所以你应尽可能避免这种情形，即延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。<br>当考虑循环时，有下列 2 种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义于循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 与i有关的某个值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义于循环内</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(与i有关的某个值)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2种写法的成本如下；</p>
<ul>
<li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B：n个构造函数 + n个析构函数</li>
</ul>
<p><strong>从效率上看</strong>：如果 class 的一个赋值成本低于一组构成+析构成本，做法 A 大体而言比较高效，尤其当 n 比较大时。否则做法 B 或许更好。<br><strong>从可理解性和维护性上看</strong>：A 造成名称 w 的作用域比做法 B 更大，可理解性和维护性相对较差。<br>因此，仅在一下情况考虑使用方法 A：</p>
<ol>
<li>你知道赋值成本比「构造 + 析构」成本低；</li>
<li>你正在处理代码中效率高度敏感的部分；</li>
</ol>
<h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型分类：</p>
<ul>
<li>C风格的转型  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T)expression   <span class="comment">//将expression转型为T</span></span><br><span class="line"><span class="built_in">T</span>(expression)   <span class="comment">//将expression转型为T</span></span><br></pre></td></tr></table></figure></li>
<li>C++提供的新式转型  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li>**<code>static_cast</code>**：只要不包含底层 <code>const</code>，都可以使用。适合将较大算术类型转换成较小算术类型（主要用于将派生类对象转为基类对象）；</li>
<li>**<code>const_cast</code>**：只能改变底层 <code>const</code>，例如指向 <code>const</code> 的指针 (指向的对象不一定是常量，但是无法通过指针修改)​，如果指向的对象是常量，则这种转换在修改对象时，结果未定义；</li>
<li>**<code>reinterpret_cast</code>**：通常为算术对象的位模式提供较低层次上的重新解释。如将<code>int*</code>转换成<code>char*</code>。很危险！</li>
<li>**<code>dynamic_cast</code><strong>：一种动态类型识别。转换的目标类型，即<code>type</code>，是指针或者左右值引用，</strong>主要用于基类指针转换成派生类类型的指针(或引用)**，通常需要知道转换源和转换目标的类型。如果​​转换失败，返回0（转换目标类型为指针类型时）或抛出<code>bad_cast</code>异常（转换目标类型为引用类型时）</li>
</ul>
</li>
</ul>
<p>应该尽可能使用新式转型：</p>
<ol>
<li>它们很容易在代码中被辨别出来（无论是人工还是使用工具如 <code>grep</code>），因而得以简化「找出类型系统在哪个地点被破坏」的过程；</li>
<li>各转型动作的目标越窄化，编译器越可能诊断出错误的运用；</li>
</ol>
<p><strong>尽量少做转型</strong>：</p>
<ol>
<li><p><strong>转型不只是告诉编译器把某种类型视为另一种类型这么简单。任何一个转型动作往往令编译器编译出运行期间执行的代码</strong>；</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例一</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y;</span><br><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base *pd = &amp;d;  <span class="comment">//隐式地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在示例一中：<code>int</code> 转型为 <code>double</code> 几乎肯定会产生一些代码，因为在大部分体系结构中，<code>int</code> 的底层表述不同于 <code>double</code> 的底层表述；</li>
<li>在示例二中：会有个偏移量在运行期被实施于 <code>Derived*</code> 指针身上，用以取得正确的 <code>Base*</code> 地址；</li>
</ul>
</li>
<li><p><strong>很容易写出似是而非的代码</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误的做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();  </span><br><span class="line">        ...  <span class="comment">//这里进行SpecialWindow专属行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Window::<span class="built_in">onResize</span>();  <span class="comment">//调用Window::onResize作用于*this身上</span></span><br><span class="line">        ...  <span class="comment">//这里进行SpecialWindow专属行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>继承中的类型转换效率低</strong></p>
<ul>
<li>C++通过 <code>dynamic_cast</code> 实现继承中的类型转换，<code>dynamic_cast</code> 的大多数实现效率都是相当慢的。因此，应该避免继承中的类型转换。一般需要 <code>dynamic_cast</code>，通常是因为想在一个认定为 derived <code>class</code> 对象身上执行 <code>derived class</code> 操作，但是拥有的是一个「指向 <code>base</code>」的指针或引用。这种情况下有 2 种办法可以避免转型：<ul>
<li><strong>使用容器并在其中存储直接指向 <code>derived class</code> 对象的指针</strong>：这种做法无法在同一个容器内存储指针「指向所有可能的各种派生类」。如果真要处理多种类型，可能需要多个容器，它们都必须具备类型安全性；</li>
<li><strong>将 <code>derived class</code> 中的操作上升到 <code>base class</code> 内，成为 <code>virtual</code> 函数，<code>base class</code> 提供一份缺省实现</strong>：缺省实现代码可能是个馊主意，条款 34 中有分析，但是也比使用 <code>dynamic_cast</code> 来转型要好；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回<code>handles</code>指向对象内部成分</h2><p>引用、指针和迭代器统统都是所谓的 <code>handles</code>。</p>
<h3 id="1）增加封装性"><a href="#1）增加封装性" class="headerlink" title="1）增加封装性"></a>1）增加封装性</h3><p>如果成员函数返回 <code>handles</code>，那么相当于成员变量的封装性从 <code>private</code> 上升到 <code>public</code>。这与<a href="#%E6%9D%A1%E6%AC%BE22%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate">条款22</a> 相悖。</p>
<h3 id="2）使得「通过const修改对象的数据」成为可能"><a href="#2）使得「通过const修改对象的数据」成为可能" class="headerlink" title="2）使得「通过const修改对象的数据」成为可能"></a>2）使得「通过const修改对象的数据」成为可能</h3><p>在<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a> 提到过「PIMPL 手法」，即：「以指针指向一个对象，内含真正数据」，也就是对象只包含指针成员，实际数据通过这个指针指向。而在<a href="#%E6%9D%A1%E6%AC%BE03%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款3</a> 中也提到，C++对 <code>const</code> 成员函数的要求是，符合 bitwise constness。因此，<code>const</code> 成员函数返回一个这个指针所指对象的引用，并不会造成指针被修改，也就符合 bitwise constness，但是通过这个引用却可以改变对象实际的数据。</p>
<h3 id="3）防止「虚吊」-dangle-发生"><a href="#3）防止「虚吊」-dangle-发生" class="headerlink" title="3）防止「虚吊」(dangle)发生"></a>3）防止「虚吊」(dangle)发生</h3><p>如果返回的 <code>handles</code> 指向一个临时对象，那么返回后临时对象销毁，<code>handles</code> 会成为「虚吊的」。只要 <code>handle</code> 被传出去，就会面临「<code>handle</code> 比其所指对象更长寿」的风险。</p>
<h2 id="条款29：为「异常安全」而努力是值得的"><a href="#条款29：为「异常安全」而努力是值得的" class="headerlink" title="条款29：为「异常安全」而努力是值得的"></a>条款29：为「异常安全」而努力是值得的</h2><p>考虑下面例子，有一个菜单类，<code>changeBg</code>函数可以改变它的背景，切换背景计数，同时提供线程安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span>&#123;</span></span><br><span class="line">    Mutex mutex;        <span class="comment">// 提供多线程互斥访问</span></span><br><span class="line">    Image *bg;          <span class="comment">// 背景图片</span></span><br><span class="line">    <span class="keyword">int</span> changeCount;    <span class="comment">// 切换背景计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBg</span><span class="params">(istream&amp; sr)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu::changeBg</span><span class="params">(istream&amp; src)</span></span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">delete</span> bg;</span><br><span class="line">    ++changeCount;</span><br><span class="line">    bg = <span class="keyword">new</span> <span class="built_in">Image</span>(src);</span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1）异常安全的2个条件"><a href="#1）异常安全的2个条件" class="headerlink" title="1）异常安全的2个条件"></a>1）异常安全的2个条件</h3><p><strong>异常安全有2个条件</strong>：</p>
<ol>
<li><strong>不泄露任何资源</strong>：即发生异常时，异常发生之前获得的资源都应该释放，不会因为异常而泄露。在上面的例子中，如果 <code>new Image</code> 发生异常，那么 <code>unlock</code> 就不会调用，因此锁资源会泄露；</li>
<li><strong>不允许数据败坏</strong>：上面的例子也不符合，如果 <code>new Image</code> 异常，背景图片会被删除，计数也会改变。但是新背景并未设置成功；</li>
</ol>
<p><strong>对于资源泄露</strong>，<a href="">条款13</a> 讨论过以对象管理资源。锁资源也可以为 <code>shared_ptr</code> 指定「删除器」，当引用为 0 时，即异常发生，管理所资源的对象被销毁后，删除器会调用 <code>unlock</code>。<br><strong>对于数据败坏</strong>：见下文。</p>
<h3 id="2）异常安全函数的3个保证"><a href="#2）异常安全函数的3个保证" class="headerlink" title="2）异常安全函数的3个保证"></a>2）异常安全函数的3个保证</h3><ol>
<li><strong>基本承诺</strong>：抛出异常后，对象仍然处于合法（valid）的状态，但不确定处于哪个状态；</li>
<li><strong>强烈保证</strong>：如果抛出了异常，状态并不会发生任何改变。就像没调用这个函数一样；</li>
<li><strong>不抛掷保证</strong>：这是最强的保证，函数总是能完成它所承诺的事情（作用于内置类型身上的所有操作都提供 <code>no throw</code> 保证。这是异常安全代码中一个必不可少的关键基础）</li>
</ol>
<p><strong><code>copy and swap</code> 策略</strong>：「<code>copy and swap</code>」设计策略通常能够<strong>为对象</strong>提供异常安全的「强烈保证」。当我们<strong>要改变一个对象时，先把它复制一份，然后去修改它的副本，改好了再与原对象交换</strong>。关于 swap 的详细讨论可以参见<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>。这种策略用在前面的例子中会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;MenuImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line">Menu::<span class="built_in">changeBg</span>(std::istream&amp; src)&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;            <span class="comment">// 见 Item 25</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;            <span class="comment">// 获得mutex的副本数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;MenuImpl&gt; <span class="title">copy</span><span class="params">(<span class="keyword">new</span> MenuImpl(*pImpl))</span></span>;</span><br><span class="line">    copy-&gt;bg.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(src)); <span class="comment">//修改副本数据</span></span><br><span class="line">    ++copy-&gt;changeCount;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pImpl, copy);              <span class="comment">//置换数据，释放mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>copy and swap</code> 策略能够<strong>为对象</strong>提供异常安全的「强烈保证」。但是一般而言，它并不保证整个函数有「强烈保证」。也就是说，如果某个函数使用 <code>copy and swap</code> 策略为某个对象提供了异常安全的「强烈保证」。但是这个函数可能调用其它函数，而这些函数可能改变一些全局状态（如数据库状态），那么整个函数就不是「强烈保证」。</p>
<blockquote>
<p>函数提供的「异常安全保证」通常最高只等于其所调用的各个函数的「异常安全保证」中的最弱者。</p>
</blockquote>
<p>除此之外，<code>copy and swap</code> 必须为每一个即将被改动的对象作出一个副本，从而可能造成时间和空间上的问题。</p>
<h3 id="3）最终目标是什么"><a href="#3）最终目标是什么" class="headerlink" title="3）最终目标是什么"></a>3）最终目标是什么</h3><p>当「强烈保证」不切实际时（比如前面提到的全局状态改变难以保证，或者效率问题），就必须提供「基本保证」。现实中你或许会发现，可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。<br>总的来说就是，应该为自己的函数努力实现尽可能高级别的异常安全，但是由于种种原因并不是说一定需要实现最高级别的异常安全，而是应该以此为目标而努力。</p>
<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><strong><code>inline</code> 的优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>较少函数调用的开销</strong></li>
<li><strong>编译器对<code>inline</code>的优化</strong></li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>目标代码的增加，程序体积增大，导致额外的换页行为，降低指令高速缓存装置的命中率</strong></li>
</ul>
</li>
</ul>
<p><code>inline</code> 提出方式包括 2 种：1）显式提出；2）隐式提出（类内实现成员函数）。<br><code>inline</code> 在大多数 C++程序中是<strong>编译期行为</strong>。<code>inline</code> 只是对编译器的一个申请，不是强制命令。大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数 <code>inline</code> 化，会给出一个警告。<br><strong>对 <code>virtual</code> 函数的调用也都会使 <code>inlining</code> 落空。因为 <code>virtual</code> 意味着等待，直到运行期才确定调用哪个函数，而 <code>inline</code> 意味着执行前，先将调用动作替换为被调用函数的本体</strong>。<br>如果程序要取某个 <code>inline</code> 函数的地址，编译器通常必须为此函数生成一个 <code>outlined</code> 函数本体。毕竟编译器没有能力提出一个指针指向并不存在的函数。<br>大部分的调试器面对 <code>inline</code> 函数都束手无策。因为无法在一个不存在的函数内设立断点。因此，一个合乎逻辑的策略是，一开始先不要将任何函数声明为 <code>inline</code>，或至少将 <code>inlining</code> 施行范围局限在那些「一定称为 <code>inline</code> 」或「十分平淡无奇」的函数身上。</p>
<h2 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h2><p>C++并没有把「将接口从实现中分离」这件事做得很好。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string theName;    <span class="comment">//实现细目</span></span><br><span class="line">    Date    theBirthDate;   <span class="comment">//实现细目</span></span><br><span class="line">    Address theAddress;     <span class="comment">//实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果没有前面 3 行引入头文件，那么编译无法通过。但是如此却<strong>会在 <code>Person</code> 定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些文件所依赖的其它头文件有任何改变。那么每个含入 <code>Person class</code> 的文件就得重新编译，任何使用 <code>Person class</code> 的文件也必须重新编译</strong>。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p>
<p>**1）一个办法是，可以把 <code>Person</code> 分割为两个类：</p>
<ul>
<li>一个只提供接口 (<code>Person</code>)；</li>
<li>一个负责实现接口 (<code>PersonImpl</code>)；就是使用<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a> 中的 PIMPL 手法：接口 <code>class</code> 中只包含一个负责实现接口的 <code>class</code> 的指针，因此任何改变都只是在负责实现接口的 <code>class</code> 中进行。那么 <code>Person</code> 的客户就完全与 <code>Date</code>， <code>Address</code>，以及 <code>Person</code> 的实现细目分离了。那些 <code>classes</code> 的任何实现修改都不需要 <code>Person</code> 客户端重新编译。此外，由于客户无法看到 <code>Person</code> 的实现细目，也就不可能写出什么「取决于那些细目的代码」。这正是接口与实现分类。这种情况下，像 <code>Person</code> 这样使用 PIMPL 的 <code>classes</code> 往往被称为 <code>handle classes</code>；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string&amp; name);</span><br><span class="line">    <span class="function">string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line">Person::<span class="built_in">Person</span>(string&amp; name): <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name))&#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">Person::name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>**2）另一种制作 <code>handle class</code> 的办法是，令 <code>Person</code> 成为一种特殊的 <code>abstract base class</code>，称为 <code>interface class</code>。其目的是详细描述 <code>derived classes</code> 的接口，因此它通常不带成员变量，也没有构造函数，只有一个 <code>virtual</code> 析构函数以及一组 <code>pure virtual</code> 函数，用来叙述整个接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户不能实例化它，只能使用它的引用和指针。然而客户一定需要某种方法来获得一个实例，比如工厂方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> shared_ptr&lt;Person&gt; <span class="title">create</span><span class="params">(string&amp; name)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(string&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shared_ptr&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function">shared_ptr&lt;Person&gt; <span class="title">p</span><span class="params">(Person::create(<span class="string">&quot;alice&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>应该让头文件自我满足</strong>，万一做不到，则让它与其他头文件内的声明式相依。其他每一件事都源自于这个简单的设计策略：</p>
<ul>
<li><strong>如果使用<code>object references</code>或<code>object pointers</code>可以完成任务，就不要使用<code>objects</code></strong></li>
<li><strong>如果能够，尽量以<code>class</code>声明式替换<code>class</code>定义式</strong>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>为声明式和定义式提供不同的头文件</strong>。为了促使这个准则，需要两个头文件：一个用于声明式，一个用于定义式。因此，上面的例子应该是这样：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;datefwd.h&quot;</span>    <span class="comment">//包含了class Date的声明</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六-继承与面向对象设计"><a href="#六-继承与面向对象设计" class="headerlink" title="六.继承与面向对象设计"></a>六.继承与面向对象设计</h1><h2 id="条款-32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款-32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的 public 继承塑模出 is-a 关系"></a>条款 32：确定你的 <code>public</code> 继承塑模出 <code>is-a</code> 关系</h2><p><strong><code>public</code> 继承隐含的寓意</strong>：每个派生类对象同时也是一个基类对象 (反之不成立)，只不过基类比派生类表现出更一般化的概念，派生类比基类表现出更特殊化的概念。<br>因此，C++中，任何函数如果期望获得一个类型为基类的实参，都也愿意接收一个派生类对象。但是反之不成立。谨记这种 <code>is-a</code> 关系以及背后隐藏的规则可以防止因为「经验主义」而使用不合理的继承。</p>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><h3 id="1）继承中的作用域嵌套"><a href="#1）继承中的作用域嵌套" class="headerlink" title="1）继承中的作用域嵌套"></a>1）继承中的作用域嵌套</h3><p>名字查找会从内层作用域向外层作用域延伸</p>
<h3 id="2）名称遮掩会遮掩基类所有重载版本"><a href="#2）名称遮掩会遮掩基类所有重载版本" class="headerlink" title="2）名称遮掩会遮掩基类所有重载版本"></a>2）名称遮掩会遮掩基类所有重载版本</h3><p>派生类中同名的名称会遮掩基类中相同的名称，如果基类包含重载函数，所有重载函数都会被遮掩。<br>解决办法是使用 <code>using</code> 引入被遮掩的名字。<br>如果只想引入基类被遮掩函数中某个版本（注意，这种需求一般只在 private 继承中出现，因为如果只继承基类的部分操作，违背了<a href="#%E6%9D%A1%E6%AC%BE32%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32</a>），可以直接定义一个同名同参的函数，然后在这个函数内调用基类的版本，做一个转调用。这实际上称为一种实现技术 (而不是引入) 更为恰当。</p>
<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><p><strong>纯虚函数一般作为接口，基类一般不提供定义，但是基类可以为纯虚函数提供定义</strong>。派生类必须声明纯虚函数，<strong>如果想要使用纯虚函数，派生类必须提供一份定义，即使基类已经为该纯虚函数提供了定义</strong>。如果派生类不提供定义，仍然是一个抽象基类</p>
<ol>
<li>声明一个 <code>pure virtual</code> 函数的目的是为了让 <code>derived classes</code><strong>只继承函数接口</strong>；</li>
<li>声明  <code>impure virtual</code> 函数的目的，是让 <code>derived classes</code> <strong>继承该函数的接口和缺省实现</strong>；</li>
<li>声明 <code>non-virtual</code> 函数的目的是为了令 <code>derived classes</code> <strong>继承函数的接口及一份强制性实现</strong>；</li>
</ol>
<h3 id="1）pure-virtual函数"><a href="#1）pure-virtual函数" class="headerlink" title="1）pure virtual函数"></a>1）<code>pure virtual</code>函数</h3><p>如果某个操作<strong>不同派生类应该表现出不同行为，并且没有相同的缺省实现</strong>，那么应该使用 <code>pure virtual</code> 函数，此时派生类只继承接口。</p>
<h3 id="2）impure-virtual函数"><a href="#2）impure-virtual函数" class="headerlink" title="2）impure virtual函数"></a>2）<code>impure virtual</code>函数</h3><p>如果某个操作<strong>不同派生类应该表现出不同行为，并且具有相同的缺省实现</strong>，那么应该使用 <code>impure virtual</code> 函数，此时派生类继承接口和缺省实现。<br><strong>但是，允许 <code>impure virtual</code> 函数同时指定函数声明和缺省行为，却可能造成危险：假设引入了一个新的派生类，但是缺省行为并不适用于新的派生类，而新的派生类忘记重新定义新的行为，那么调用该操作将表现出缺省行为，这是不合理的</strong>。<br>由于任何派生类想要使用 <code>pure virtual</code> 函数都必须提供一份定义，那么如果想要使用缺省行为，可以直接在定义中调用基类的实现。否则，可以定制特殊的行为。因为是纯虚函数，只要不定义就无法使用，因此也可以避免前面的问题。</p>
<h3 id="3）non-virtual函数"><a href="#3）non-virtual函数" class="headerlink" title="3）non-virtual函数"></a>3）<code>non-virtual</code>函数</h3><p>如果某个操作<strong>在整个体系中，应该表现出一致的行为</strong>，那么应该使用 <code>non-virtual</code> 函数。此时派生类继承接口和一份强制性实现。</p>
<h2 id="条款-35：考虑-virtual-函数以外的其他选择"><a href="#条款-35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款 35：考虑 virtual 函数以外的其他选择"></a>条款 35：考虑 <code>virtual</code> 函数以外的其他选择</h2><p>在面向对象中，如果<strong>希望某个操作存在缺省算法，并且各派生类可以定制适合自己的操作</strong>。可以使用 <code>public virtual</code> 函数，这是最简单直白且容易想到的方法，但是除此之外，也存在其它可替代的方案。它们有各自的优缺点，应该将所有方案全部列入考入。<br>以一个例子来介绍其它几种可替代方案。在一个游戏人物的类中，存在一个健康值计算的函数，不同的角色可以提供不同的健康值计算方法，并且存在一个缺省实现。以传统的 <code>public virtual</code> 函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">//健康值计算函数，派生类可以重新定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1）藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#1）藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="1）藉由Non-Virtual Interface手法实现Template Method模式"></a>1）藉由Non-Virtual Interface手法实现Template Method模式</h3><p>这种方案的主要思想是：保留 <code>healthValue</code> 为 <code>public</code> 成员，但是让其成为 <code>non-virtual</code>，并调用一个 <code>private</code> (也可以是 <code>protected</code>) <code>virtual</code> 函数进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...                             <span class="comment">//做一些事前工作</span></span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="built_in">doHealthValue</span>();   <span class="comment">//负责真正的健康值计算</span></span><br><span class="line">        ...                             <span class="comment">//做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span>   <span class="comment">//派生类可以重新定义</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...     <span class="comment">//缺省的健康值计算方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NVI 手法的一个优点是可以在真正操作进行的前后保证一些「事前」和「事后」工作一定会进行。如「事前」进行一些锁的分配，日志记录。「事后」进行解锁等操作。</p>
<blockquote>
<p> NVI（Non-Virtual Interface）是一种设计模式，用于在C++中实现将虚函数的调用封装在非虚成员函数中，以提供更好的灵活性和安全性。</p>
</blockquote>
<h3 id="2）藉由Function-Pointers实现Strategy模式"><a href="#2）藉由Function-Pointers实现Strategy模式" class="headerlink" title="2）藉由Function Pointers实现Strategy模式"></a>2）藉由Function Pointers实现Strategy模式</h3><p>上面的方案本质还是使用 <code>virtual</code> 函数，人物的健康值计算 (操作) 还是与人物 (类) 相关。后面这几种方案，都是将任务的健康值计算 (操作) 与具体的每个人 (对象) 相关，并且可以每个人 (对象) 的健康值计算 (操作) 可以修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>    <span class="comment">//前置声明</span></span><br><span class="line"><span class="comment">//健康值计算的缺省函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 定义函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 构造函数传递函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 实际执行函数</span></span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个人物(类)包含一个计算健康值的函数指针，每创建一个人(对象)时，可以为其指定不同的健康值计算函数。因此将操作和类分离。同时，如果提供修改函数指针成员的方法，每个对象还能使用不同的计算方法</p>
<h3 id="3）藉由tr1-function完成Strategy模式"><a href="#3）藉由tr1-function完成Strategy模式" class="headerlink" title="3）藉由tr1::function完成Strategy模式"></a>3）藉由tr1::function完成Strategy模式</h3><p>这种方案是前一种的加强，将函数指针改成任何可调用对象。因此允许任何与可调用声明相兼容(即可以通过类型转换与声明相符)的可调用物</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>    <span class="comment">//前置声明</span></span><br><span class="line"><span class="comment">//健康值计算的缺省函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//现在，类型HealthCalcFunc从函数指针变成了function对象</span></span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    <span class="comment">// 构造函数传递函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4）传统的Stategy模式"><a href="#4）传统的Stategy模式" class="headerlink" title="4）传统的Stategy模式"></a>4）传统的Stategy模式</h3><p>传统的 Stategy 模式做法会将健康计算函数做成一个分离的继承体系中的  <code>virtual</code> 成员函数，设计结果看起来像这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>    <span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">cacl</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个HealthCalcFunc对象，可以通过它调用缺省的健康值计算方法</span></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//non-virtual函数，virtual函数的包裹器(wrapper)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">cacl</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个方案的吸引力在于，熟悉标准 Strategy 模式的人很容易辨认它，而且它还提供「将一个既有的健康算法纳入使用」的可能性——只要为 <code>HealthCalcFunc</code> 继承体系添加一个 <code>derived class</code> 即可。</p>
<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的<code>non-virtual</code>函数</h2><p>从规范上说，<a href="#%E6%9D%A1%E6%AC%BE34%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34</a> 提到，如果某个操作在整个继承体系应该是不变的，那么使用 <code>non-virtual</code> 函数，此时派生类从基类继承接口以及一份强制实现。如果派生类希望表现出不同行为，那么应该使用 <code>virtual</code> 函数。<br>另一方面，假设真的重新定义了继承而来的 <code>non-virtual</code> 函数，会表现出下列令人困惑的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;  <span class="comment">//重新定义了继承而来的non-virtual函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D x;</span><br><span class="line">B *pB = &amp;x;</span><br><span class="line">D *pD = &amp;x;</span><br><span class="line"></span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();       <span class="comment">//调用B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();       <span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure>

<p>你可能会觉得因为 <code>pB</code> 和 <code>pD</code> 指向的是相同的对象，因此调用的 <code>non-virtual</code> 函数也应该相同，但是事实并非如此。因为 <code>non-virtual</code> 函数是静态绑定，因此实际上调用的函数由指针或引用决定。</p>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p><a href="#%E6%9D%A1%E6%AC%BE36%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0">条款36</a> 论述了 <code>non-virtual</code> 函数不应该被重新定义，那么 <code>non-virtual</code> 函数中的参数也就不存在被重新定义的机会。因此这里主要针对的是 <code>virtual</code> 函数。<br><strong>原因就在于，<code>virtual</code> 函数是动态绑定，而缺省参数值却是静态绑定</strong>。所以你可能调用了一个派生类的 <code>virtual</code> 函数，但是使用到的缺省参数，却是基类的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ShapeColor</span> &#123;</span>Red,Green,Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle r;</span><br><span class="line">Circle c;</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">draw</span>();           <span class="comment">//调用Rectangle::draw，静态类型为Rectangle，所以缺省参数为Shape::Green</span></span><br><span class="line"><span class="comment">//c.draw();         //调用Circle::draw，静态类型为Circle，没有缺省参数，因此错误，必须显式指定！</span></span><br><span class="line"></span><br><span class="line">Shape *pr = &amp;r;</span><br><span class="line">Shape *pc = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为容易引起困惑的地方，函数与参数不一致</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();         <span class="comment">//调用Rectangle::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span></span><br><span class="line">pc-&gt;<span class="built_in">draw</span>();         <span class="comment">//调用Shape::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span></span><br></pre></td></tr></table></figure>

<p>但是，即使派生类严格遵循基类的缺省参数，也存在问题：当基类的缺省参数发生变化时，派生类的所有缺省参数也需要跟着修改。因此，<strong>本质在于，不应该在<code>virtual</code>函数中使用缺省参数</strong>，如果有这样的需求，那么这种场景就适合使用<a href="#">条款35</a>中，<code>public virtual</code>函数的几种替代方案，比如NVI手法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ShapeColor</span> &#123;</span>Red,Green,Blue&#125;;</span><br><span class="line">    <span class="comment">//此时，带缺省参数的已经不是virtual函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);  <span class="comment">//调用一个virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//而完成真正工作的virtual函数已经不带缺省参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//完成真正的工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//而完成真正工作的virtual函数已经不带缺省参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//而完成真正工作的virtual函数已经不带缺省参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="条款-38：通过复合塑模出-has-a-或「根据某物实现出」"><a href="#条款-38：通过复合塑模出-has-a-或「根据某物实现出」" class="headerlink" title="条款 38：通过复合塑模出 has-a 或「根据某物实现出」"></a>条款 38：通过复合塑模出 <code>has-a</code> 或「根据某物实现出」</h2><p>复合是类型间的一种关系，当某种类型的对象含有另一种类型的对象，便是这种关系。<br>复合意味着 <code>has-a</code> (有一个) 或 <code>is-implemented-in-terms-of</code> (根据某物实现出)。</p>
<ul>
<li><code>has-a</code>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Address address;</span><br><span class="line">    PhoneNumber voiceNumber;</span><br><span class="line">    PhoneNumber faxNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>根据某物实现出：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;   <span class="comment">//底层容器</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面两者情况都应该使用复合，而不是 <code>public</code> 继承。在 <code>has-a</code> 中，每个人肯定不是一个地址，或者电话。显然不能是 <code>is-a</code> 的关系。而对于后者，由于每个栈只能从栈顶压入弹出元素，而队列不同，<code>is-a</code> 的性质是所有对基类为 <code>true</code> 的操作，对派生类也应该为 <code>true</code>。所以 <code>stack</code> 也不应该通过 <code>public</code> 继承 <code>deque</code> 来实现，因此使用复合。</p>
<h2 id="条款-39：明智而审慎地使用-private-继承"><a href="#条款-39：明智而审慎地使用-private-继承" class="headerlink" title="条款 39：明智而审慎地使用 private 继承"></a>条款 39：明智而审慎地使用 <code>private</code> 继承</h2><p><strong><code>private</code> 继承和 <code>public</code> 继承的不同之处</strong>：</p>
<ul>
<li><strong>编译器不会把子类对象转换为父类对象</strong>；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">private</span> Person &#123; ... &#125;;     <span class="comment">// private继承</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;                 <span class="comment">// 任何人都会吃</span></span><br><span class="line">Person p;                                  <span class="comment">// p是人</span></span><br><span class="line">Student s;                                 <span class="comment">// s是学生</span></span><br><span class="line"><span class="built_in">eat</span>(p);                                    <span class="comment">// 没问题，p是人，会吃</span></span><br><span class="line"><span class="built_in">eat</span>(s);                                    <span class="comment">// 错误！难道学生不是人？！</span></span><br></pre></td></tr></table></figure>
  如果使用 <code>public</code> 继承，编译器在必要的时候可以将 <code>Student</code> 隐式转换成 <code>Person</code>，但是 <code>private</code> 继承时不会，所以 <code>eat(s)</code> 调用失败。从这个例子中表达了，<code>private</code> 继承并不表现出 <code>is-a</code> 的关系。实际上**<code>private</code> 表现出的是 <code>is-implemented-in-terms-of</code> 的关系。</li>
<li>**父类成员（即使是 <code>public</code>、<code>protected</code>）都变成了 <code>private</code>**；</li>
</ul>
<p><a href="#%E6%9D%A1%E6%AC%BE38%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA">条款38</a>提到，复合也是可以表现出<code>is-implemented-in-terms-of</code>的关系，那么两者有什么区别？</p>
<h3 id="1）private-继承"><a href="#1）private-继承" class="headerlink" title="1）private 继承"></a>1）<code>private</code> 继承</h3><p>假设 <code>Widget</code> 类需要执行周期性任务，于是希望继承 <code>Timer</code> 的实现。因为 <code>Widget</code> 不是一个 <code>Timer</code>，所以选择了 <code>private</code> 继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;          <span class="comment">// 每滴答一次，该函数就被自动调用一次</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;           <span class="comment">// 查看Widget的数据...等等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>Widget</code> 中重写虚函数 <code>onTick</code>，使得 <code>Widget</code> 可以周期性地执行某个任务。<br>通过 <code>private</code> 继承来表现 <code>is-implemented-in-terms-of</code> 关系实现非常简单，而且下列情况也只能使用这种方式：</p>
<ul>
<li>当 <code>Widget</code> 需要访问 <code>Timer</code> 的 <code>protected</code> 成员时。因为对象组合后只能访问 <code>public</code> 成员，而 <code>private</code> 继承后可以访问 <code>protected</code> 成员。</li>
<li>当 <code>Widget</code> 需要重写 <code>Timer</code> 的虚函数时。比如上面的例子中，需要重写 <code>onTick</code>。单纯的复合是做不到的。</li>
</ul>
<h3 id="2）复合"><a href="#2）复合" class="headerlink" title="2）复合"></a>2）复合</h3><p>如果使用复合，上面的例子可以这样实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span>:</span> <span class="keyword">public</span> Timer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过复合来表现 <code>is-implemented-in-terms-of</code> 关系，实现较为复杂，但是具有下列优点：</p>
<ul>
<li>如果希望禁止 <code>Widget</code> 的子类重定义 <code>onTick</code>。因为派生类无法访问私有的 <code>WidgetTimer</code> 类；</li>
<li>可以减小 <code>Widget</code> 和 <code>Timer</code> 的编译依赖。如果是 <code>private</code> 继承，在定义 <code>Widget</code> 的文件中势必需要引入 <code>#include &quot;timer.h&quot;</code>。但如果采用复合的方式，可以把 <code>WidgetTimer</code> 放到另一个文件中，在 <code>Widget</code> 中使用 <code>WidgetTimer*</code> 并声明 <code>WidgetTimer</code> 即可；</li>
</ul>
<p>总的来说，在需要表现 <code>is-implemented-in-terms-of</code> 关系时。如果一个类需要访问基类的 <code>protected</code> 成员，或需要重新定义其一个或多个 <code>virtual</code> 函数，那么使用 <code>private</code> 继承。否则，在考虑过所有其它方案后，仍然认为 <code>private</code> 继承是最佳办法，才使用它。</p>
<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>使用多继承时，一个问题是不同基类可能具有相同名称，产生歧义（即使一个名字可访问，另一个不可访问）。<br>一般有两种方式使用多继承：</p>
<ul>
<li>一般的多重继承<ul>
<li>如果某个基类到派生类之间存在多条路径，那么派生类会包含重复的基类成员</li>
</ul>
</li>
<li>虚继承（此时基类是虚基类）<ul>
<li>如果某个基类到派生类之间存在多条路径，派生类只包含一份基类成员，但是这会带来额外开销<ul>
<li>为避免重复，编译器必须提供一些机制，后果就是 <code>virtual</code> 继承的那些 <code>classes</code> 所产生的对象往往比 <code>non-virtual</code> 继承的体积大，访问 <code>virtual base classes</code> 的成员变量时，速度也更慢；</li>
<li><code>virtual base</code> 的初始化由继承体系中的最底层 <code>class</code> 负责，这会带来开销<ul>
<li><code>classes</code> 若派生自 <code>virtual bases</code> 而需要初始化，必须认知其 <code>virtual bases</code>——无论那些 <code>bases</code> 距离多远</li>
<li>当一个新 <code>derived class</code> 加入继承体系中，它必须承担其 virtual ba<code>ses</code> 的初始化责任</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果你有一个单一继承的设计方案，而它大约等价于一个多重继承方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候是完成任务的最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎的情况下使用它</p>
<h1 id="七-模板与泛型编程"><a href="#七-模板与泛型编程" class="headerlink" title="七.模板与泛型编程"></a>七.模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><p>面向对象设计中的类（<code>class</code>）考虑的是显式接口（<code>explicit interface</code>）和运行时多态， 而模板编程中的<strong>模板（<code>template</code>）考虑的是隐式接口（<code>implicit interface</code>）和编译期多态</strong>。</p>
<ul>
<li>对类而言，显式接口是由函数签名表征的，运行时多态由虚函数实现；</li>
<li>对模板而言，隐式接口是由表达式的合法性表征的，编译期多态由模板初始化和函数重载的解析实现；</li>
</ul>
<h2 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 <code>typename</code> 的双重意义</h2><p>以下代码中， <code>typename</code> 和 <code>class</code> 等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure>

<p>但是如果在 <code>template</code> 中，遇到嵌套从属名称，需要明确声明是一种类型时，必须使用 <code>typename</code>。考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C::const_iterator *x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们认为 <code>C::const_iterator</code> 表示容器 <code>C</code> 的迭代器类型，因此上述代码定义一个该迭代器类型的指针。但是这是一种先入为主的思想。如果 <code>C:: const_iterator</code> 不是一个类型呢？比如恰巧有个 <code>static</code> 成员变量被命名为 <code>const_iterator</code>，或如果 <code>x</code> 碰巧是个 <code>global</code> 变量名称？那样的话上述代码就不再是声明一个 <code>local</code> 变量，而是一个相乘动作。<br>因此，C++有个规则解决这种歧义：<strong>如果解析器在 <code>template</code> 中遭遇一个嵌套从属名称，它便假设这个名称不是个类型，除非你告诉它是</strong>。所以缺省情况下嵌套从属名称不是类型。那么怎么告诉它是一个类型，当然就是 <code>typename</code> 了，所以上述代码应该像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> C::const_iterator *x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<strong>规则是：除了下面 2 个例外，任何时候当你想要在 <code>template</code> 中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字 <code>typename</code>：</strong></p>
<ol>
<li><strong><code>typename</code> 不可出现在 <code>base classes list</code> 内的嵌套从属名称之前</strong>；</li>
<li><strong><code>typename</code> 也不可出现在成员初始值列表中作为 <code>base class</code> 修饰符</strong>；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="comment">//typename不可出现在此</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //typename也不可出现在此</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;  <span class="comment">//这里必须使用typename</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>typename</code> 相关规则在不同的编译器上有不同的实践。某些编译器接收的代码原本该有 <code>typename</code> 却遗漏了；原本不该有 <code>typename</code> 却出现了；还有少数编译器（通常是较旧版本）根本就拒绝 <code>typename</code>。这意味 <code>typename</code> 和「嵌套从属名称」之间的互动，也会在移植性方面给你带来一些麻烦。</p>
<h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>假设以下 <code>MsgSender</code> 类可以通过两种方式发送信息到各个公司：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//1.发送原始文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(...);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.发送加密后的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设我们有时候想要在每次送出信息时志记（log）某些信息。因此有了以下派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将「传送前「的信息写至log；</span></span><br><span class="line">        <span class="built_in">sendClear</span>(...);             <span class="comment">//调用base class函数，无法通过编译</span></span><br><span class="line">        <span class="comment">//将」传送后「的信息写至log；</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在问题是，如果有一个公司 <code>CompanyZ</code> 只支持加密传送，那么泛化的 <code>MsgSender</code> 就不适合，因此需要为其产生一个特化版的 <code>MsgSender</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;</span>CompanyZ&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//只支持发送加密后的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，当 <code>base class</code> 被指定为 <code>MsgSender&lt;CompanyZ&gt;</code>时，其内不包含 <code>sendClear</code> 方法，那么 <code>derived class LoggingMsgSender</code> 的 <code>sendClearMsg</code> 方法就会调用不存在 <code>sendClear</code>。<br><strong>因此，正是因为知道 <code>base class templates</code> 有可能被特化，而那么特化版本可能不提供和一般性 <code>template</code> 相同的接口。因此 C++往往拒绝在 <code>templatized base classes</code>（模板化基类，本例的 <code>MsgSender&lt;Company&gt;</code>）内寻找继承而来的名称（本例的 <code>SendClear</code>）</strong>。<br><strong>解决办法有 3 个，它们会通知编译器: 进入 <code>base class</code> 作用域查找继承而来的名称</strong>：</p>
<ol>
<li>**使用 <code>this-&gt;</code>**； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将「传送前「的信息写至log；</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(...);     <span class="comment">//成立，假设sendClear将被继承</span></span><br><span class="line">        <span class="comment">//将」传送后「的信息写至log；</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>**使用 <code>using</code>**； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//告诉编译器，请它假设sendClear位于base class内</span></span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将「传送前「的信息写至log；</span></span><br><span class="line">        <span class="built_in">sendClear</span>(...);     <span class="comment">//成立，假设sendClear将被继承</span></span><br><span class="line">        <span class="comment">//将」传送后「的信息写至log；</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>通过作用域符明确指出</strong>； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将「传送前「的信息写至log；</span></span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(...);  <span class="comment">//成立，假设sendClear将被继承</span></span><br><span class="line">        <span class="comment">//将」传送后「的信息写至log；</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 这种方法往往最不让人满意，因为如果被调用的是 <code>virtual</code> 函数，这样会关闭「<code>virtual</code> 绑定行为」。</li>
</ol>
<p>要注意的是，它们只是通知编译器进去查找。如果找到了自然是没问题。但是如同上面的 <code>CompanyZ</code>，如果基类还是不存在相应名称，编译器还是会报错</p>
<h2 id="条款-44：将与参数无关的代码抽离-templates"><a href="#条款-44：将与参数无关的代码抽离-templates" class="headerlink" title="条款 44：将与参数无关的代码抽离 templates"></a>条款 44：将与参数无关的代码抽离 <code>templates</code></h2><p>模板提供的是编译期的多态，即使你的代码看起来非常简洁短小，生成的二进制文件也可能包含大量的冗余代码。因为模板每次实例化都会生成一个完整的副本，所以其中与模板参数无关的部分会造成代码膨胀。  把模板中参数无关的代码重构到模板外便可以有效地控制模板产生的代码膨胀：</p>
<ul>
<li><strong>对于「非类型模板参数」产生的代码膨胀，用函数参数或成员变量来替换模板参数即可消除冗余</strong>；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非类型模板参数造成代码膨胀</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;  <span class="comment">//求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下会实例化两个类：Square&lt;double, 5&gt;和Square&lt;double, 10&gt;</span></span><br><span class="line"><span class="comment">//会具现化两份invert。除了常量5和10，两个函数的其它部分完全相同</span></span><br><span class="line">Square&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; s1;</span><br><span class="line">Square&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; s2;</span><br><span class="line">s1.<span class="built_in">invert</span>();</span><br><span class="line">s2.<span class="built_in">invert</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下，使用函数参数消除重复</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareBase</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="comment">//以下函数只是作为避免代码重复的方法，并不应该被外界调用，</span></span><br><span class="line">    <span class="comment">//同时，该函数希望被子类调用，因此使用protected</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span><span class="keyword">private</span> SquareBase&lt;T&gt;&#123;<span class="comment">//只要T相同，都会使用同一份父类实例，</span></span><br><span class="line"><span class="keyword">private</span>:                           <span class="comment">//因此，只有一份invert(int size)</span></span><br><span class="line">    <span class="keyword">using</span> SquareBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//调用父类invert的代价为零，因为Square::invert是隐式的inline函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  最后是父类如何访问矩阵数据。原本这些数据在派生类中，但是因为 <code>invert</code> 核心代码转移到了父类，那么父类必须有办法访问这些数据。可以在调用 <code>SquareBase:: invert</code> 时把内存地址也一起告知父类，但如果矩阵类中有很多函数都需要这些信息就需要为每个函数添加一个这样的参数。因此，可以把数据地址直接放在父类中。</li>
<li><strong>对于类型模板参数产生的代码膨胀，可以让不同实例化的模板类共用同样的二进制表示</strong>；<ul>
<li><code>int</code> 和 <code>long</code> 在多数平台都是一样的底层实现，然而模板却会实例化为两份，因为它们类型不同；</li>
<li><code>List&lt;int *&gt;</code>，<code>List&lt;const int *&gt;</code>，<code>List&lt;double *&gt;</code> 的底层实现也是一样的。但因为指针类型不同，也会实例化为多份模板类；<br>如果某些成员函数操作强型指针（<code>T*</code>），应该令它们调用另一个操作无类型指针 (<code>void*</code>) 的函数，后者完成实际工作。</li>
</ul>
</li>
</ul>
<h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>需要使用成员函数模板的一个例子是构造函数和 <code>copying</code> 赋值运算符。例如，假设 <code>SmartPtr</code> 是一种智能指针，并且它是一个 <code>template class</code>。现在有一个继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>现在希望通过一个 <code>SmartPtr&lt;Bottom&gt;</code>或 <code>SmartPtr&lt;Middle&gt;</code>来初始化一个 <code>SmartPtr&lt;Top&gt;</code>。如果是指针，即 <code>Middle*</code>和 <code>Bottom*</code>可以隐式转换成 <code>Top*</code>，问题是：<strong>同一个 <code>template</code> 的不同具现体之间不存在什么与生俱来的固有关系，即使具现体之间具有继承关系</strong>。因此，**<code>SmartPtr&lt;Bottom&gt;</code>或 <code>SmartPtr&lt;Middle&gt;</code>并不能隐式转化成 <code>SmartPtr&lt;Top&gt;</code>**。因此，我们需要一个构造函数模板，来实现这种转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数模板</span></span><br><span class="line">    <span class="comment">//意思是：对任何类型T和任何类型U，可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;U&gt; &amp;other)</span></span></span><br><span class="line"><span class="function">     : heldPtr(other.get()) &#123;</span>...&#125;</span><br><span class="line">    <span class="comment">//原始指针为private成员，需要一个接口来获取</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;   <span class="comment">//智能指针所持有的原始指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们当然不希望一个 <code>SmartPtr&lt;Top&gt;</code> 可以转化成 <code>SmartPtr&lt;Bottom&gt;</code> 或 <code>SmartPtr&lt;Middle&gt;</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">最后需要指明的是：**`member templates`并不改变语言规则**，而语言规则说，如果程序需要一个 `copy`构造函数，你却没声明它，编译器会为你暗自生成一个。因此，使用 `member templates` 实现一个泛化版的`copy`构造函数时，编译器也会合成一个「正常的」`copy`构造函数。</span><br><span class="line"></span><br><span class="line">## 条款46：需要类型转换时请为模板定义非成员函数</span><br><span class="line">**`template` 实参推导过程中从不将隐式类型转换函数纳入考虑**，下列将[条款24](#条款24若所有参数皆需类型转换请为此采用non-member函数)中的 `Rational` 和 `operator*`改成了`template`，混合运算会编译错误：</span><br><span class="line">```c++</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Rational&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(const T &amp;numerator = 0, const T &amp;denominator = 1);</span><br><span class="line">    const T numerator() const;</span><br><span class="line">    const T denominator() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">const Rational&lt;T&gt; operator*(const Rational&lt;T&gt; &amp;lhs,const Rational&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Rational&lt;int&gt; oneHalt(1,2);</span><br><span class="line">Rational&lt;int&gt; result = oneHalf * 2   //编译错误</span><br></pre></td></tr></table></figure>

<p>将 <code>oneHalf</code> 传递给 <code>operator*</code> 时，它将 <code>T</code> 推断为 <code>int</code>，因此期待第二个参数也为 <code>Rational</code>，但是第二个参数为 <code>int</code>，前面我们说了，<code>template</code> 实参推导过程中从不将隐式类型转换函数纳入考虑。因此编译错误。<br>那么解决办法是什么？在 <code>class template</code> 将其声明为 <code>friend</code>，从而具现化一个 <code>operator*</code>，具现化后就可以不受 <code>template</code> 的限制了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//也可以是Rational&lt;T&gt;，但是省去&lt;T&gt;更简洁</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.numerator,</span><br><span class="line">                         lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果上面只有函数声明，而函数定义在类外，那么会报链接错误。当传入第一个参数 <code>oneHalt</code> 时，会具现化 <code>Rational&lt;int&gt;</code>，编译器也就知道了我们要调用传入两个 <code>Rational&lt;int&gt;</code> 的版本，但是那个函数只在类中进行了声明，并没有定义，不能依赖类外的 <code>operator* template</code> 提供定义，我们必须自己定义，所以会出现链接错误。解决方法就是像上面一样定义与类内。<br>这样看起来有点像是 <code>member</code> 函数，但是因为 <code>friend</code> 关键字，所以实际是 <code>non-member</code> 函数，如果去掉 <code>friend</code> 关键字，就成了 <code>member</code> 函数，但是此时参数也只能有 1 个，就不能实现所有参数的隐式转换。<br>上面的代码可能还有一个问题，虽然有 <code>friend</code>，上述函数仍是隐式的 <code>inline</code>。如果函数实体代码量较大，可以令 <code>operator*</code>不做任何事，只调用一个定义与 <code>class</code> 外部的辅助函数（当然这里没必要，因为本身只有 1 行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//helper template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用<code>traits classes</code>表现类型信息</h2><ul>
<li><code>Traits classes</code> 使得「类型相关信息」在编译期可用。它们以 <code>templates</code> 和「 <code>templates</code> 特化」完成实现；</li>
<li>整合重载技术后，<code>traits classes</code> 有可能在编译期对类型执行 <code>if...else</code> 测试；<h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2></li>
<li>Template metaprogramming（TMP）是编写 template-based C++程序并执行于编译期的过程；</li>
<li>Template metaprogram (模板元程序) 是<strong>以 C++写成、执行于 C++编译器内的程序</strong>；</li>
</ul>
<p><strong>TMP 的两个重要特点：1）基于 template；2）编译期执行</strong>。<br>TMP 有 2 个伟大的效力：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的；</li>
<li>执行于编译期，因此可将工作从运行期转移到编译期。会导致以下几个结果<ul>
<li>某些原本在运行期才能侦测到的错误现在可在编译期找出来；</li>
<li>使用 TMP 的 C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求；</li>
<li>编译时间变长了；</li>
</ul>
</li>
</ol>
<p><code>traits</code> 解法就是 TMP，<code>traits</code> 引发「编译器发生于类型身上的 <code>if...else</code> 计算」。<br>另一个 TMP 的例子是循环，TMP 并没有真正的循环构件，所以循环效果藉由递归完成。TMP 的递归甚至不是正常种类，因为 TMP 循环并不涉及递归函数调用，而是涉及「递归模板具现化」。以计算阶乘为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&#123;</span>    <span class="comment">//一般情况，Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;</span><span class="number">0</span>&gt;&#123;    <span class="comment">//特殊情况：Factorial&lt;0&gt;的值是1</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>value = <span class="number">1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;    <span class="comment">//打印120</span></span><br><span class="line">    std::cout &lt;&lt; Factorial&lt;<span class="number">10</span>&gt;::value;   <span class="comment">//打印3628800</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TMP能够达到以下目标（这部分可以等有实际需求了再去详细了解）：</p>
<ul>
<li>确保量度单位正确</li>
<li>优化矩阵运算</li>
<li>可以生成客户定制的设计模式实现品</li>
</ul>
<h1 id="八-定制new和delete"><a href="#八-定制new和delete" class="headerlink" title="八.定制new和delete"></a>八.定制new和delete</h1><ul>
<li><code>operator new</code> 和 <code>operator delete</code> 用来分配单一对象；</li>
<li><code>arrays</code> 所用的内存由 <code>operator new[]</code>分配出来，并由 <code>operator delete[]</code>归还；</li>
<li>STL 容器使用的堆内存由容器所拥有的分配器对象管理；</li>
</ul>
<h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p><code>operator new</code> 抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，<code>new_handler</code>，可以通过调用 <code>std::set_new_handler()</code> 来设置，<code>std::set_new_handler()</code> 定义在头文件 <code>&lt;new&gt;</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="comment">/** If you write your own error handler to be called by @c new, it must</span></span><br><span class="line"><span class="comment">   *  be of this type.  */</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Takes a replacement handler as the argument, returns the</span></span><br><span class="line">  <span class="comment">/// previous handler.</span></span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>operator new</code> 无法满足内存申请时，它会不断调用 <code>new_handler</code> 函数，直到找到足够内存。一个设计良好的 <code>new_handler</code> 函数必须做以下事情；</p>
<ul>
<li><strong>让更多内存可被使用</strong>：一个做法是程序一开始执行就分配一大块内存，而后当 <code>new_handler</code> 第一次被调用，将它们还给程序使用。这便造成 <code>operator new</code> 内的下一次内存分配动作可能成功；</li>
<li>**安装另一个 <code>new_handler</code>**：如果当前 <code>new_handler</code> 无法取得更多可用内存，可用安装的另一个，下次 <code>operator new</code> 时会调用新的 <code>new_handler</code>；</li>
<li>**卸除 <code>new_handler</code>**：将 <code>nullptr</code> 指针传给 <code>set_new_handler</code>；</li>
<li><strong>抛出 <code>bad_alloc</code> (或派生自 <code>bad_alloc</code>) 的异常</strong>：这样的异常不会被 <code>operator new</code> 捕获，因此会被传播到内存索求处；</li>
<li><strong>不返回</strong>：通常调用 <code>abort</code> 或 <code>exit</code>（<code>abort</code> 会设置程序非正常退出，<code>exit</code> 会设置程序正常退出，当存在未处理异常时 C++会调用 <code>terminate</code>，它会回调由 <code>std:: set_terminate</code> 设置的处理函数，默认会调用 <code>abort</code>）；</li>
</ul>
<h3 id="1）实现-class-专属的-new-handlers"><a href="#1）实现-class-专属的-new-handlers" class="headerlink" title="1）实现 class 专属的 new_handlers"></a>1）实现 <code>class</code> 专属的 <code>new_handlers</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span>: handler(nh)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>()&#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="keyword">const</span> HandlerHolder&amp;);     <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">const</span> NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;); <span class="comment">// 禁用赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler current;   <span class="comment">//class专属的new-handlers</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class专属的new-handlers初始化为null</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::current = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>()&#123;</span><br><span class="line">    std::new_handler old = current;</span><br><span class="line">    current = p;    <span class="comment">//将class专属的new-handlers设置为新的new_handler</span></span><br><span class="line">    <span class="keyword">return</span> old;     <span class="comment">//返回旧的class专属的new-handlers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new时会调用该operator new</span></span><br><span class="line"><span class="comment">//它会设置全局的new-handlers为该class专属的new-handlers，然后调用全局operator new申请内存</span></span><br><span class="line"><span class="comment">//h对象销毁后，其析构函数会将全局new-handlers恢复为调用前的状态</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> * NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(current))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 <code>NewHandlerSupport</code> 这个模板基类后，给 Widget 添加 <code>new_handler</code> 支持只需要 <code>public</code> 继承即可:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>`handler` 是静态成员，这样编译器才能为每个类型生成一个 `handler` 实例。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### nothrow new</span><br><span class="line">1993年之前C++的 `operator new` 在失败时会返回 `null` 而不是抛出异常。如今的C++仍然支持这种 `no throw` 的 `operator new`。</span><br><span class="line">```c++</span><br><span class="line">Widget *p1 = new Widget;    // 失败时抛出 bad_alloc 异常</span><br><span class="line">if(p1 == 0) ...             // 这个测试一定失败</span><br><span class="line"></span><br><span class="line">Widget *p2 = new (std::nothrow) Widget;</span><br><span class="line">if(p2 == 0) ...             // 这个测试可能成功</span><br></pre></td></tr></table></figure>

<p><code>nothrow new</code> 只能保证所调用的 <code>no throw</code> 版的 <code>operator new</code> 不抛出异常，但是构造也属于 <code>new</code> 的一个步骤，而它没法强制构造函数不抛出异常，所以并不能保证 <code>new (std::nothrow) Widget</code> 这样的表达式绝不导致异常。</p>
<h2 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 <code>new</code> 和 <code>delete</code> 的合理替换时机</h2><p>一般出于下列原因可能想要替换编译器提供的 <code>operator new</code> 或 <code>operator delete</code>：</p>
<ul>
<li>为了检测运用错误；</li>
<li>为了收集动态分配内存的使用统计信息；</li>
<li>为了增加分配和归还的速度；</li>
<li>为了降低缺省内存管理器带来的空间额外开销；</li>
<li>为了弥补缺省分配器中的非最佳齐位；</li>
<li>为了将相关对象成簇集中；</li>
<li>为了获得非传统的行为；</li>
</ul>
<p>下面是一个「为了检测运用错误」而实现的简单的 <code>operator new</code> 的例子，通过在首部和尾部插入一个签名，返回中间内存块给程序使用，如果程序在使用内存时发生过在区块前或区块后写入的行为，那么签名就会被修改，因此可以检测这种行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;    <span class="comment">// 边界符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多申请一些内存来存放占位符 </span></span><br><span class="line">    <span class="keyword">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">void</span> *pMem = <span class="built_in">malloc</span>(realSize);</span><br><span class="line">    <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入边界符</span></span><br><span class="line">    *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))) </span><br><span class="line">        = *(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回真正的内存区域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子主要是展示，它存在很多错误：</p>
<ol>
<li>所有的 <code>operator new</code> 都应该内含一个循环，反复调用某个 <code>new_handler</code> 函数，这里却没有；</li>
<li>C++要求所有 <code>operator new</code> 返回的指针都有适当的对齐。这里 <code>malloc</code> 返回的指针是满足要求的，但是因为上述实现并不是直接返回 <code>malloc</code> 的结果，而是返回一个 <code>int</code> 偏移后的地址，因此无法保证它的安全；</li>
</ol>
<h2 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 <code>new</code> 和 <code>delete</code> 时需固守常规</h2><p>前一条款是解释什么时候会想实现自己的 <code>operator new</code> 和 <code>operator delete</code>，这个条款是解释当实现自己的 <code>operator new</code> 和 <code>operator delete</code> 时，必须遵守的规则。</p>
<h3 id="1）operator-new-需要遵守的规则"><a href="#1）operator-new-需要遵守的规则" class="headerlink" title="1）operator new 需要遵守的规则"></a>1）<code>operator new</code> 需要遵守的规则</h3><p>实现一致性的 <code>operator new</code> 必得返回正确的值，内存不足时必得调用 <code>new_handler</code> 函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的 <code>new</code>。<br>下面是 <code>non-member operator new</code> 的伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;          <span class="comment">//处理0-byte申请</span></span><br><span class="line">        size = <span class="number">1</span>;           <span class="comment">//将它视为1-byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        尝试分配<span class="function">size bytes</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(分配成功)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="params">(一个指针，指向分配得来的内存)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="comment">//分配失败：找出目前的new-handling函数</span></span></span><br><span class="line"><span class="function">        new_handler globalHandler </span>= <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继承中定制 <code>member operator new</code> 时，一般是针对某特定 <code>class</code> 的对象分配行为提供最优化，此时，并不是为了该 <code>class</code> 的任何 <code>derived classes</code>。也就是说，针对 <code>class X</code> 而设计的 <code>operator new</code>，其行为很典型地只为大小刚好为 <code>sizeof (X)</code> 的对象而设计。然而一旦被继承下去，有可能 <code>base class</code> 的 <code>operator new</code> 被调用用以分配 <code>derived class</code> 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base  <span class="comment">//假设Derived未声明operator new</span></span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">Derived *p = <span class="keyword">new</span> Derived;    <span class="comment">//这里调用的是Base::operator new</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>Base class</code> 专属的 <code>operator new</code> 并没有设计上述问题的处理方法，那么最佳做法是将「内存申请量错误」的调用行为改采标准 <code>operator new</code>，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base))            <span class="comment">//如果大小错误</span></span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);    <span class="comment">//交给标准的operator new处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）operator-delete-需要遵守的规则"><a href="#2）operator-delete-需要遵守的规则" class="headerlink" title="2）operator delete 需要遵守的规则"></a>2）<code>operator delete</code> 需要遵守的规则</h3><p><code>operator delete</code> 比起 <code>operator new</code> 更简单，需要记住的唯一事情就是 C++保证「删除 null 指针永远安全」：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>)  <span class="keyword">return</span>;  <span class="comment">//如果将被删除的是个null指针，那就什么都不做</span></span><br><span class="line">    现在，归还rawMemory所指的内存；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>member</code> 版本也很简单，只需要多一个动作检查删除数量。万一 <code>class</code> 专属的 <code>operator new</code> 将大小有误的分配行为转交 <code>::operator new</code> 执行，你也必须将大小有误的删除行为转交 <code>::operator delete</code> 执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory,std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>)  <span class="keyword">return</span>;         <span class="comment">//检查null指针</span></span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base))&#123;           <span class="comment">//如果大小错误，令标准版</span></span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;   <span class="comment">//operator delete处理此一申请</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    现在，归还rawMemory所指的内存</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果即将被删除的对象派生自某个 <code>base class</code>，而后者欠缺 <code>virtual</code> 析构函数，那么 C++传给 <code>operator delete</code> 的 <code>size_t</code> 数值可能不正确。这是「让你的 <code>base classes</code> 拥有 <code>virtual</code> 析构函数」的一个够好的理由。</p>
<h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了<code>placement new</code>也要写<code>placement delete</code></h2><p><code>placement new</code> 是带有额外参数的 <code>operator new</code>，但是通常都指「接受一个指针指向对象该被构造之处」的 <code>operator new</code>。这个版本被纳入了 C++标准程序库，只要 <code>#include &lt;new&gt;</code>就可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>,<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>new</code> 会先调用 <code>operator new</code>，然后构造对象。如果对象构造过程中发生异常，那么需要调用相应的 <code>operator delete</code>，否则会发生内存泄露。而 <code>operator delete</code> 必须和相应的 <code>operator new</code> 匹配</p>
<ul>
<li>对于正常版本的 <code>operator new</code>，匹配的 <code>operator delete</code> 就是不带额外参数的版本；</li>
<li>对于非正常版本的 <code>operator new (placement new)</code>，匹配的 <code>operator delete</code> 是带相应参数的版本 (<code>placement delete</code>)；</li>
</ul>
<p>**<code>placement delete</code> 只有在「伴随 <code>placement new</code> 调用而触发的构造函数」出现异常时才会被调用。对着一个指针施行 <code>delete</code> 绝不会导致调用 <code>placement delete</code>**。<br>这意味着如果要对所有与 <code>placement new</code> 相关的内存泄露宣战，我们必须同时提供一个正常的 <code>operator delete</code>（用于构造期间无任何异常被抛出）和一个 <code>placement</code> 版本（用于构造期间有异常被抛出）。后者的额外参数必须和 <code>operator new</code> 一样。只要这样做，就再也不会因为难以察觉的内存泄露而失眠；  还需要注意名称掩盖的问题：</p>
<ul>
<li>成员函数的名称会掩盖外围作用域中的相同名称</li>
<li>子类的名称会掩盖所有父类相同的名称</li>
</ul>
<p>一个比较好的方法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardNewDeleteForms</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//正常的 new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//placement new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">void</span> *ptr)</span> <span class="title">throw</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, ptr); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">void</span> *ptr)</span> <span class="title">throw</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">delete</span></span>(pMemory, ptr); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, nt); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> StandardNewDeleteForms &#123;      <span class="comment">//继承标准形式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;     <span class="comment">//让这些形式可见</span></span><br><span class="line">   <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream&amp; log)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;    <span class="comment">// 自定义 placement new</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;            <span class="comment">// 对应的 placement delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/running/">跑步</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-number">1.</span> <span class="toc-text">一.让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.</span> <span class="toc-text">条款02：尽量以const,enum,inline替换#define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%BB%A5const%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.1.</span> <span class="toc-text">1）以const替换#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BB%A5enum%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.2.</span> <span class="toc-text">2）以enum替换#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%BB%A5inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.1.3.</span> <span class="toc-text">3）以inline替换#define</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.2.</span> <span class="toc-text">条款03：尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89const%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）const修饰变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89const%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）const修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">3）const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">条款04：确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">二.构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">条款05：了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">2.2.</span> <span class="toc-text">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">条款08：别让异常逃离析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">1）原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">2.4.2.</span> <span class="toc-text">2）如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">条款09：绝不在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-number">2.6.</span> <span class="toc-text">条款10：令operator&#x3D;返回一个reference to *this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operater-%E4%B8%AD%E5%A4%84%E7%90%86%E3%80%8C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E3%80%8D"><span class="toc-number">2.7.</span> <span class="toc-text">条款11：在operater&#x3D;中处理「自我赋值」</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">2.8.</span> <span class="toc-text">条款12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">三.资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">3.1.</span> <span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.</span> <span class="toc-text">条款14：在资源管理类中小心copying行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">3.3.</span> <span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">条款16：成对使用new和delete时要采取相同形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.5.</span> <span class="toc-text">条款 17：以独立语句将 new 的对象置入智能指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">四.设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">条款18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-number">4.2.</span> <span class="toc-text">条款19：设计class犹如设计type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value"><span class="toc-number">4.3.</span> <span class="toc-text">条款20：宁以pass-by-reference-to-const替换pass-by-value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-number">4.4.</span> <span class="toc-text">条款21：必须返回对象时，别妄想返回其reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-number">4.5.</span> <span class="toc-text">条款22：将成员变量声明为private</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AFpublic"><span class="toc-number">4.5.1.</span> <span class="toc-text">1）为什么不能是public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E9%82%A3%E4%B9%88protected%E8%A1%8C%E4%B8%8D%E8%A1%8C"><span class="toc-number">4.5.2.</span> <span class="toc-text">2）那么protected行不行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">条款23：宁以non-member、non-friend替换member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">条款24：若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">条款25：考虑写出一个不抛出异常的swap函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">五.实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">5.1.</span> <span class="toc-text">条款26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">5.3.</span> <span class="toc-text">条款28：避免返回handles指向对象内部成分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%A2%9E%E5%8A%A0%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">5.3.1.</span> <span class="toc-text">1）增加封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BD%BF%E5%BE%97%E3%80%8C%E9%80%9A%E8%BF%87const%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%8D%E6%88%90%E4%B8%BA%E5%8F%AF%E8%83%BD"><span class="toc-number">5.3.2.</span> <span class="toc-text">2）使得「通过const修改对象的数据」成为可能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E9%98%B2%E6%AD%A2%E3%80%8C%E8%99%9A%E5%90%8A%E3%80%8D-dangle-%E5%8F%91%E7%94%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">3）防止「虚吊」(dangle)发生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E3%80%8C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E3%80%8D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">5.4.</span> <span class="toc-text">条款29：为「异常安全」而努力是值得的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%842%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text">1）异常安全的2个条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E7%9A%843%E4%B8%AA%E4%BF%9D%E8%AF%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">2）异常安全函数的3个保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.4.3.</span> <span class="toc-text">3）最终目标是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">5.5.</span> <span class="toc-text">条款30：透彻了解inlining的里里外外</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E5%B0%86%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">5.6.</span> <span class="toc-text">条款31：将文件间的编译依存关系将至最低</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">六.继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">条款 32：确定你的 public 继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">6.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">1）继承中的作用域嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%90%8D%E7%A7%B0%E9%81%AE%E6%8E%A9%E4%BC%9A%E9%81%AE%E6%8E%A9%E5%9F%BA%E7%B1%BB%E6%89%80%E6%9C%89%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">6.2.2.</span> <span class="toc-text">2）名称遮掩会遮掩基类所有重载版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89pure-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">1）pure virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89impure-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">2）impure virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.3.</span> <span class="toc-text">3）non-virtual函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35%EF%BC%9A%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">6.4.</span> <span class="toc-text">条款 35：考虑 virtual 函数以外的其他选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%97%89%E7%94%B1Non-Virtual-Interface%E6%89%8B%E6%B3%95%E5%AE%9E%E7%8E%B0Template-Method%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">1）藉由Non-Virtual Interface手法实现Template Method模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%97%89%E7%94%B1Function-Pointers%E5%AE%9E%E7%8E%B0Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">2）藉由Function Pointers实现Strategy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%97%89%E7%94%B1tr1-function%E5%AE%8C%E6%88%90Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.3.</span> <span class="toc-text">3）藉由tr1::function完成Strategy模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E4%BC%A0%E7%BB%9F%E7%9A%84Stategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.4.</span> <span class="toc-text">4）传统的Stategy模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">条款36：绝不重新定义继承而来的non-virtual函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">6.6.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96%E3%80%8C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E3%80%8D"><span class="toc-number">6.7.</span> <span class="toc-text">条款 38：通过复合塑模出 has-a 或「根据某物实现出」</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">6.8.</span> <span class="toc-text">条款 39：明智而审慎地使用 private 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89private-%E7%BB%A7%E6%89%BF"><span class="toc-number">6.8.1.</span> <span class="toc-text">1）private 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%A4%8D%E5%90%88"><span class="toc-number">6.8.2.</span> <span class="toc-text">2）复合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.9.</span> <span class="toc-text">条款40：明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">七.模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%9A%E6%80%81"><span class="toc-number">7.1.</span> <span class="toc-text">条款41：了解隐式接口和编译器多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">条款 42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">7.3.</span> <span class="toc-text">条款43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-templates"><span class="toc-number">7.4.</span> <span class="toc-text">条款 44：将与参数无关的代码抽离 templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">条款45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">7.6.</span> <span class="toc-text">条款47：请使用traits classes表现类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE48%EF%BC%9A%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">条款48：认识template元编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete"><span class="toc-number">8.</span> <span class="toc-text">八.定制new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.1.</span> <span class="toc-text">条款49：了解new-handler的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AE%9E%E7%8E%B0-class-%E4%B8%93%E5%B1%9E%E7%9A%84-new-handlers"><span class="toc-number">8.1.1.</span> <span class="toc-text">1）实现 class 专属的 new_handlers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">条款 50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-51%EF%BC%9A%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-number">8.3.</span> <span class="toc-text">条款 51：编写 new 和 delete 时需固守常规</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89operator-new-%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">8.3.1.</span> <span class="toc-text">1）operator new 需要遵守的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89operator-delete-%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">8.3.2.</span> <span class="toc-text">2）operator delete 需要遵守的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE52%EF%BC%9A%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete"><span class="toc-number">8.4.</span> <span class="toc-text">条款52：写了placement new也要写placement delete</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&text=Effective C++总结"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&is_video=false&description=Effective C++总结"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Effective C++总结&body=Check out this article: http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&title=Effective C++总结"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&name=Effective C++总结&description=Effective C++知识点总结。"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/07/25/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/C%E5%92%8CC++/Effective%20C++/&t=Effective C++总结"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    ap0l1o
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/running/">跑步</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
